%% Discrete-time or continuous-time ARMA modeling starting from frequency domain data. %% Rik Pintelon, 21 October 2011%close allclear all%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition simulation parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%N = 5000;               % number of time domain samples% domain of the noise modelNoisePlane = 'z';       % discrete-timeNoisePlane = 's';     % continuous-time% NoisePlane = 'w';       % sqrt(s)-domainstde = 1;               % standard deviation driving white noiseTs = 1/5.5;             % sampling periodfs = 1/Ts;              % sampling frequencyfmin = 0.1;             % begin frequency band of interestfmax = 2;               % end frequency band of interest% selection of the corresponding DFT linesSelect = [floor(fmin/(fs/N))+1:1:floor(fmax/(fs/N))+1].';	% select from fmin to fmaxF = length(Select);                                         % number of frequencies in the frequency band of interestSelectAll = [1:1:N+1].';                                    % from DC to Nyquist on 2*N points for s-domainfreq = (Select-1)*fs/N;                                     % frequencies selected DFT linesfreqAll = ((SelectAll-1)/(2*N)/Ts);                         % frequencies all DFT linesif NoisePlane == 's'    sAll = sqrt(-1)*2*pi*freqAll;end % if s-domainif NoisePlane == 'w'    sAll = (sqrt(-1)*2*pi*freqAll).^0.5;end % if s-domainny = 2;                 % number of outputs ny < = 3%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition noise model transfer function %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%switch NoisePlane        case 'z'        c0 = [1 -1 0.9];        c0 = zeros(3,3,3);        c0(1,1,:) = [3.5666e-01   0.9830e-01   3.3444e-01];        c0(2,2,:) = [1 -1 0.9];        c0(3,3,:) = [9.6478e-01   -5.4142e-01   9.4233e-01];        c0(1,2,:) = [0.1 -0.05 0.07];        c0(2,1,:) = c0(1,2,:);        c0(2,1,end) = c0(2,1,end)*0.4;                d0 = [1 -0.2 0.85];            case 's'		c0 = zeros(3,3,3);		% entry 1,1		fz = 0.6;		deltaz = 0.1;		TheZero = 2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz);		c0(1,1,:) = fliplr(real(poly([TheZero,conj(TheZero)])));		% entry 2,2		fz = 1.2;		deltaz = 0.05;		TheZero = 2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz);		c0(2,2,:) = fliplr(real(poly([TheZero,conj(TheZero)])));		% entry 3,3		fz = 0.35;		deltaz = 0.15;		TheZero = 2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz);		c0(3,3,:) = fliplr(real(poly([TheZero,conj(TheZero)])));        c0(1,2,:) = 0.1*c0(3,3,:);        c0(2,1,:) = 0.1*c0(1,1,:);		fp1 = 0.25;		deltap1 = 0.2;		ThePole1 = 2*pi*sqrt(-1)*fp1*(1 + sqrt(-1)*deltap1);		fp2 = 1;		deltap2 = 0.05;		ThePole2 = 2*pi*sqrt(-1)*fp2*(1 + sqrt(-1)*deltap2);		d0 = real(poly([ThePole1,conj(ThePole1),ThePole2,conj(ThePole2)]));		d0 = fliplr(d0);        	case 'w',        % noise model		c0 = zeros(3,3,3);		% entry 1,1		fz = 0.6;		deltaz = 0.1;		TheZero = (2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz)).^0.5;		c0(1,1,:) = fliplr(real(poly([TheZero,conj(TheZero)])));		% entry 2,2		fz = 1.2;		deltaz = 0.05;		TheZero = (2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz)).^0.5;		c0(2,2,:) = fliplr(real(poly([TheZero,conj(TheZero)])));		% entry 3,3		fz = 0.35;		deltaz = 0.15;		TheZero = (2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz)).^0.5;		c0(3,3,:) = fliplr(real(poly([TheZero,conj(TheZero)])));        c0(1,2,:) = 0.1*c0(3,3,:);        c0(2,1,:) = 0.1*c0(1,1,:);				fp1 = 0.25;		deltap1 = 0.2;		ThePole1 = (2*pi*sqrt(-1)*fp1*(1 + sqrt(-1)*deltap1)).^0.5;		fp2 = 1;		deltap2 = 0.05;		ThePole2 = (2*pi*sqrt(-1)*fp2*(1 + sqrt(-1)*deltap2)).^0.5;		d0 = real(poly([ThePole1,conj(ThePole1),ThePole2,conj(ThePole2)]));		d0 = fliplr(d0);    end % switch% reduce to ny outputsc0 = c0(1:ny, 1:ny, :);nd = length(d0) - 1;        % order common denominator polynomialnc = size(c0, 3) - 1;       % order numerator matrix polynomial%%%%%%%%%%%%%%%%%%%%%%%%%%% Set the default values %%%%%%%%%%%%%%%%%%%%%%%%%%%% create the structures required for the MIMO_BoxJenkins function[Sel, Theta0, ModelVar, IterVar] = DefaultValues([], [], nc, nd, [], ny, [], NoisePlane, 'ARMA');if (ModelVar.NoisePlane == 's') || (ModelVar.NoisePlane == 'w')    nih = 4;                        % larger order transient term is needed in s-domain    ModelVar.nih = nih;    Sel.Ih = ones(ny, nih+1);end % if s-domain% true parameter values (except the noise transient parameters)Theta0.D = d0;for ii = 1:ny	for jj = 1:ny		Theta0.C(jj,ii,:) = c0(jj,ii,:);	endendnih = ModelVar.nih;Theta0.Ih = zeros(ny, nih+1);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation filtered white noise outputs %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Te = fliplr(hankel(ones(ny,1)));switch ModelVar.NoisePlane        case 'z'                % calculation N samples response in the time domain        e = randn(ny, N);        y = zeros(ny, N);        e = Te*e;        for jj=1:ny            for ii=1:ny                y(jj,:) = y(jj,:) + filter(squeeze(c0(jj,ii,:)),d0,e(ii,:));            end % ii        end % jj            case {'s','w'}                % calculation 2*N samples response in the frequency domain  		e = randn(ny, 2*N);		e = Te*e;		E = fft(e,[],2);		Y = zeros(ny, length(SelectAll));		for jj=1:ny			for ii=1:ny				Y(jj,:) = Y(jj,:) + ((polyval(fliplr(squeeze(c0(jj,ii,:)).'),sAll)./polyval(fliplr(d0),sAll)).').*E(ii,SelectAll);			end % ii		end % jj        % response on 2*N points		y = 2*real(ifft([zeros(ny,1),Y(:,2:end-1),zeros(ny,N)],[],2));        % selection first N samples 		y = y(:,1:N);        end % switch%%%%%%%%%%%%%%%%%%%%%%%%%%%% Data for identification %%%%%%%%%%%%%%%%%%%%%%%%%%%%% Selection of the frequency band of interestY = fft(y,[],2)/sqrt(N);Y = Y(:, Select);% filling out the data structure (ARMA => no data.U is needed)data.Y = Y;data.freq = freq;data.Ts = Ts;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Starting value noise model % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%FigNum = 1;ThetaStart = StartNoiseModel(data, [], Sel, ModelVar, IterVar, FigNum);%%%%%%%%%%%%%%%%%%%%%%%%%% Estimation ARMA model %%%%%%%%%%%%%%%%%%%%%%%%%%[Theta, Cost, smax, smin, wscale] = MIMO_BoxJenkins(data, Sel, ThetaStart, ModelVar, IterVar);%%%%%%%%%%%%%%%%%%%%%%%%%%% Cramer-Rao lower bound %%%%%%%%%%%%%%%%%%%%%%%%%%%[CRbound, Theta, CovThetan, Thetan, Seln, wscale, TheCond] = MIMO_CR_bound(data, Sel, Theta, ModelVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation true, estimated and measured noise power spectra %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%switch ModelVar.NoisePlane	case 'z', x.Noise = exp(-sqrt(-1)*2*pi*freq*Ts);	case 's', x.Noise = sqrt(-1)*2*pi*freq;	case 'w', x.Noise = (sqrt(-1)*2*pi*freq).^0.5;endx.Plant = ones(size(x.Noise));PolyTrans0 = CalcPolyTrans(Theta0, x);PolyTrans = CalcPolyTrans(Theta, x);S0 = CalcPowerSpectrum(PolyTrans0, Te*Te.');S = CalcPowerSpectrum(PolyTrans, Theta.CovE);Sy = zeros(ny,ny,F);for kk = 1:F	Sy(:,:,kk) = data.Y(:,kk)*data.Y(:,kk)';end % kk%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation true poles, resonance frequencies, %% damping ratios, time constants                 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the covariance has no meaning here% True noise poles[CovPoles0, Poles0] = CovRoots(Theta0.D, eye(nd+1), Sel.D, NoisePlane, Ts);%%%%%%%%%%%%%%%%%%%%%% Plot the results %%%%%%%%%%%%%%%%%%%%%% comparison data and estimated modelfigure(FigNum+1)clfmm = 0;for jj = 1:ny	for ii = 1:ny		mm = mm+1;        subplot(ny, ny, mm)        plot(freq, db(squeeze(Sy(jj,ii,:)))/2, 'k+', freq, db(squeeze(S(jj,ii,:)))/2, 'r');        xlabel('Frequency (Hz)')        ylabel('Noise power (dB)')	end % iiend % jjsubplot(ny, ny, ceil(ny/2));title('data: black; estimate: red');zoom on;shg% comparison true and estimated power spectrumfigure(FigNum+2)clfmm = 0;for jj = 1:ny	for ii = 1:ny		mm = mm+1;        subplot(ny, ny, mm)        plot(freq, db(squeeze(S0(jj,ii,:)))/2, 'k', freq, db(squeeze(S(jj,ii,:)))/2, 'r', ...             freq, db(squeeze(S0(jj,ii,:)-S(jj,ii,:)))/2, 'k--', freq, db(squeeze(CRbound.NoisePower(jj,ii,:)))/4, 'r--');        xlabel('Frequency (Hz)')        ylabel('Noise power (dB)')	end % iiend % jjsubplot(ny, ny, ceil(ny/2));title('true Power: black; estim.: red; diff.: black --; CR: red --');zoom on;shg% comparison true and estimated phase power spectrumfigure(FigNum+3)clfmm = 0;for jj = 1:ny	for ii = 1:ny		mm = mm+1;        subplot(ny, ny, mm)        plot(freq, angle(squeeze(S0(jj,ii,:)))*180/pi, 'k', freq, angle(squeeze(S(jj,ii,:)))*180/pi, 'r');        xlabel('Frequency (Hz)')        ylabel('Phase (°)')	end % iiend % jjsubplot(ny, ny, ceil(ny/2));title('true value: black; estim.: red');zoom on;shg% comparison true and estimated resonance frequencies noise: case 1, known reference signal disp('Estimates noise model')disp('Estim. f0 [Hz], std(f0) [Hz], estim. - true [Hz]')[Theta.noise.poles.freq, CRbound.noise.poles.freq.^0.5, Theta.noise.poles.freq-Poles0.freq]% comparison true and estimated damping ratios noise: case 1, known reference signal disp('Estim. damping, std(damping), estim. - true')[Theta.noise.poles.damp, CRbound.noise.poles.damp.^0.5, Theta.noise.poles.damp-Poles0.damp]