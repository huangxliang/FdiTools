function [Theta, Sel, Cost, smax, smin, wscale] = MIMO_BoxJenkins(data, Sel, Theta0, ModelVar, IterVar)%% [Theta, Sel, Cost, smax, smin, wscale] = MIMO_BoxJenkins(data, Sel, Theta0, ModelVar, IterVar);%%					%				Model class%					Box-Jenkins:		Y = B/A U + Ig/A  + C/D E + Ih/D%					OE:					Y = B/A U + Ig/A  + E				(no noise model)%					ARMA:				Y = C/D E + Ih/D					(no plant model)%					ARMAX:				Y = B/A U + C/A E + Ig/A%%				System with nu inputs and ny outputs%					Y:					ny x 1 observed output%					U:					nu x 1 observed input%					E:					ny x 1 unobserved zero mean white noise input with ny x ny covariance matrix CovE%%				Common denominator model%					G = B/A:			ny x nu plant transfer function%					H = C/D:			ny x ny noise transfer function%					Tg = Ig/A:			ny x 1 plant transient term%					Th = Ih/D:			ny x 1 noise transient term%					A:					polynomial of order OrderA%					B:					ny x nu matrix polynomial of order OrderB%					Ig:					ny x 1 vector polynomial of order OrderIg%					C:					ny x ny matrix polynomial of order OrderC%					D:					polynomial of order OrderD					%					Ih:					ny x 1 vector polynomial of order OrderIh%%				Coefficients polynomials in increasing powers of Omega, where%					s-domain			Omega = j*2*pi*freq%					sqrt(s)-domain		Omega = sqrt(j*2*pi*freq)%					z-domain			Omega = exp(-j*2*pi*freq*Ts)%										%       References:%%                   Pintelon R., and J. Schoukens (2006). Box-Jenkins identification revisited - Part I: theory, Automatica, %                   vol. 42, no. 1, pp. 63-75.%%                   Pintelon R., Y. Rolain, and J. Schoukens (2006). Box-Jenkins identification revisited - Part II: applications, %                   Automatica, vol. 42, no. 1, pp. 77-84.%%                   Pintelon, R., J. Schoukens, and P. Guillaume (2007). Box-Jenkins identification revisited - Part III: multivariable %                   systems, Automatica, vol. 43, no. 5, pp. 868-875.%%                   Pintelon, R., and J. Schoukens (2012). System Identification: A Frequency Domain Approach, second edition, %                   IEEE Press-Wiley, Piscataway (USA). %%%	Output parameters%%		Theta				=	estimated value plant, noise, and initial conditions parameters%								Theta = struct('A', [], 'B', [], 'Ig', [], 'C',[],'D',[], 'Ih', [])%									Theta.A     =   1 x (OrderA+1)%                                                       Theta.A(r) = coefficient a(r-1) of Omega^(r-1) %									Theta.B     =   ny x nu x (OrderB+1)%                                                       Theta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%									Theta.Ig    =   ny x (OrderIg+1)%                                                       Theta.Ig(i,r) = coefficient ig(i,r-1) of Omega^(r-1) %									Theta.C     =   ny x ny x (OrderC+1)%                                                       Theta.C(i,j,r) = coefficient c(i,j,r-1) of Omega^(r-1) %									Theta.D     =   1 x (OrderD+1)%                                                       Theta.D(r) = coefficient d(r-1) of Omega^(r-1)%									Theta.Ih    =   ny x (OrderIh+1)%                                                       Theta.Ih(i,r) = coefficient ih(i,r-1) of Omega^(r-1)%                                   Theta.CovE  =   covariance matrix ny x 1 driving white noise source %								Note:	all coefficients (except those for which Sel = 0) are free%										during the minimization + in each iteration step the following%										constraints are imposed:%											norm([a, vec(b), vec(ig)] = 1%											norm([d, vec(ih)]) = 1;%											sum(C(:,:,r).'*C(:,:,r)) = eye(ny)%											 r%%       Sel                 =   see input parameter; modified such that it is compatible with the required model structure%%		Cost				=	value of the cost function in the last iteration step%%		smax				=	largest singular value of the Jacobian matrix%%		smin				=	smallest singular value of the Jacobian matrix%%		wscale				=	structure containing the frequency scaling%									wscale = struct('Plant', [], 'Noise', [])%									wscale.Plant	=	angular frequency scaling plant model%									wscale.Noise	=	angular frequency scaling noise model%%%	Input parameters%%		data				=	structure containing the non-parametric data required for the identification%									data.Y		=	DFT spectrum ny x 1 output signal, dimensions ny x number of frequencies%									data.U		=	DFT spectrum nu x 1 input signal, dimensions: nu x number of frequencies %                                                   (ARMA modeling: empty or zeros(nu, number of frequencies)) %									data.freq	=	vector of frequency values (Hz), dimension: number of frequencies x 1%									data.Ts		=	sampling time (s)%									data.Gc		=	controller transfer function (feedback dynamics), must be given in case of a %                                                   system operating in feedback. Zero or empty if unknown or not present. %                                                   (optional, default zero) %                                                       size nu x ny x number of frequencies%%		Sel					=	structure with fields 'A', 'B', 'Ig', 'C', 'D', 'Ih'%									Sel = struct('A', [], 'B', [], 'Ig', [], 'C', [], 'D', [], 'Ih', [])%									Sel.A = 1 x (OrderA+1)%										Sel.A(r) = 1 if coeff. a(r-1) is unknown%										Sel.A(r) = 0 if coeff. a(r-1) = 0%									Sel.B = ny x nu x (OrderB+1)%										Sel.B(i,j,r) = 1 if coeff. b(i,j,r-1) is unknown%										Sel.B(i,j,r) = 0 if coeff. b(i,j,r-1) = 0%									Sel.Ig = ny x (OrderIg+1)%										Sel.Ig(i,r) = 1 if coeff. ig(i,r-1) is unknown%										Sel.Ig(i,r) = 0 if coeff. ig(i,r-1) = 0%									Sel.C = ny x ny x (OrderC+1)%										Sel.C(i,j,r) = 1 if coeff. c(i,j,r-1) is unknown%										Sel.C(i,j,r) = 0 if coeff. c(i,j,r-1) = 0%									Sel.D = 1 x (OrderD+1)%										Sel.D(r) = 1 if coeff. d(r-1) is unknown%										Sel.D(r) = 0 if coeff. d(r-1) = 0%									Sel.Ih = ny x (OrderIh+1)%										Sel.Ih(i,r) = 1 if coeff. ih(i,r-1) is unknown%										Sel.Ih(i,r) = 0 if coeff. ih(i,r-1) = 0%%		Theta0				=	starting value plant, noise, and initial conditions parameters%                               Theta0 = struct('A', [], 'B', [], 'Ig', [], 'C', [], 'D', [], 'Ih', [])%									Theta0.A    =   1 x (OrderA+1)%                                                       Theta0.A(r) = coefficient a(r-1) of Omega^(r-1) %									Theta0.B    =   ny x nu x (OrderB+1)%                                                       Theta0.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1) %									Theta0.Ig   =   ny x (OrderIg+1)%                                                       Theta0.Ig(i,r) = coefficient ig(i,r-1) of Omega^(r-1) %									Theta0.C    =   ny x ny x (OrderC+1)%                                                       Theta0.C(i,j,r) = coefficient c(i,j,r-1) of Omega^(r-1) %									Theta0.D    =   1 x (OrderD+1)%                                                       Theta0.D(r) = coefficient d(r-1) of Omega^(r-1)%									Theta0.Ih   =   ny x (OrderIh+1)%                                                       Theta0.Ih(i,r) = coefficient ih(i,r-1) of Omega^(r-1)%%		ModelVar			=	contains the information about the model to be identified%								ModelVar = struct('Transient', [], 'PlantPlane', [], 'NoisePlane', [], 'Struct', [], ...%                                                 'RecipPlant', [], 'RecipNoise')%									ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%									ModelVar.PlantPlane		=	plane of the plant model%																	's':	continuous-time;%																	'w':	sqrt(s)-domain%																	'z':	discrete-time;%																	'':		plane not defined%									ModelVar.NoisePlane		=	plane of the noise model%																	's':	continuous-time;%																	'w':	sqrt(s)-domain%																	'z':	discrete-time;%																	'':		plane not defined%									ModelVar.Struct			=	model structure%																	'BJ':		Box-Jenkins%																	'OE':		output error (plant model only)%																	'ARMA':		autoregressive moving average (noise model only)%																	'ARMAX':	autoregressive moving average with exogenous input%									ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%									ModelVar.RecipNoise		=	1 if noise model is reciprocal: H(i,j) = H(j,i)%%		IterVar				=	contains the information about the minimization procedure%								IterVar = struct('LM', [], 'MaxIter', [], 'TolParam', [], 'TolCost', [], ...%                                                'TraceOn', [], 'NormJacob', [])%									IterVar.LM 			=	1 then the Levenberg-Marquardt minimization scheme is used%									IterVar.MaxIter 	=	maximum number of itterations of the minimization procedure%									IterVar.TolParam 	=	relative precision on parameter estimates%									IterVar.TolCost 	=	relative precision on cost function%									IterVar.TraceOn 	=	1 then output iterations (optional, default 1)%									IterVar.NormJacob 	=	1 scales the columns of the Jacobian matrix such that the%                                                           columns have norm one (optional, default 1)%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, December 2004 % All rights reserved.% Software can be used freely for non-commercial applications only.% Version 17 October 2011%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Initialisation of the variables, and compatibility check of the input arguments %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% model structure variablesModelVar.PlantPlane = lower(ModelVar.PlantPlane);ModelVar.NoisePlane = lower(ModelVar.NoisePlane);ModelVar.Struct = upper(ModelVar.Struct);% add number of inputs and outputs to ModelVar% for an ARMA model structure the plant model does not existif strcmp(ModelVar.Struct, 'ARMA')	data.U = zeros(1, size(data.Y, 2));	data.Gc = zeros([1, size(data.Y)]);end % if ARMAModelVar.ny = size(data.Y,1);ModelVar.nu = size(data.U,1);% 1. imposes the compatibility of the parameter vector Theta0 and%    the free model parameters with the model structure% 2. puts the order of the polynomials in ModelVar% 4. checks whether the noise model transfer function is diagonal%    or not (C non-diag. => ny^2 constraints, C diag. => ny constraints)[Theta0, Sel, ModelVar] = ImposeModelCompatibility(Theta0, Sel, ModelVar);% iteration variablestry     if isempty(IterVar.TraceOn)        IterVar.TraceOn = 1;    end % ifcatch    IterVar.TraceOn = 1;end % trytry     if isempty(IterVar.NormJacob)        IterVar.NormJacob = 1;    end % ifcatch    IterVar.NormJacob = 1;end % try% presence feedback controllertry    if isempty(data.Gc)        data.Gc = zeros(ModelVar.nu, ModelVar.ny, length(data.freq));    end % empty Gccatch    data.Gc = zeros(ModelVar.nu, ModelVar.ny, length(data.freq));end % try% Check if DC and Nyquist belong to the frequency setif data.freq(1) == 0 data.DC = 1; else data.DC = 0; endif data.freq(end) == 1/(2*data.Ts) data.Nyquist = 1; else data.Nyquist = 0; end% angular frequency scaling for plant and noise modelwscale = struct('Plant', [], 'Noise', []);% jw, sqrt(jw), or exp(-jwTs) values for plant and noise modelx = struct('Plant', [], 'Noise', []);% matrix of powers of x xMat = struct('Plant', [], 'Noise', []);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% domain of the plant model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the vector x.plant represents z^-1, s, or sqrt(s) of the plant modelswitch ModelVar.PlantPlane	case {'s','w'}		if ModelVar.PlantPlane == 's'			x.Plant = sqrt(-1)*2*pi*data.freq;		elseif ModelVar.PlantPlane == 'w'			x.Plant = (sqrt(-1)*2*pi*data.freq).^(0.5);		end;		wscale.Plant = median(abs(x.Plant));		x.Plant = x.Plant/wscale.Plant;	case 'z'		x.Plant = exp(-sqrt(-1)*2*pi*data.freq*data.Ts);		wscale.Plant = 1;	case ''		x.Plant = ones(size(data.freq));		wscale.Plant = 1;	otherwise, disp('Invalid plant plane ...'), returnendnmax = max([ModelVar.na, ModelVar.nb, ModelVar.nig]);xMat.Plant = CalcMIMOBJOmegaMat(x.Plant, nmax);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% domain of the noise model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the vector x.Noise represents z^-1, s, or sqrt(s) of the noise modelswitch ModelVar.NoisePlane	case {'s','w'}		if ModelVar.NoisePlane == 's'			x.Noise = sqrt(-1)*2*pi*data.freq;		elseif ModelVar.NoisePlane == 'w'			x.Noise = (sqrt(-1)*2*pi*data.freq).^(0.5);		end;		wscale.Noise = median(abs(x.Noise));		x.Noise = x.Noise/wscale.Noise;	case 'z'		x.Noise = exp(-sqrt(-1)*2*pi*data.freq*data.Ts);		wscale.Noise = 1;	case ''		x.Noise = ones(size(data.freq));		wscale.Noise = 1;	otherwise, disp('Invalid noise plane ...'), returnendnmax = max([ModelVar.nc, ModelVar.nd, ModelVar.nih]);xMat.Noise = CalcMIMOBJOmegaMat(x.Noise, nmax);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Normalize the starting values for s-, and sqrt(s)-domains %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Theta0 = MIMONormalise(Theta0, wscale, ModelVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% maximum likelihood estimate of the model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% cost function starting valuesCost = MIMOCost(data, Theta0, x);% initialisation itertation parametersMaxRelErr = NaN;RelVarCost = NaN;DeltaCost = NaN;OldTheta = Theta0;OldCost = Cost;OldMaxRelErr = MaxRelErr;OldRelVarCost = RelVarCost;OldDeltaCost = DeltaCost;if IterVar.TraceOn == 1    home    disp([ModelVar.Struct, ' iteration # ', int2str(0)]);	fprintf('maximum relative variation parameters: %e \n',MaxRelErr);	fprintf('cost function (delta cost): %e (%e ) \n',Cost,DeltaCost);end% starting values onlyif IterVar.MaxIter < 1	Theta = OldTheta;    OldCost = inf;end% Newton-Gauss or Levenberg-Marquardt iteration loopLambda = 0;StartLM = 1; % initialization for Levenberg-Marquardt minimization schemeiii = 0;while iii <= IterVar.MaxIter	 iii = iii + 1;    	[Theta, Cost, smax, smin] = MIMONewtonGaussStep(data, x, xMat, OldTheta, Sel, ModelVar, IterVar, Lambda);		if ~((IterVar.LM == 1) && (Cost > OldCost))				% estimated parameters polynomial A		A = Theta.A(Sel.A == 1);		OldA = OldTheta.A(Sel.A == 1);		MaxRelErr = max([abs((A - OldA)./A)]);				% estimated parameters ny x nu matrix polynomial B		for ii = 1:ModelVar.ny			for jj = 1:ModelVar.nu				B = squeeze(Theta.B(ii, jj, Sel.B(ii,jj,:) == 1)).';				OldB = squeeze(OldTheta.B(ii, jj, Sel.B(ii,jj,:) == 1)).';				MaxRelErr = max([MaxRelErr, abs((B - OldB)./B)]);			end % jj		end % ii				% estimated parameters ny x 1 vector polynomial Ig		for ii = 1:ModelVar.ny			Ig = Theta.Ig(ii, Sel.Ig(ii,:) == 1);			OldIg = OldTheta.Ig(ii, Sel.Ig(ii,:) == 1);			MaxRelErr = max([MaxRelErr, abs((Ig - OldIg)./Ig)]);		end % ii				% estimated parameters ny x ny matrix polynomial C		for ii = 1:ModelVar.ny			for jj = 1:ModelVar.ny				C = squeeze(Theta.C(ii, jj, Sel.C(ii,jj,:) == 1)).';				OldC = squeeze(OldTheta.C(ii, jj, Sel.C(ii,jj,:) == 1)).';				MaxRelErr = max([MaxRelErr, abs((C - OldC)./C)]);			end % jj		end % ii				% estimated parameters polynomial D		D = Theta.D(Sel.D == 1);		OldD = OldTheta.D(Sel.D == 1);		MaxRelErr = max([MaxRelErr, abs((D - OldD)./D)]);				% estimated parameters ny x 1 vector polynomial Ih		for ii = 1:ModelVar.ny			Ih = Theta.Ih(ii, Sel.Ih(ii,:) == 1);			OldIh = OldTheta.Ih(ii, Sel.Ih(ii,:) == 1);			MaxRelErr = max([MaxRelErr, abs((Ih - OldIh)./Ih)]);		end % ii				DeltaCost = Cost - OldCost;			RelVarCost = abs(DeltaCost)/Cost;		OldTheta = Theta;		OldCost = Cost;		OldMaxRelErr = MaxRelErr;		OldRelVarCost = RelVarCost;		OldDeltaCost = DeltaCost;			end % if not Levenberg-Marquardt or if Cost <= OldCost		if IterVar.LM				if Cost > OldCost						if StartLM == 1				Lambda = smax^2;				StartLM = 0;		% initialization Lambda parameter is done			else				Lambda = 10*Lambda;			end % if start Levenberg-Marquardt						Theta = OldTheta;			Cost = OldCost;			MaxRelErr = OldMaxRelErr;			RelVarCost = OldRelVarCost;			DeltaCost = OldDeltaCost;					else						Lambda = 0.4*Lambda;					end % if Cost > OldCost			end % if Levenberg-Marquardt	if IterVar.TraceOn				home		disp([ModelVar.Struct, ' iteration # ', int2str(iii)]);		disp(['condition number:',num2str(smax/smin)]);		disp(['maximum relative variation parameters: ',num2str(MaxRelErr)]);	 	disp(['cost function (delta cost): ',num2str(Cost),' (',num2str(DeltaCost),')']);		if IterVar.LM == 1			disp(['Lambda factor Levenberg-Marquardt iteration scheme: ',num2str(Lambda)]);		end			end % if trace on		if (MaxRelErr < IterVar.TolParam) || (RelVarCost < IterVar.TolCost)		iii = IterVar.MaxIter + 1;	end % if relative variation parameters or cost function is small enough	end % while main iteration loop%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% rotate the polynomial C-matrix to make it as symmetric as possible %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if ~(ModelVar.DiagNoiseModel || ModelVar.RecipNoise)	Theta.C = MakeSymmetric(Theta.C);end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation CovE: normalisation and rotation influences the estimate of CovE % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[Cost, CovE] = MIMOCost(data, Theta, x);Theta.CovE = CovE;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% denormalize the estimated parameters for s-, and sqrt(s)-domains %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Theta = MIMODeNormalise(Theta, wscale, ModelVar);