function [CRbound, Theta, CovThetan, Thetan, Seln, wscale, TheCond] = MIMO_CR_bound(data, Sel, Theta, ModelVar)%% [CRbound, Theta, CovThetan, Thetan, Seln, wscale, TheCond] = MIMO_CR_bound(data, Sel, Theta, ModelVar);%%   Calculates the CR-bound of the following model structures%   (asymptotically, the influence of the transients is zero)%					%				Model class%					Box-Jenkins:		Y = B/A U + C/D E%					OE:					Y = B/A U + E				(no noise model)%					ARMA:				Y = C/D E					(no plant model)%					ARMAX:				Y = B/A U + C/A E%%				System with nu inputs and ny outputs%					Y:					ny x 1 observed output%					U:					nu x 1 observed input%					E:					ny x 1 unobserved zero mean white noise input with ny x ny covariance matrix CovE%%				Common denominator model%					G = B/A:			ny x nu plant transfer function%					H = C/D:			ny x ny noise transfer function%					A:					polynomial of order OrderA%					B:					ny x nu matrix polynomial of order OrderB%					C:					ny x ny matrix polynomial of order OrderC%					D:					polynomial of order OrderD					%%				Coefficients polynomials in raising powers of Omega, where%					s-domain			Omega = j*2*pi*freq%					sqrt(s)-domain		Omega = sqrt(j*2*pi*freq)%					z-domain			Omega = exp(-j*2*pi*freq*Ts)%					%										%       References:%%                   Pintelon, R., P. Guillaume, and J. Schoukens (2007). Uncertainty calculation in (operational) modal analysis, %                   Mechanical Systems and Signal Processing, vol. 21, no. 6, pp. 2359-2373.%%                   Pintelon, R., J. Schoukens, and P. Guillaume (2007). Box-Jenkins identification revisited - Part III: multivariable %                   systems, Automatica, vol. 43, no. 5, pp. 868-875.%%                   Pintelon, R., and J. Schoukens (2012). System Identification: A Frequency Domain Approach, second edition, %                   IEEE Press-Wiley, Piscataway (USA). %%%	Output parameters%%		CRbound				=	Cramer-Rao bound of the estimated physical model parameters, the estimated plant model, and the estimated noise model%								CRbound = struct('A', [], 'vecB',[], 'vecC', [], 'D', [], 'all', [], 'vecG', [], 'vecH', [], 'NoisePower', [])%									CRbound.A               =   FreeParam.A x FreeParam.A%                                                                   CRbound.A(i,j) = covariance between coefficients a(i-1) and a(j-1) %							        CRbound.AvecB           =   FreeParam.A x FreeParam.B%                                                                   CRbound.AvecB(i,j) = covariance between free coefficients a(i-1) and vecB(j) %									CRbound.vecB            =   FreeParam.B x FreeParam.B%                                                                   CRbound.vecB(i,j) = covariance between vecB(i) and vecB(j) where vecB = permute(B, [3, 1, 2]); vecB = vecB(:)%									CRbound.vecC            =   FreeParam.C x FreeParam.C%                                                                   CRbound.vecC(i,j) = covariance between vecC(i) and vecC(j) where vecC = permute(C, [3, 1, 2]); vecC = vecC(:) %									CRbound.D               =   FreeParam.D x FreeParam.D%                                                                   CRbound.D(i,j) = covariance between coefficients d(i-1) and d(j-1) %							        CRbound.DvecC           =   FreeParam.D x FreeParam.C%                                                                   CRbound.DvecC(i,j) = covariance between free coefficients d(i-1) and vecC(j) %									CRbound.vecG            =   (ny*nu) x (ny*nu) x F%                                                                   CRbound.vecG(i,j,r) = covariance between vecG(i,r) and vecG(j,r)%									CRbound.G               =   ny x nu x F%                                                                   CRbound.G(i,j,r) = variance G(i,j,r)%									CRbound.vecH            =   (ny^2) x (ny^2) x F%                                                                   CRbound.vecH(i,j,r) = covariance between vecH(i,r) and vecH(j,r)%									CRbound.H               =   ny x ny x F%                                                                   CRbound.H(i,j,r) = variance H(i,j,r)%									CRbound.NoisePower      = 	ny x ny x F%                                                                   CRbound.NoisePower(i,j,r) = variance (H*H')[i,j]%									CRbound.SqrtNoisePower	=	ny x ny x F%                                                                   CRbound.SqrtNoisePower(i,j,r) = variance sqrt((H*H')[i,j])%                                   CRbound.noise           =   struct('res', [], 'poles', []) %                                                                   covariance of the noise residue matrices and the noise poles  %                                   CRbound.noise.res       =   struct('all', 'sv', 'lsv', 'rsv') %                                                                   CRbound.noise.res.all	=   covariance matrix of (vec(Res))re; where ()re puts the real%                                                                                               and imaginary parts of the matrix on top of each other; vec()%                                                                                               stacks the columns of the matrix on top of each other; and Res%                                                                                               is a residue matrix of the ny x ny noise transfer function matrix H = C/D;%                                                                                                   size: (2*ny^2) x (2*ny^2) x na%                                                                   CRbound.noise.res.sv	=   variance singular values of the residues;%                                                                                                   size: ny x na%                                                                   CRbound.noise.res.lsv	=   covariance left singular vectors of the residues [real(ur); imag(ur)];%                                                                                                   size: 2*ny x 2*ny x ny x na%                                                                   CRbound.noise.res.rsv   =   covariance right singular vectors of the residues [real(vr); imag(vr)];%                                                                                                   size: 2*ny x 2*ny x ny x na%                                   CRbound.noise.poles     =   struct{'root', 'all', 'damp', 'freq', 'time'}%                                                                   CRbound.noise.poles.root	=   cov((root)re); where ()re stacks the real and imaginary part of the root%                                                                                                   on top of each other; ; size 2 x 2 x number of roots%                                                                   CRbound.noise.poles.all     =   Cov(roots.all) = cov((roots)re); where the real and imaginary parts of%                                                                                                   the vector roots are stacked on top of each other;%                                                                                                       size 2*(number of roots) x 2*(number of roots)%                                                                   CRbound.noise.poles.damp	=   variance damping complex roots; entry is NaN for real roots%                                                                   CRbound.noise.poles.freq	=   variance frequency complex roots; entry is NaN for real roots%                                                                   CRbound.noise.poles.time	=   variance time constant real roots; entry is NaN for complex roots%                                   CRbound.plant           =   struct('res', [], 'poles', []) %                                                                   covariance of the plant residue matrices and the plant poles  %                                   CRbound.plant.res       =   struct('all', 'sv', 'lsv', 'rsv') %                                                                   CRbound.plant.res.all	=   covariance matrix of (vec(Res))re; where ()re puts the real%                                                                                               and imaginary parts of the matrix on top of each other; vec()%                                                                                               stacks the columns of the matrix on top of each other; and Res%                                                                                               is a residue matrix of the ny x nu plant transfer function matrix G = B/A;%                                                                                                   size: (2*ny*nu) x (2*ny*nu) x na%                                                                   CRbound.plant.res.sv	=   variance singular values of the residues;%                                                                                                   size: min(ny, nu) x na%                                                                   CRbound.plant.res.lsv	=   covariance left singular vectors of the residues [real(ur); imag(ur)];%                                                                                                   size: 2*ny x 2*ny x min(ny, nu) x na%                                                                   CRbound.plant.res.rsv   =   covariance right singular vectors of the residues [real(vr); imag(vr)];%                                                                                                   size: 2*nu x 2*nu x min(ny, nu) x na%                                   CRbound.plant.poles     =   struct{'root', 'all', 'damp', 'freq', 'time'}%                                                                   CRbound.plant.poles.root	=   cov((root)re); where ()re stacks the real and imaginary part of the root%                                                                                                   on top of each other; ; size 2 x 2 x number of roots%                                                                   CRbound.plant.poles.all     =   Cov(roots.all) = cov((roots)re); where the real and imaginary parts of%                                                                                                   the vector roots are stacked on top of each other;%                                                                                                       size 2*(number of roots) x 2*(number of roots)%                                                                   CRbound.plant.poles.damp	=   variance damping complex roots; entry is NaN for real roots%                                                                   CRbound.plant.poles.freq	=   variance frequency complex roots; entry is NaN for real roots%                                                                   CRbound.plant.poles.time	=   variance time constant real roots; entry is NaN for complex roots%                                   Notes:%                                       - Theta = [A; vec(B); vec(C); D]; size: Number of free parameters x 1%                                       - vec(B) and vec(C) are calculated as follows: vecB = permute(B, [3, 1, 2]); vecB = vecB(:);%%       Theta               =   constrained physical model parameters, the free input parameters are defined in Seln, %                               and where the poles, residue matrices, and singular value decomposition of the residue matrices%                               of the noise and plant models have been added %									Theta.A     =   1 x (OrderA+1)%                                                       Theta.A(r) = coefficient a(r-1) of Omega^(r-1) %									Theta.B     =   ny x nu x (OrderB+1)%                                                       Theta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%									Theta.C     =   ny x ny x (OrderC+1)%                                                       Theta.C(i,j,r) = coefficient c(i,j,r-1) of Omega^(r-1) %									Theta.D     =   1 x (OrderD+1)%                                                       Theta.D(r) = coefficient d(r-1) of Omega^(r-1)%                                   Theta.CovE  =   real valued covariance matrix ny x 1 driving white noise source %                                   Theta.noise.res     =   struct{'all', 'sv', 'lsv', 'rsv'}%                                                               Theta.noise.res.all	= 	residue matrices of the noise transfer function matrix H = C/D;%                                                                                           size: ny x ny x na %                                                               Theta.noise.res.sv	=   singular values of the residue matrices;%                                                                                           size: ny x na%                                                               Theta.noise.res.lsv	=   left singular vectors of the residue matrices;%                                                                                           size: ny x ny x na%                                                               Theta.noise.res.rsv	=   right singular vectors of the residue matrices;%                                                                                           size: ny x ny x na%                                   Theta.noise.poles	=   struct{'root', 'damp', 'freq', 'time}%                                                               Theta.noise.poles.root	=   poles of the noise transfer function matrix H = C/D;%                                                                                               size na x 1%                                                               Theta.noise.poles.damp	=   damping ratio of the poles;%                                                                                               size na x 1%                                                               Theta.noise.poles.freq	=   resonance frequency in Hz of the poles;%                                                                                               size na x 1%                                                               Theta.noise.poles.time	=   time constant in seconds of the real poles;%                                                                                               size na x 1%                                   Theta.plant.res     =   struct{'all', 'sv', 'lsv', 'rsv'}%                                                               Theta.plant.res.all	= 	residue matrices of the plant transfer function matrix G = B/A;%                                                                                           size: ny x nu x na %                                                               Theta.plant.res.sv	=   singular values of the residue matrices;%                                                                                           size: min(ny, nu) x na%                                                               Theta.plant.res.lsv	=   left singular vectors of the residue matrices;%                                                                                           size: ny x min(ny, nu) x na%                                                               Theta.plant.res.rsv	=   right singular vectors of the residue matrices;%                                                                                           size: nu x min(ny, nu) x na%                                   Theta.plant.poles	=   struct{'root', 'damp', 'freq', 'time}%                                                               Theta.plant.poles.root	=   poles of the plant transfer function matrix G = B/A;%                                                                                               size na x 1%                                                               Theta.plant.poles.damp	=   damping ratio of the poles;%                                                                                               size na x 1%                                                               Theta.plant.poles.freq	=   resonance frequency in Hz of the poles;%                                                                                               size na x 1%                                                               Theta.plant.poles.time	=   time constant in seconds of the real poles;%                                                                                               size na x 1%                                   Notes:%                                       - the residues are sorted in the same order as the poles %                                       - the largest element of the right singular vector is made positive real%                                         by multiplying the left and right singular vectors by exp(-j*fi) where%                                         fi is the phase of the largest element of the right singular vector%                                       - for discrete-time systems the damping (damp), resonance frequency (freq), and time constants %                                         (time) are calculated via the inverse impulse invariant transformation s = log(z)/Ts %                                       - for w = sqrt(s) systems the damping (damp), resonance frequency (freq), and time constants %                                         (time) are calculated via the transformation s = w^2 %%		CovThetan           =	Cramer-Rao bound of the normalised estimated model parameters, the estimated plant model, and the estimated noise model%								CovThetan = struct('A', [], 'vecB',[], 'vecC', [], 'D', [], 'all', [], 'noise', [], 'plant', [])%                               See CRbound for the defintion of the structure. %                               Should be used for numerical stable calculation of uncertainty bounds; to guarantee the%                               positive semi-definiteness of %                                                 X.' * CovThetan * X %                               one should calculate%                                       (sqrtCovThetan * X).' * (sqrtCovThetan * X)  %                               where sqrtCovThetan is a square root of CovThetan calculated via an SVD. %%       Seln                =   structure containing the information about the estimated parameters of Thetan; see Sel in the input parameters%%		Thetan				=	(normalised) estimated plant and noise parameters (see input parameters) were the%								following constraints have been imposed:%                                       - in s-, sqrt(s) domains the parameters are normalised with wscale,%                                         for example, ar * s^r => (ar*wscale^r) * (s/wscale)^r%                                         where wscale.Plant and wscale.Noise are used for the plant and noise model%                                         parameters respectively%                                       - the following constraints on the (normalised) model parameters are imposed%                                           z-domain:               a(0) = d(0) = 1,%                                                                   c(k) = c(k) * CovE^(-1/2),%                                                                   c(0) is made symmetric through orthogonal transformations%                                                                        => (ny^2-ny)/2 constraints (upper triangular part of c(0))%                                           s-, sqrt(s)-domains:    a(na) = d(nd) = 1%                                                                   c(k) = c(k) * CovE^(-1/2),%                                                                   c(nc) is made symmetric through orthogonal transformations%                                                                         => (ny^2-ny)/2 constraints (upper triangular part of c(nc))%%		wscale				=	structure containing the frequency scaling%									wscale = struct('Plant', [], 'Noise', [])%									wscale.Plant	=	angular frequency scaling plant model%									wscale.Noise	=	angular frequency scaling noise model%%		TheCond				=	condition number Jacobian matrix used to calculate the CR-bound; cond(CR-bound) = TheCond^2%%%	Input parameters%%		data				=	structure containing the non-parametric data required for the identification%									data.Y		=	DFT spectrum ny x 1 output signal, size ny x number of frequencies%									data.U		=	DFT spectrum nu x 1 input signal, size: nu x number of frequencies%									data.freq	=	vector of frequency values (Hz), size: number of frequencies x 1%									data.Ts		=	sampling time (s)%									data.Gc		=	controller transfer function, zero or empty if unknown or not present,%                                                   (default zero), size nu x ny x number of frequencies %                                   data.R      =   optional, may be empty,%                                                   if not empty then either%                                                       - DFT spectrum reference signal compatible with U, Y and Gc, size nu x number of frequencies%                                                       - Power spectrum reference signal E{R*R'}, size nu x nu x number of frequencies%                                                   if empty then R is calculated as R = U + Gc * Y%%		Sel					=	struct('A', [], 'B', [], 'C', [], 'D', [])%									Sel.A       =   1 x (OrderA+1)%                                                       Sel.A(r) = 1 if coeff. a(r-1) is unknown%                                                       Sel.A(r) = 0 if coeff. a(r-1) = 0%									Sel.B       =   ny x nu x (OrderB+1)%                                                       Sel.B(i,j,r) = 1 if coeff. b(i,j,r-1) is unknown%                                                       Sel.B(i,j,r) = 0 if coeff. b(i,j,r-1) = 0%									Sel.C       =   ny x ny x (OrderC+1)%                                                       Sel.C(i,j,r) = 1 if coeff. c(i,j,r-1) is unknown%                                                       Sel.C(i,j,r) = 0 if coeff. c(i,j,r-1) = 0%									Sel.D       =   1 x (OrderD+1)%                                                       Sel.D(r) = 1 if coeff. d(i,j,r-1) is unknown%                                                       Sel.D(r) = 0 if coeff. d(i,j,r-1) = 0%%		Theta				=	estimated plant and noise parameters%								Theta = struct('A', [], 'B', [], 'C', [], 'D', [])%									Theta.A     =   1 x (OrderA+1)%                                                       Theta.A(r) = coefficient a(r-1) of Omega^(r-1) %									Theta.B     =   ny x nu x (OrderB+1)%                                                       Theta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%									Theta.C     =   ny x ny x (OrderC+1)%                                                       Theta.C(i,j,r) = coefficient c(i,j,r-1) of Omega^(r-1) %									Theta.D     =   1 x (OrderD+1)%                                                       Theta.D(r) = coefficient d(r-1) of Omega^(r-1)%                                   Theta.CovE  =   real valued covariance matrix ny x 1 driving white noise source %%		ModelVar			=	contains the information about the model to be identified%								struct('Transient', [], 'PlantPlane', [], 'NoisePlane', [], 'Struct', [], 'RecipPlant',[], 'RecipNoise')%									ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%									ModelVar.PlantPlane		=	plane of the plant model%																	's':	continuous-time;%																	'w':	sqrt(s)-domain%																	'z':	discrete-time;%																	'':		plane not defined%									ModelVar.NoisePlane		=	plane of the plant model%																	's':	continuous-time;%																	'w':	sqrt(s)-domain%																	'z':	discrete-time;%																	'':		plane not defined%									ModelVar.Struct			=	model structure%																	'BJ':		Box-Jenkins%																	'OE':		output error (plant model only)%																	'ARMA':		autoregressive moving average (noise model only)%																	'ARMAX':	autoregressive moving average with exogenous input%									ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%									ModelVar.RecipNoise		=	1 if noise model is reciprocal: H(i,j) = H(j,i)%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, April 2005 % All rights reserved.% Software can be used freely for non-commercial applications only.% Version 18 October 2011%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% initialisation of the variables, and compatibility check of the input arguments %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% model structure variablesModelVar.PlantPlane = lower(ModelVar.PlantPlane);ModelVar.NoisePlane = lower(ModelVar.NoisePlane);ModelVar.Struct = upper(ModelVar.Struct);% add number of inputs and outputs to ModelVar% for an ARMA model structure the plant model does not existif strcmp(ModelVar.Struct, 'ARMA')	data.U = zeros(1,size(data.Y,2));	data.Gc = zeros([1,size(data.Y)]);end % if ARMAModelVar.ny = size(data.Y,1);ModelVar.nu = size(data.U,1);% presence feedback controllertry    if isempty(data.Gc)        data.Gc = zeros(ModelVar.nu, ModelVar.ny, length(data.freq));    end % empty Gccatch    data.Gc = zeros(ModelVar.nu, ModelVar.ny, length(data.freq));end % try% 1. imposes the compatibility of the parameter vector Theta and%    the free model parameters with the model structure% 2. puts the order of the polynomials in ModelVar% 4. checks whether the noise model transfer function is diagonal%    or not (C non-diag. => ny^2 constraints, C diag. => ny constraints)[Theta, Sel, ModelVar] = ImposeModelCompatibility(Theta, Sel, ModelVar);% presence feedback controllerif isempty(data.Gc)	data.Gc = zeros(ModelVar.nu, ModelVar.ny, length(data.freq));end % empty Gc% check whether (power) spectrum reference signal is availabletry    NoReference = isempty(data.R);catch    NoReference = 1;endif NoReference	% calculation of the reference signal from the input/output data and the	% controller assuming that the initial conditions can be neglected	data = CalcReference(data);end % no reference (power) spectrum available% Check if DC and Nyquist belong to the frequency setif data.freq(1) == 0; data.DC = 1; else data.DC = 0; endif data.freq(end) == 1/(2*data.Ts); data.Nyquist = 1; else data.Nyquist = 0; end% angular frequency scaling for plant and noise modelwscale = struct('Plant', [], 'Noise', []);% jw, sqrt(jw), or exp(-jwTs) values for plant and noise modelx = struct('Plant', [], 'Noise', []);xn = struct('Plant', [], 'Noise', []);      % normalised values of x% matrix of powers of x xMat = struct('Plant', [], 'Noise', []);CovThetan = struct('A', [], 'vecB', [], 'AvecB', [], 'vecC', [], 'D', [], 'DvecC', [], 'all', [], 'noise', [], 'plant', []);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% domain of the plant model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the vector s represents z^-1, s, or sqrt(s) of the plant modelswitch ModelVar.PlantPlane	case {'s','w'}		if ModelVar.PlantPlane == 's'			x.Plant = sqrt(-1)*2*pi*data.freq;		elseif ModelVar.PlantPlane == 'w'			x.Plant = (sqrt(-1)*2*pi*data.freq).^(0.5);		end;		wscale.Plant = median(abs(x.Plant));	case 'z'		x.Plant = exp(-sqrt(-1)*2*pi*data.freq*data.Ts);		wscale.Plant = 1;	case ''		x.Plant = ones(size(data.freq));		wscale.Plant = 1;	otherwise, disp('Invalid plant plane ...'), returnend% normalized x-valuexn.Plant = x.Plant/wscale.Plant;nmax = max([ModelVar.na, ModelVar.nb, ModelVar.nig]);xMat.Plant = CalcMIMOBJOmegaMat(xn.Plant, nmax);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Domain of the noise model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the vector q represents z^-1, s, or sqrt(s) of the noise modelswitch ModelVar.NoisePlane	case {'s','w'}		if ModelVar.NoisePlane == 's'			x.Noise = sqrt(-1)*2*pi*data.freq;		elseif ModelVar.NoisePlane == 'w'			x.Noise = (sqrt(-1)*2*pi*data.freq).^(0.5);		end;		wscale.Noise = median(abs(x.Noise));	case 'z'		x.Noise = exp(-sqrt(-1)*2*pi*data.freq*data.Ts);		wscale.Noise = 1;	case ''		x.Noise = ones(size(data.freq));		wscale.Noise = 1;	otherwise, disp('Invalid noise plane ...'), returnend% normalized x-valuexn.Noise = x.Noise/wscale.Noise;nmax = max([ModelVar.nc, ModelVar.nd, ModelVar.nih]);xMat.Noise = CalcMIMOBJOmegaMat(xn.Noise, nmax);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Normalise the model parameters for s-, and sqrt(s)-domains %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Thetan = MIMONormalise(Theta, wscale, ModelVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Impose constraints on the (normalised) model parameters      %%   z-domain:           a0 = d0 = 1                            %%   s-, sqrt(s)-domain: ana = dnd = 1                          %%   the C-coefficients are normalised such that CovE = eye(ny) %% and modify the free model parameter selection accordingly    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% impose the constraints on the model parameters[Thetan, Seln] = ConstrainModel(Thetan, Sel, ModelVar);% store all the normalised estimated parameters because% later the plant and noise transient terms are deletedSaveThetan = Thetan;   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Cramer-Rao lower bound of the free model parameters %%   CRBound.A                                         %%   CRbound.vecB                                      %%   CRbound.vecC                                      %%   CRbound.D                                         %   %   CRbound.Theta                                     %   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculation polynomials and transfer functionsPolyTrans = CalcPolyTrans(Thetan, xn);% Since they are asymptotically zero, the Cramer-Rao lower bound is not % calculated for the plant and noise transient termsModelVar.Transient = 0;ModelVar.nig = 0;ModelVar.nih = 0;Seln.Ig = zeros(ModelVar.ny, 1);Seln.Ih = zeros(ModelVar.ny, 1);Thetan.Ig = zeros(ModelVar.ny, 1);Thetan.Ih = zeros(ModelVar.ny, 1);PolyTrans.Tg = zeros(size(PolyTrans.Tg));PolyTrans.Th = zeros(size(PolyTrans.Th));% calculate the derivative of the transfer functions w.r.t. the model parametersDeriv = CalcDeriv(xMat, PolyTrans, ModelVar);% derivatives of the hermitian transpose of the plant and noise transfer functions% w.r.t. the model parametersDeriv.vecGHa = DvecZ_2_DvecZH(Deriv.vecGa, ModelVar.ny, ModelVar.nu);Deriv.vecGHb = DvecZ_2_DvecZH(Deriv.vecGb, ModelVar.ny, ModelVar.nu);Deriv.vecHHc = DvecZ_2_DvecZH(Deriv.vecHc, ModelVar.ny, ModelVar.ny);Deriv.vecHHd = DvecZ_2_DvecZH(Deriv.vecHd, ModelVar.ny, ModelVar.ny);[CRbound, sqrtCRbound, TheCond] = CRmodelparameters(PolyTrans, Deriv, Seln, ModelVar, data);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Poles and residue matrices of the plant model G = B/A % % and their Cramer-Rao lower bound                      %%   CRbound.plant.poles                                 %%   CRbound.plant.res                                   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if ~strcmp(ModelVar.Struct, 'ARMA')        % calculate plant poles and residue matrices and their covariances    [CovParam, Param] = CovResidues(Thetan, CRbound, Seln, ModelVar.PlantPlane, data.Ts);    % add poles and residue matrices to Thetan    Thetan.plant.poles = Param.poles;    Thetan.plant.res = [];    Thetan.plant.res.all = Param.res;    Thetan.plant.res.sv = Param.sv;    Thetan.plant.res.lsv = Param.lsv;    Thetan.plant.res.rsv = Param.rsv;    % add poles and residue matrices to CRbound    CRbound.plant = [];    CRbound.plant.poles = CovParam.poles;    CRbound.plant.res = CovParam.res;    else % ARMA model        Thetan.plant.poles = [];    Thetan.plant.res = [];    CRbound.plant = [];    CRbound.plant.poles = [];    CRbound.plant.res = [];    end % if not ARMA model%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Poles and residue matrices of the noise model H = C/D % % and their Cramer-Rao lower bound                      %%   CRbound.noise.poles                                 %%   CRbound.noise.res                                   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if ~strcmp(ModelVar.Struct, 'OE')        % calculate noise poles and residue matrices and their covariances    CRdummy.A = CRbound.D;    CRdummy.vecB = CRbound.vecC;    CRdummy.AvecB = CRbound.DvecC;    Theta_dummy.A = Thetan.D;    Theta_dummy.B = Thetan.C;    if strcmp(ModelVar.Struct, 'ARMAX')        Sel_dummy.A = Seln.A;           % noise poles = plant poles    else % not ARMAX        Sel_dummy.A = Seln.D;    end % if ARMAX    Sel_dummy.B = Seln.C;    [CovParam, Param] = CovResidues(Theta_dummy, CRdummy, Sel_dummy, ModelVar.NoisePlane, data.Ts);    % add poles and residue matrices to Thetan    Thetan.noise.poles = Param.poles;    Thetan.noise.res = [];    Thetan.noise.res.all = Param.res;    Thetan.noise.res.sv = Param.sv;    Thetan.noise.res.lsv = Param.lsv;    Thetan.noise.res.rsv = Param.rsv;    % add poles and residue matrices to CRbound    CRbound.noise = [];    CRbound.noise.poles = CovParam.poles;    CRbound.noise.res = CovParam.res;    else % OE model        Thetan.noise.poles = [];    Thetan.noise.res = [];    CRbound.noise = [];    CRbound.noise.poles = [];    CRbound.noise.res = [];end % if not OE model%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Cramer-Rao lower bound of the plant and noise transfer functions %% and the noise power spectra and their square root                %%   CRBound.vecG                                                   %%   CRbound.vecH                                                   %%   CRBound.NoisePower                                             %%   CRbound.SqrtNoisePower                                         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%CRbound = CRtransferfunctions(CRbound, sqrtCRbound, PolyTrans, Deriv, Seln, ModelVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CR-bound of the estimated normalised parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%CovThetan = struct('A', [], 'vecB', [], 'AvecB', [], 'vecC', [], 'D', [], 'DvecC', [], 'all', [], 'plant', [], 'noise', []);CovThetan.A = CRbound.A;CovThetan.vecB = CRbound.vecB;CovThetan.AvecB = CRbound.AvecB;CovThetan.D = CRbound.D;CovThetan.vecC = CRbound.vecC;CovThetan.DvecC = CRbound.DvecC;CovThetan.all = CRbound.all;CovThetan.plant.poles = CRbound.plant.poles;CovThetan.plant.res = CRbound.plant.res;CovThetan.noise.poles = CRbound.noise.poles;CovThetan.noise.res = CRbound.noise.res;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CR-bound of the estimated physical model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% denormalisation CR-bounds noise model parametersSel_dummy = Seln;% if ARMAX then the noise poles = plant polesif strcmp(ModelVar.Struct, 'ARMAX')    Sel_dummy.D = Sel_dummy.A;end % if ARMAX modelCRbound = CRboundPhysicalParam(CRbound, Sel_dummy, wscale, ModelVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Restore the estimated plant and noise transient parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Thetan.Ig = SaveThetan.Ig;Thetan.Ih = SaveThetan.Ih;Seln.Ig = Sel.Ig;Seln.Ih = Sel.Ih;% set Transient = 1 otherwise the transient parameters are% not denormalizedModelVar.Transient = 1;% restore the order of the transient polynomialsModelVar.nig = size(Thetan.Ig, 2) - 1;ModelVar.nih = size(Thetan.Ih, 2) - 1;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation of the constrained physical model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Thetan: constrained normalised parameters% Theta: constrained physical parametersTheta = MIMODeNormalise(Thetan, wscale, ModelVar);% calculate the covariance of the unobserved driving noise source[Cost, CovE] = MIMOCost(data, Theta, x);Theta.CovE = CovE;% denormalisation residue matrices and poles of the plant modelif strcmp(ModelVar.PlantPlane, 's') || strcmp(ModelVar.PlantPlane, 'w')        wscale1 = wscale.Plant;    switch ModelVar.PlantPlane         case 's'            wscale2 = wscale.Plant;        case 'w'            % poles are squared in sqrt(s)-domain before calculating            % the resonance frequencies and damping ratios            wscale2 = wscale.Plant^2;       end % if        % denormalisation of the poles, frequency and time constants,    % but not the damping because it has no units    Theta.plant = [];    Theta.plant.poles = Thetan.plant.poles;    Theta.plant.poles.root = Theta.plant.poles.root * wscale1;    Theta.plant.poles.freq = Theta.plant.poles.freq * wscale2;    Theta.plant.poles.time = Theta.plant.poles.time / wscale2;    % denormalisation of the residue matrices and the singular values,     % but not the left and right singular vectors because they have no units    Theta.plant.res = Thetan.plant.res;    Theta.plant.res.all = Theta.plant.res.all * wscale1;    Theta.plant.res.sv = Theta.plant.res.sv * wscale1;end % if s- or sqrt(s)-domain plant model% denormalisation residue matrices and poles of the noise modelif strcmp(ModelVar.NoisePlane, 's') || strcmp(ModelVar.NoisePlane, 'w')        wscale1 = wscale.Noise;    switch ModelVar.NoisePlane         case 's'            wscale2 = wscale.Noise;        case 'w'            % poles are squared in sqrt(s)-domain before calculating            % the resonance frequencies and damping ratios            wscale2 = wscale.Noise^2;       end % if        % denormalisation of the poles, frequency and time constants,    % but not the damping because it has no units    Theta.noise = [];    Theta.noise.poles = Thetan.noise.poles;    Theta.noise.poles.root = Theta.noise.poles.root * wscale1;    Theta.noise.poles.freq = Theta.noise.poles.freq * wscale2;    Theta.noise.poles.time = Theta.noise.poles.time / wscale2;    % denormalisation of the residue matrices and the singular values,     % but not the left and right singular vectors because they have no units    Theta.noise.res = Thetan.noise.res;    Theta.noise.res.all = Theta.noise.res.all * wscale1;    Theta.noise.res.sv = Theta.noise.res.sv * wscale1;end % if s- or sqrt(s)-domain noise model