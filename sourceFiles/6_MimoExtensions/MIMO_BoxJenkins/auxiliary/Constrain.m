function Theta = Constrain(Theta, ModelVar);%% function Theta = Constrain(Theta, ModelVar);%%	Impose the following constraints on the plant and noise model parameters:%			1. reciprocity B and C%			2. norm([a, vec(b), vec(ig)] = 1%			3. norm([d, vec(ih)]) = 1;%			4. sum(C(:,:,r).'*C(:,:,r)) = eye(ny)%			 	r%			5. d = a for ARMAX%%	Output parameter%%		Theta	=	see input parameters%%	Input parameters%%		Theta		=	new estimate plant, noise, and initial conditions parameters%						structure with fields 'A', 'B', 'Ig', 'C', 'D', 'Ih'%							Theta = struct('A',[],'B',[], 'Ig', [], 'C',[],'D',[], 'Ih', [])%							Theta.A = 1 x (OrderA+1)%								Theta.A(r) = coefficient a(r-1) of Omega^(r-1) %							Theta.B = ny x nu x (OrderB+1)%								Theta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%							Theta.Ig = ny x (OrderIg+1)%								Theta.Ig(i,r) = coefficient ig(i,r-1) of Omega^(r-1) %							Theta.C = ny x ny x (OrderA+1)%								Theta.C(i,j,r) = coefficient c(i,j,r-1) of Omega^(r-1) %							Theta.D = 1 x (OrderD+1)%								Theta.D(r) = coefficient d(r-1) of Omega^(r-1)%							Theta.Ih = ny x (OrderIh+1)%								Theta.Ih(i,r) = coefficient ih(i,r-1) of Omega^(r-1)%		ModelVar	=	contains the information about the model to be identified%						structure with fields 'Transient', 'ThePlane', 'TheModel', 'Reciprocal', ...%							ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%							ModelVar.PlantPlane		=	plane of the plant model%															's':	continuous-time;%															'w':	sqrt(s)-domain%															'z':	discrete-time;%															'':		plane not defined%							ModelVar.NoisePlane		=	plane of the plant model%															's':	continuous-time;%															'w':	sqrt(s)-domain%															'z':	discrete-time;%															'':		plane not defined%							ModelVar.Struct			=	model structure%															'BJ':		Box-Jenkins%															'OE':		output error (plant model only)%															'ARMA':		autoregressive moving average (noise model only)%															'ARMAX':	autoregressive moving average with exogenous input%							ModelVar.DiagNoiseModel	=	1 if C is a diagonal matrix%							ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%							ModelVar.RecipNoise		=	1 if noise model is reciprocal: H(i,j) = H(j,i)%							ModelVar.nu				=	number of inputs%							ModelVar.ny				= 	number of outputs%							ModelVar.na				=	order polynomial A%							ModelVar.nb				= 	order matrix polynomial B%							ModelVar.nig			=	order vector polynomial Ig%							ModelVar.nc				=	order matrix polynomial C%							ModelVar.nd				=	order polynomial D%							ModelVar.nih			=	order vector polynomial Ih%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, December 2004 % All rights reserved.% Software can be used freely for non-commercial applications only.%nu = ModelVar.nu;ny = ModelVar.ny;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% constraint on plant model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if ModelVar.RecipPlant	for jj = 1:nu							% column index		for ii = 1+jj:ny					% row index			lji = jj + ny*(ii-1);			% block position coefficients b(jj,ii) polynomial			% reciprocity plant model					if lji <= nu*ny					% test for rectangular matrices				Theta.B(jj,ii,:) = Theta.B(ii,jj,:);			end % if		end % ii	end % jj		end % if symmetric BNormPlant = norm([Theta.A.'; Theta.B(:); Theta.Ig(:)]);Theta.A = Theta.A/NormPlant;Theta.B = Theta.B/NormPlant;Theta.Ig = Theta.Ig/NormPlant;if strcmp(ModelVar.Struct, 'ARMAX')	Theta.D = Theta.A;end % if ARMAX%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% constraint on noise model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if ~strcmp(ModelVar.Struct, 'ARMASTART')        if ModelVar.RecipNoise        for jj = 1:ny							% column index            for ii = 1+jj:ny					% row index		                % reciprocity noise model                Theta.C(jj,ii,:) = Theta.C(ii,jj,:);			            end % ii        end % jj        NormC = norm(Theta.C(:));        Theta.C = Theta.C/NormC;    else        nc = ModelVar.nc;        % calculate sum r (Cr^T * Cr) for r = 0, 1, ..., nc        Call = reshape(permute(Theta.C,[1,3,2]),ny*(nc+1),ny);        [uc, sc, vc] = svd(Call.'*Call, 0);        Tc = uc*diag(diag(sc).^(-0.5))*uc.';        for ii = 1:nc+1            Theta.C(:,:,ii) = Theta.C(:,:,ii) * Tc;        end % ii    end    if ~strcmp(ModelVar.Struct,'ARMAX')        NormNoise = norm([Theta.D.'; Theta.Ih(:)]);        Theta.D = Theta.D/NormNoise;        Theta.Ih = Theta.Ih/NormNoise;    end % if not ARMAXend % not ARMASTART