function [Theta, Cost, smax, smin] = MIMONewtonGaussStep(data, x, xMat, OldTheta, Sel, ModelVar, IterVar, Lambda);%%	[Theta, Cost, smax, smin] = MIMONewtonGaussStep(data, x, xMat, OldTheta, Sel, ModelVar, IterVar, Lambda)%%	Output parameters%%		Theta				=	estimated value plant, noise, and initial conditions parameters%								Theta = struct('A',[],'B',[], 'Ig', [], 'C',[],'D',[], 'Ih', [])%									Theta.A     =   1 x (OrderA+1)%                                                       Theta.A(r) = coefficient a(r-1) of Omega^(r-1) %									Theta.B     =   ny x nu x (OrderB+1)%                                                       Theta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%									Theta.Ig    =   ny x (OrderIg+1)%                                                       Theta.Ig(i,r) = coefficient ig(i,r-1) of Omega^(r-1) %									Theta.C     =   ny x ny x (OrderC+1)%                                                       Theta.C(i,j,r) = coefficient c(i,j,r-1) of Omega^(r-1) %									Theta.D     =   1 x (OrderD+1)%                                                       Theta.D(r) = coefficient d(r-1) of Omega^(r-1)%									Theta.Ih    =   ny x (OrderIh+1)%                                                       Theta.Ih(i,r) = coefficient ih(i,r-1) of Omega^(r-1)%						Note:	all coefficients (except those for which Sel = 0) are free%								during the minimization + in each iteration step the following%								constraints are imposed:%									norm([a, vec(b), vec(ig)] = 1%									norm([d, vec(ih)]) = 1;%									sum(C(:,:,r).'*C(:,:,r)) = eye(ny)%									 r%%		Cost		=	value of the cost function in the last iteration step%%		smax		=	largest singular value of the Jacobian matrix%%		smin		=	smallest singular value of the Jacobian matrix%%%	Input parameters%%		data		=	structure containing the non-patameteric data%							data.Y			=	DFT spectrum ny x 1 output signal, dimensions ny x number of frequencies%							data.U			=	DFT spectrum nu x 1 input signal, dimensions: nu x number of frequencies%							data.freq		=	vector of frequency values (Hz), dimension: number of frequencies x 1%							data.Ts			=	sampling time (s)%							data.Gc			=	controller transfer function, zero or empty if unknown or not present,%												dimension nu x ny x number of frequencies%							data.DC			=	1 if DC present otherwise 0%							data.Nyquist	=	1 if Nyquist frequency present otherwise 0%%		x			=	structure containing (jwk) or (zk^-1) values%							x.Plant         =	plant model, dimension: number of frequencies x 1%							x.Noise         =	noise model, dimension: number of frequencies x 1%%		xMat		=	structure with tables of powers of (jwk)^r or (zk^-r)%							xMat.Plant		=	plant model, dimension: number of frequencies x max order%							xMat.Noise		=	noise model, dimension: number of frequencies x max order%%		OldTheta	=	previous estimate plant, noise, and initial conditions parameters%						structure with fields 'A', 'B', 'Ig', 'C', 'D', 'Ih'%						OldTheta = struct('A',[],'B',[], 'Ig', [], 'C',[],'D',[], 'Ih', [])%							OldTheta.A      =   1 x (OrderA+1)%                                                   OldTheta.A(r) = coefficient a(r-1) of Omega^(r-1) %							OldTheta.B      =   ny x nu x (OrderB+1)%                                                   OldTheta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%							OldTheta.Ig     =   ny x (OrderIg+1)%                                                   OldTheta.Ig(i,r) = coefficient ig(i,r-1) of Omega^(r-1) %							OldTheta.C      =   ny x ny x (OrderA+1)%                                                   OldTheta.C(i,j,r) = coefficient c(i,j,r-1) of Omega^(r-1) %							OldTheta.D      =   1 x (OrderD+1)%                                                   OldTheta.D(r) = coefficient d(r-1) of Omega^(r-1)%							OldTheta.Ih     =   ny x (OrderIh+1)%                                                   OldTheta.Ih(i,r) = coefficient ih(i,r-1) of Omega^(r-1)%						Note:	all coefficients (except those for which Sel = 0) are free%								during the minimization + in each iteration step the following%								constraints are imposed:%									norm([a, vec(b), vec(ig)] = 1%									norm([d, vec(ih)]) = 1;%									sum(C(:,:,r).'*C(:,:,r)) = eye(ny)%									 r%%		Sel			=	structure selecting the parameters to be estimated: 0 = known; 1 = estimated %					    Sel = struct('A', [], 'B', [], 'Ig', [], 'C', [], 'D', [], 'Ih', [])%							Sel.A           =   1 x (OrderA+1)%                                                   Sel.A(r) = 1 if coeff. a(r-1) is unknown%                                                   Sel.A(r) = 0 if coeff. a(r-1) = 0%							Sel.B           =   ny x nu x (OrderB+1)%                                                   Sel.B(i,j,r) = 1 if coeff. b(i,j,r-1) is unknown%                                                   Sel.B(i,j,r) = 0 if coeff. b(i,j,r-1) = 0%							Sel.Ig          =   ny x (OrderIg+1)%                                                   Sel.Ig(i,r) = 1 if coeff. ig(i,r-1) is unknown%                                                   Sel.Ig(i,r) = 0 if coeff. ig(i,r-1) = 0%							Sel.C           =   ny x ny x (OrderC+1)%                                                   Sel.C(i,j,r) = 1 if coeff. c(i,j,r-1) is unknown%                                                   Sel.C(i,j,r) = 0 if coeff. c(i,j,r-1) = 0%							Sel.D           =   1 x (OrderD+1)%                                                   Sel.D(r) = 1 if coeff. d(r-1) is unknown%                                                   Sel.D(r) = 0 if coeff. d(r-1) = 0%							Sel.Ih          =   ny x (OrderIh+1)%                                                   Sel.Ih(i,r) = 1 if coeff. ih(i,r-1) is unknown%                                                   Sel.Ih(i,r) = 0 if coeff. ih(i,r-1) = 0%%		ModelVar	=	contains the information about the model to be identified%						structure with fields 'Transient', 'ThePlane', 'TheModel', 'Reciprocal', ...%							ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%							ModelVar.PlantPlane		=	plane of the plant model%															's':	continuous-time;%															'w':	sqrt(s)-domain%															'z':	discrete-time;%															'':		plane not defined%							ModelVar.NoisePlane		=	plane of the noise model%															's':	continuous-time;%															'w':	sqrt(s)-domain%															'z':	discrete-time;%															'':		plane not defined%							ModelVar.Struct			=	model structure%															'BJ':		Box-Jenkins%															'OE':		output error (plant model only)%															'ARMA':		autoregressive moving average (noise model only)%															'ARMAX':	autoregressive moving average with exogenous input%							ModelVar.DiagNoiseModel	=	1 if C is a diagonal matrix%							ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%							ModelVar.RecipNoise		=	1 if noise model is reciprocal: H(i,j) = H(j,i)%							ModelVar.nu				=	number of inputs%							ModelVar.ny				= 	number of outputs%							ModelVar.na				=	order polynomial A%							ModelVar.nb				= 	order matrix polynomial B%							ModelVar.nig			=	order vector polynomial Ig%							ModelVar.nc				=	order matrix polynomial C%							ModelVar.nd				=	order polynomial D%							ModelVar.nih			=	order vector polynomial Ih%%		IterVar		=	contains the information about the scaling of the Jacobian matrix %							IterVar.NormJacob       =	1 scales the columns of the Jacobian matrix such that the%                                                           columns have norm one (optional, default 1)%%		Lambda		=	Levenberg-Marquardt parameter%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, 2004 % All rights reserved.% Software can be used freely for non-commercial applications only.% Version April 2008%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculate the variation of the free model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% transfer functions and polynomialsPolyTrans = CalcPolyTrans(OldTheta, x);% prediction Error, and sample covariance matrix CovE of the prediction error[Error, CovE] = PredError(data, PolyTrans);% Jacobian matrix of prediction error w.r.t. ALL model parameters% Note: Jacobian is scaled by gF; size ny x ntheta x FJacob = MIMOJacob(data, xMat, Error, PolyTrans, ModelVar);% weight error vector and Jacobian matrix at the left hand side by% the inverse of the square root of CovE, and put the different% frequency contributions on top of each other% size Jacob in: ny x ntheta x F% size Jacob out: ny*F x ntheta% size Error in: ny x F% size Error out: ny*F x 1[Jacob, Error] = LeftWeighting(Jacob, Error, CovE);% impose the common parameter structure and eliminate the excess parameters % size Jacob in: ny*F x ntheta% size Jacob out: ny*F x number of free model parametersJacob = Add_SelectColumns(Jacob, Sel, ModelVar);if IterVar.NormJacob    % scaling of the columns of the Jacobian matrix to improve the condition number     TheScale = sum(abs(Jacob.^2), 1).^0.5;    IndexZeroes = find(TheScale == 0);    TheScale(IndexZeroes) = 1;    Jacob = Jacob ./ repmat(TheScale, [size(Jacob, 1), 1]);end % if% calculate the parameter variation DeltaParam[u, ss, v] = svd([real(Jacob); imag(Jacob)], 0);switch ModelVar.Struct	case 'OE', nn = 1;	case {'ARMA','ARMAX'}, nn = 2;    case 'ARMASTART', nn = 0;	case 'BJ', nn = 3;endsmax = ss(1,1);smin = ss(end-nn, end-nn);diags = diag(ss);diags = diags(1:end-nn);DeltaParam = -v*diag([diags./(diags.^2+Lambda); zeros(nn,1)])*(u.'*[real(Error);imag(Error)]);if IterVar.NormJacob    % denormalisation parameter variation    DeltaParam = DeltaParam ./ TheScale.';end % if%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% extract the plant and noise model parameters from DeltaParam %% order in DeltaParam: a, b, ig, c, d, ih                      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Theta = ExtractParam(DeltaParam, OldTheta, Sel);	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Impose constraints on updated parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Theta = Constrain(Theta, ModelVar);%%%%%%%%%%%%%%%%%% cost function %%%%%%%%%%%%%%%%%%Cost = MIMOCost(data, Theta, x);