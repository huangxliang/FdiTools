function [TheTheta] = MIMONormalise(TheTheta, Thewscale, TheModelVar);%%	[TheTheta] = MIMONormalise(TheTheta, Thewscale, TheModelVar);%%	Output parameters%		TheTheta			=	see input parameters%%	Input parameters%		TheTheta			=	plant, noise, and initial conditions parameters%								structure with fields 'A', 'B', 'Ig', 'C', 'D', 'Ih'%									TheTheta = struct('A',[],'B',[], 'Ig', [], 'C',[],'D',[], 'Ih', [])%									TheTheta.A = 1 x (OrderA+1)%										TheTheta.A(r) = coefficient a(r-1) of Omega^(r-1) %									TheTheta.B = ny x nu x (OrderB+1)%										TheTheta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%									TheTheta.Ig = ny x (OrderIg+1)%										TheTheta.Ig(i,r) = coefficient ig(i,r-1) of Omega^(r-1) %									TheTheta.C = ny x ny x (OrderA+1)%										TheTheta.C(i,j,r) = coefficient c(i,j,r-1) of Omega^(r-1) %									TheTheta.D = 1 x (OrderD+1)%										TheTheta.D(r) = coefficient d(r-1) of Omega^(r-1)%									TheTheta.Ih = ny x (OrderIh+1)%										TheTheta.Ih(i,r) = coefficient ih(i,r-1) of Omega^(r-1)%								Note:	all coefficients (except those for which Sel = 0) are free%										during the minimization + in each iteration step the following%										constraints are imposed:%											norm([a, vec(b), vec(ig)] = 1%											norm([d, vec(ih)]) = 1;%											sum(C(:,:,r).'*C(:,:,r)) = eye(ny)%											 r%		Thewscale			=	structure containing the frequency scaling%									Thewscale = struct('Plant', [], 'Noise', [])%									Thewscale.Plant	=	angular frequency scaling plant model%									Thewscale.Noise	=	angular frequency scaling noise model%		TheModelVar			=	contains the information about the model to be identified%								structure with fields 'Transient', 'ThePlane', 'Reciprocal'%									TheModelVar = struct('Transient', [], 'PlantPlane', [], 'NoisePlane', [], 'Struct', [], 'Reciprocal',[])%									TheModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%									TheModelVar.PlantPlane		=	plane of the plant model%																	's':	continuous-time;%																	'w':	sqrt(s)-domain%																	'z':	discrete-time;%																	'':		plane not defined%									TheModelVar.NoisePlane		=	plane of the noise model%																	's':	continuous-time;%																	'w':	sqrt(s)-domain%																	'z':	discrete-time;%																	'':		plane not defined%									TheModelVar.Struct			=	model structure%																	'BJ':		Box-Jenkins%																	'OE':		output error (plant model only)%																	'ARMA':		autoregressive moving average (noise model only)%																	'ARMAX':	autoregressive moving average with exogenous input%									TheModelVar.Reciprocal		=	1 if plant and noise models are reciprocal: G(i,j) = G(j,i) and H(i,j) = H(j,i)%									TheModelVar.nu				=	number of inputs%									TheModelVar.ny				= 	number of outputs%									TheModelVar.na				=	order polynomial A%									TheModelVar.nb				=	order ny x nu matrix polynomial B%									TheModelVar.nig             =	order ny x 1 vector polynomial Ig%									TheModelVar.nc				=	order ny x ny matrix polynomial C%									TheModelVar.nd				=	order polynomial D%									TheModelVar.nih             =	order ny x 1 vector polynomial Ih%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, 2004 % All rights reserved.% Software can be used freely for non-commercial applications only.% Version April 2008%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% normalisation plant model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if ~strcmp(TheModelVar.Struct,'ARMA') && ~strcmp(TheModelVar.PlantPlane,'z')		na = TheModelVar.na;	nb = TheModelVar.nb;	nig = TheModelVar.nig;	nmax = max([na, nb, nig]);	TheScale = zeros(1,1,nmax+1);	for ii = 0:nmax		TheScale(1,1,ii+1) = Thewscale.Plant^ii;	end	% polynomial A	TheTheta.A = TheTheta.A.*(squeeze(TheScale(1,1,1:na+1)).');	% ny x nu matrix polynomial B	nu = TheModelVar.nu;	ny = TheModelVar.ny;	TheTheta.B = TheTheta.B.*repmat(TheScale(1,1,1:nb+1),[ny, nu, 1]);		% ny x 1 vector polynomial Ig	if TheModelVar.Transient			TheTheta.Ig = TheTheta.Ig.*repmat(squeeze(TheScale(1,1,1:nig+1)).',[ny, 1]);	end % if transient	end % not ARMA and not z-domain%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% normalisation noise model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if ~strcmp(TheModelVar.Struct,'OE') && ~strcmp(TheModelVar.NoisePlane,'z')		nc = TheModelVar.nc;	nd = TheModelVar.nd;	nih = TheModelVar.nih;	nmax = max([nc, nd, nih]);	TheScale = zeros(1,1,nmax+1);	for ii = 0:nmax		TheScale(1,1,ii+1) = Thewscale.Noise^ii;	end	% ny x ny matrix polynomial C	ny = TheModelVar.ny;	TheTheta.C = TheTheta.C.*repmat(TheScale(1,1,1:nc+1),[ny, ny, 1]);	% polynomial D	TheTheta.D = TheTheta.D.*(squeeze(TheScale(1,1,1:nd+1)).');		% ny x 1 vector polynomial Ih	if TheModelVar.Transient && ~strcmp(TheModelVar.Struct, 'ARMAX')		TheTheta.Ih = TheTheta.Ih.*repmat(squeeze(TheScale(1,1,1:nih+1)).',[ny, 1]);	end % if transient	end % not OE and not z-domain