function [TheError, CovE, gF, E] = PredError(data, PolyTrans);%%	[TheError, CovE, gF, E] = PredError(data, PolyTrans)%%	Output parameters%%		TheError	=	prediction error model equations, dimension ny x number of freq.%						TheError = H^-1 * (Y - G * U - Tg - Th)%		CovE		=	estimate of the real valued covariance matrix of the driving white noise sources, dimension ny x ny%		gF			=	scale factor prediction error, scalar%		E			=	output residual model equations, dimension ny x number of freq.%						E = Y - G * U - Tg - Th%%	Input parameters%%		data		=	structure containing the non-patameteric data%							data.Y			=	DFT spectrum ny x 1 output signal, dimensions ny x number of frequencies%							data.U			=	DFT spectrum nu x 1 input signal, dimensions: nu x number of frequencies%							data.freq		=	vector of frequency values (Hz), dimension: number of frequencies x 1%							data.Ts			=	sampling time (s)%							data.Gc			=	controller transfer function, zero or empty if unknown or not present,%												dimension nu x ny x number of frequencies%							data.DC			=	1 if DC present otherwise 0%							data.Nyquist	=	1 if Nyquist frequency present otherwise 0%%		PolyTrans	=	structure containing the polynomials and transfer functions evaluated in x%							PolyTrans.A		=	denominator polynomial plant transfer function evaluated in x.Plant, dimensions 1 x number of freq.%							PolyTrans.D		=	D polynomial evaluated in x.Noise, dimensions 1 x number of freq.%							PolyTrans.G		=	plant transfer matrix evaluated in x.Plant, dimensions ny x nu x number of freq.%							PolyTrans.Hinv	=	inverse of the noise transfer matrix evaluated in x.Noise, dimensions ny x ny x number of freq.%							PolyTrans.Tg	=	plant transient term evaluated in x.Plant, dimension ny x number of freq.%							PolyTrans.Th	=	noise transient term evaluated in x.Noise, dimension ny x number of freq.%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, December 2004 % All rights reserved.% Software can be used freely for non-commercial applications only.% Version April, 2008%ny = size(data.Y, 1);	% number of outputsnu = size(data.U, 1);	% number of outputsF = size(data.Y, 2);	% number of frequenciesY = data.Y;U = data.U;G = PolyTrans.G;Hinv = PolyTrans.Hinv;Tg = PolyTrans.Tg;Th = PolyTrans.Th;Gc = data.Gc;TheError = zeros(ny, F);gF = 0;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the prediction error TheError: the lines below are equivalent with        %% for kk = 1:F                                                                                  %% 	TheError(:, kk) = Hinv(:, :, kk)*(Y(:, kk) - G(:, :, kk)*U(:, kk) - Tg(:, kk) - Th(:, kk)); %% end                                                                                           %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%UT = zeros(1, nu, F);UT(1,:,:) = U;GU = sum(G.*repmat(UT, ny, 1), 2);[rows, columns, depth] = size(GU);GU = squeeze(GU);% squeeze function on 1 x 1 x F delivers F x 1 !!!if rows*columns == 1	GU = GU.'; endE = Y - GU - Tg - Th;ET = zeros(1, ny, F);ET(1,:,:) = E;TheError = sum(Hinv.*repmat(ET, ny, 1), 2);[rows, columns, depth] = size(TheError);TheError = squeeze(TheError);% squeeze function on 1 x 1 x F delivers F x 1 !!!if rows*columns == 1	TheError = TheError.'; end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the scale factor gF: the lines below are equivalent with %% for kk = 1:F                                                                 %% 	gF = gF - log(det(Hinv(:, :, kk)*(eye(ny) + G(:, :, kk)*Gc(:, :, kk))));   %% end                                                                          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculation eye(ny) + G(:, :, kk)*Gc(:, :, kk))) for all kkGGc = zeros(ny, ny, F);for ii = 1:ny	UT(1,:,:) = squeeze(Gc(:,ii,:));	GGc(:,ii,:) = sum(G.*repmat(UT, ny, 1), 2);endTheEye = zeros(F, ny, ny);eyeT = zeros(1,ny,ny);eyeT(1,:,:) = eye(ny);TheEye = repmat(eyeT,F,1);TheEye = permute(TheEye,[2,3,1]);GGc = GGc + TheEye;% calculation Hinv(:, :, kk)*GGc(:, :, kk) for all kkHinvGGc = zeros(ny, ny, F);GGcT = zeros(1, ny, F); for ii = 1:ny	GGcT(1,:,:) = squeeze(GGc(:,ii,:));	HinvGGc(:,ii,:) = sum(Hinv.*repmat(GGcT, ny, 1), 2);end% calculation sum k (-logdet(HinvGGc(:, :, kk)))if ny > 1    for kk = 1:F        gF = gF - log(det(HinvGGc(:, :, kk)));    endelse % ny = 1    gF = sum(-log(squeeze(HinvGGc)));end % if%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DC and Nyquist have half of the weight in the ML cost function %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if data.DC == 1	TheError(:, 1) = TheError(:, 1)/sqrt(2);	gF = gF + log(det(Hinv(:, :, 1)*(eye(ny) + G(:, :, 1)*Gc(:, :, 1))))/2;	F = F - 1/2;end % if DCif data.Nyquist == 1	TheError(:, end) = TheError(:, end)/sqrt(2);	gF = gF + log(det(Hinv(:, :, end)*(eye(ny) + G(:, :, end)*Gc(:, :, end))))/2;	F = F - 1/2;end % if Nyquist%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% final value scale factor and Covariance matrix %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%gF = exp(gF/F/ny);CovE = real(TheError*TheError')/F;