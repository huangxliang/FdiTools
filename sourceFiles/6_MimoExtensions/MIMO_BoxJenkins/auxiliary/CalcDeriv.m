function Deriv = CalcDeriv(xMat, PolyTrans, ModelVar);%% function Deriv = CalcDeriv(xMat, PolyTrans, ModelVar);%%		Calculates the derivative of the transfer functions G = B/A, H = C/D%		Tg = Ig/A, and Th = Ih/D w.r.t. the model parameters. For the transfer%		function matrices G and H the derivative of vec(G) and vec(H) is calculated%%	Output parameter%%		Deriv		=	structure containing the derivative of vec(G), vec(H), Tg, and Th w.r.t.%						all the plant model parameters a, b, ig, c, d, ih%						    Deriv.vecGa	=	derivative vec(G) w.r.t. a;	size ny*nu x (na+1) x number of freq.%						    Deriv.vecGb	=	derivative vec(G) w.r.t. b;	size ny*nu x ny*nu*(nb+1) x number of freq.%						    Deriv.vecHc	=	derivative vec(H) w.r.t. c;	size ny^2 x ny^2*(nc+1) x number of freq.%						    Deriv.vecHd	=	derivative vec(H) w.r.t. d;	size ny^2 x (nd+1) x number of freq.%						    Deriv.Tga	=	derivative Tg w.r.t. a;		size ny x (na+1) x number of freq.%						    Deriv.Tgig	=	derivative Tg w.r.t. ig;	size ny x ny*(nig+1) x number of freq.%						    Deriv.Thd	=	derivative Th w.r.t. d;		size ny x (nd+1) x number of freq.%						    Deriv.Thih	=	derivative Th w.r.t. ih;	size ny x ny*(nih+1) x number of freq.%% Input parameters%%		xMat		=	structure with tables of powers of (jwk)^r or (zk^-r)%							xMat.Plant		=	plant model, dimension: number of frequencies x max order%							xMat.Noise		=	noise model, dimension: number of frequencies x max order%		PolyTrans	=	structure containing the polynomials and transfer functions evaluated in x%							PolyTrans.A		=	denominator polynomial plant transfer function evaluated in x.Plant, dimensions 1 x number of freq.%							PolyTrans.D		=	D polynomial evaluated in x.Noise, dimensions 1 x number of freq.%							PolyTrans.G		=	plant transfer matrix evaluated in x.Plant, dimensions ny x nu x number of freq.%							PolyTrans.Hinv	=	inverse of the noise transfer matrix evaluated in x.Noise, dimensions ny x ny x number of freq.%							PolyTrans.Tg	=	plant transient term evaluated in x.Plant, dimension ny x number of freq.%							PolyTrans.Th	=	noise transient term evaluated in x.Plant, dimension ny x number of freq.%		ModelVar	=	contains the information about the model to be identified%						structure with fields 'Transient', 'ThePlane', 'TheModel', 'Reciprocal', ...%							ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%							ModelVar.PlantPlane		=	plane of the plant model%															's':	continuous-time;%															'w':	sqrt(s)-domain%															'z':	discrete-time;%															'':		plane not defined%							ModelVar.NoisePlane		=	plane of the plant model%															's':	continuous-time;%															'w':	sqrt(s)-domain%															'z':	discrete-time;%															'':		plane not defined%							ModelVar.Struct			=	model structure%															'BJ':		Box-Jenkins%															'OE':		output error (plant model only)%															'ARMA':		autoregressive moving average (noise model only)%															'ARMAX':	autoregressive moving average with exogenous input%							ModelVar.DiagNoiseModel	=	1 if C is a diagonal matrix%							ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%							ModelVar.RecipNoise		=	1 if noise model is reciprocal: H(i,j) = H(j,i)%							ModelVar.nu				=	number of inputs%							ModelVar.ny				= 	number of outputs%							ModelVar.na				=	order polynomial A%							ModelVar.nb				= 	order matrix polynomial B%							ModelVar.nig			=	order vector polynomial Ig%							ModelVar.nc				=	order matrix polynomial C%							ModelVar.nd				=	order polynomial D%							ModelVar.nih			=	order vector polynomial Ih%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, 2004 % All rights reserved.% Software can be used freely for non-commercial applications only.% Version April 2008%Deriv = struct('vecGa', [], 'vecGb', [], 'vecHc', [], 'vecHd', [], 'Tga', [], 'Tgig', [], 'Thd', [], 'Thih', []);F = size(xMat.Plant,1);na = ModelVar.na;nb = ModelVar.nb;nig = ModelVar.nig;nc = ModelVar.nc;nd = ModelVar.nd;nih = ModelVar.nih;ny = ModelVar.ny;nu = ModelVar.nu;Deriv.vecGa = zeros(ny*nu, na+1, F);Deriv.vecGb = zeros(ny*nu, ny*nu*(nb+1), F);Deriv.Tga = zeros(ny, na+1, F);Deriv.Tgig = zeros(ny, ny*(nig+1), F);Deriv.vecHc = zeros(ny^2, ny^2*(nc+1), F);Deriv.vecHd = zeros(ny^2, (nd+1), F);Deriv.Thd = zeros(ny, nd+1, F);Deriv.Thih = zeros(ny, ny*(nih+1), F);% divide xMat.Plant by A-polynomialMaxOrder = size(xMat.Plant, 2);xMat.Plant = xMat.Plant./repmat(PolyTrans.A.',1,MaxOrder);% divide xMat.Noise by D-polynomialMaxOrder = size(xMat.Noise, 2);xMat.Noise = xMat.Noise./repmat(PolyTrans.D.',1,MaxOrder);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative of vec(G) w.r.t. a. The lines below are equivalent with % % for kk = 1:F                                                                               % %	 vecG = PolyTrans.G(:,:,kk);                                                             %   %	 vecG = vecG(:);                                                                         % %	 Deriv.vecGa(:,:,kk) = - vecG * xMat.Plant(kk, 1:na+1);                                  % % end                                                                                        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for ii = 1:nu*ny        column = ceil(ii/ny);    row = ii - (column-1)*ny;    % squeeze function on 1 x 1 x F delivers F x 1 !!!    G = squeeze(PolyTrans.G(row, column, :));    Deriv.vecGa(ii,:,:) = -(xMat.Plant(:, 1:na+1) .* repmat(G, [1, na+1])).';    end % ii%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative of vec(G) w.r.t. b. The lines below are equivalent with % % for kk = 1:F                                                                               % %	 Deriv.vecGb(:,:,kk) = kron(eye(nu*ny, nu*ny), xMat.Plant(kk, 1:nb+1));                  %   % end                                                                                        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for ii = 1:nu*ny        vii = zeros(nu*ny, 1);    vii(ii) = 1;    Deriv.vecGb(ii,:,:) = kron(vii, (xMat.Plant(:, 1:nb+1)).');    end % ii%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative Tg w.r.t. a. The lines below are equivalent with        % % for kk = 1:F                                                                               % %	 Deriv.Tga(:,:,kk) = - PolyTrans.Tg(:, kk) * xMat.Plant(kk, 1:na+1);                     %   % end                                                                                        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for ii = 1:ny        Tg = PolyTrans.Tg(ii, :).';    Deriv.Tga(ii,:,:) = -(xMat.Plant(:, 1:na+1) .* repmat(Tg, [1, na+1])).';    end % ii%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative of Tg w.r.t. ig. The lines below are equivalent with    % % for kk = 1:F                                                                               % %	 Deriv.Tgig(:,:,kk) = kron(eye(ny, ny), xMat.Plant(kk, 1:nig+1));                        %   % end                                                                                        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for ii = 1:ny        vii = zeros(ny, 1);    vii(ii) = 1;    Deriv.Tgig(ii,:,:) = kron(vii, (xMat.Plant(:, 1:nig+1)).');    end % ii%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative of H w.r.t. c. The lines below are equivalent with      % % for kk = 1:F                                                                               % %	 Deriv.vecHc(:,:,kk) = kron(eye(ny^2, ny^2), xMat.Noise(kk, 1:nc+1));                    %   % end                                                                                        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for ii = 1:ny^2        vii = zeros(ny^2, 1);    vii(ii) = 1;    Deriv.vecHc(ii,:,:) = kron(vii, (xMat.Noise(:, 1:nc+1)).');    end % ii%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative of vec(H) w.r.t. d. The lines below are equivalent with % % for kk = 1:F                                                                               % %	 vecH = PolyTrans.H(:,:,kk);                                                             % %	 vecH = vecH(:);                                                                         % %	 Deriv.vecHd(:,:,kk) = - vecH * xMat.Noise(kk, 1:nd+1);                                  % % end                                                                                        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for ii = 1:ny^2        column = ceil(ii/ny);    row = ii - (column-1)*ny;    % squeeze function on 1 x 1 x F delivers F x 1 !!!    H = squeeze(PolyTrans.H(row, column, :));    Deriv.vecHd(ii,:,:) = -(xMat.Noise(:, 1:nd+1) .* repmat(H, [1, nd+1])).';    end % ii%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative Th w.r.t. d. The lines below are equivalent with        % % for kk = 1:F                                                                               % %	 Deriv.Thd(:,:,kk) = - PolyTrans.Th(:, kk) * xMat.Noise(kk, 1:nd+1);                     %   % end                                                                                        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for ii = 1:ny        Th = PolyTrans.Th(ii, :).';    Deriv.Thd(ii,:,:) = -(xMat.Noise(:, 1:nd+1) .* repmat(Th, [1, nd+1])).';    end % ii%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative of Th w.r.t. ih. The lines below are equivalent with    % % for kk = 1:F                                                                               % %	 Deriv.Thih(:,:,kk) = kron(eye(ny, ny), xMat.Noise(kk, 1:nih+1));                        %   % end                                                                                        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for ii = 1:ny        vii = zeros(ny, 1);    vii(ii) = 1;    Deriv.Thih(ii,:,:) = kron(vii, (xMat.Noise(:, 1:nih+1)).');    end % ii