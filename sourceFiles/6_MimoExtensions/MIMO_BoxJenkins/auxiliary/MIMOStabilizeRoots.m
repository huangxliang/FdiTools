function [NewPoly, SumCoef] = MIMOStabilizeRoots(Poly, domain, TraceOn)%%	NewPoly = MIMOStabilizeRoots(Poly, domain, TraceOn) %% StabilizeRoots returns a monic stable polynomial in z^-1.%% output arguments%   NewPoly	=	monic stable polynomial in z^-1 (coeff. z^0 = 1);%				in 's' => sum coefficients = 1%   SumCoef = 	sum coefficients 's' domain polynomial; otherwise empty%% input arguments%   Poly 	=	polynomial in ascending powers of z^-1%	domain	=	'z' if discrete time model, 's' if continuous time model%	TraceOn	=	1 the display messages%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, 1998 % All rights reserved.% Software can be used freely for non-commercial applications only.% Version April 2004%% initialisationindex = [];Pindex = [];Nindex = [];Zindex = [];% calculates roots in z and verifies the stabilityif domain == 'z' 	RootsPoly = roots(Poly);	index = find (abs(RootsPoly) > 1);				% roots outside unit circle	SumCoef = [];end;% calculates roots in s, imposes the sum constraint, and verifies the stabilityif domain == 's' 	RootsPoly = roots(fliplr(Poly));	index = find (real(RootsPoly) > 0);				% roots in right half plane	SumCoef = sum(Poly);	Poly = Poly/SumCoef;end;% calculates roots in sqrt(s), imposes the sum constraint, and verifies the stabilityif domain == 'w' 	RootsPoly = roots(fliplr(Poly));	% roots in abs(angle(roots))<pi/4	Pindex = find ((angle(RootsPoly) > 0) & (angle(RootsPoly) < pi/4));	Nindex = find ((angle(RootsPoly) < 0) & (angle(RootsPoly) > -pi/4));	Zindex = find (abs(angle(RootsPoly)) == 0);	SumCoef = sum(Poly);	Poly = Poly/SumCoef;end;if ~ (isempty(index) & isempty(Pindex) & isempty(Nindex) & isempty(Zindex))		NumberOfRoots = length(RootsPoly);	NewPoly = [1];	% stabilize unstable roots and reconstruct the polynomial s.t. coeff. z^0 = 1	% the stabilisation is done with an allpass section	if domain == 'z'		RootsPoly(index) = 1./RootsPoly(index);		for ii = 1:NumberOfRoots	 		NewPoly = conv(NewPoly,[1 -RootsPoly(ii)]);		end;		NewPoly = real(NewPoly);	end;		% stabilize unstable roots and reconstruct the polynomial s.t. sum(coeff.) = 1	% after a bilinear transformation this is the condition to have z^0 = 1	% the stabilisation is done with an allpass section	if domain == 's'		RootsPoly(index) = -real(RootsPoly(index)) + sqrt(-1)*imag(RootsPoly(index));		for ii = 1:NumberOfRoots	 		NewPoly = conv(NewPoly,[-RootsPoly(ii) 1]);		end;		NewPoly = real(NewPoly);		SumCoef = sum(NewPoly);		NewPoly = NewPoly/SumCoef;	end;		% stabilize unstable roots and reconstruct the polynomial s.t. sum(coeff.) = 1	% after a bilinear transformation this is the condition to have z^0 = 1	% the stabilisation is NOT done with an allpass section, since an allpass in	% sqrt(s)-domain implies an increase in order of numerator and denominator	if domain == 'w' 		RootsPoly(Pindex) = abs(RootsPoly(Pindex)).*exp(sqrt(-1)*(pi/2 - angle(RootsPoly(Pindex)))); 		RootsPoly(Nindex) = abs(RootsPoly(Nindex)).*exp(-sqrt(-1)*(pi/2 + angle(RootsPoly(Nindex))));		RootsPoly(Zindex) = -RootsPoly(Zindex);		for ii = 1:NumberOfRoots	 		NewPoly = conv(NewPoly,[-RootsPoly(ii) 1]);		end;		NewPoly = real(NewPoly);		SumCoef = sum(NewPoly);		NewPoly = NewPoly/SumCoef;	end;		if TraceOn == 1		'stab. active'	endelse	NewPoly = Poly;end;