function [Theta, smax, smin] = LSNewtonGaussStep(data, x, xMat, Sel, ModelVar);%%	[Theta, smax, smin] = LSNewtonGaussStep(data, x, xMat, Sel, ModelVar)%%	Output parameters%		Theta		=	new estimate plant, noise, and initial conditions parameters%						structure with fields 'A', 'B', 'Ig', 'C', 'D', 'Ih'%							Theta = struct('A',[],'B',[], 'Ig', [], 'C',[],'D',[], 'Ih', [])%							Theta.A = 1 x (OrderA+1)%								Theta.A(r) = coefficient a(r-1) of Omega^(r-1) %							Theta.B = ny x nu x (OrderB+1)%								Theta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%							Theta.Ig = ny x (OrderIg+1)%								Theta.Ig(i,r) = coefficient ig(i,r-1) of Omega^(r-1) %						Note:	all coefficients (except those for which Sel = 0) are free%								during the minimization + in each iteration step the following%								constraints are imposed:%									norm([a, vec(b), vec(ig)] = 1%		Cost		=	value of the cost function in the last iteration step%		smax		=	largest singular value of the Jacobian matrix%		smin		=	smallest singular value of the Jacobian matrix%%	input parameters%		data		=	structure containing the non-patameteric data%							data.Y			=	DFT spectrum ny x 1 output signal, dimensions ny x number of frequencies%							data.U			=	DFT spectrum nu x 1 input signal, dimensions: nu x number of frequencies%							data.freq		=	vector of frequency values (Hz), dimension: number of frequencies x 1%							data.Ts			=	sampling time (s)%							data.DC			=	1 if DC present otherwise 0%							data.Nyquist	=	1 if Nyquist frequency present otherwise 0%		x			=	structure containing (jwk) or (zk^-1) values%							x.Plant	=	plant model, dimension: number of frequencies x 1%		xMat		=	structure with tables of powers of (jwk)^r or (zk^-r)%							xMat.Plant		=	plant model, dimension: number of frequencies x max order%		Sel			=	structure with fields 'A', 'B', 'Ig'%							Sel = struct('A',[],'B',[], 'Ig', [])%							Sel.A = 1 x (OrderA+1)%								Sel.A(r) = 1 if coeff. a(r-1) is unknown%								Sel.A(r) = 0 if coeff. a(r-1) = 0%							Sel.B = ny x nu x (OrderB+1)%								Sel.B(i,j,r) = 1 if coeff. b(i,j,r-1) is unknown%								Sel.B(i,j,r) = 0 if coeff. b(i,j,r-1) = 0%							Sel.Ig = ny x (OrderIg+1)%								Sel.Ig(i,r) = 1 if coeff. ig(i,r-1) is unknown%								Sel.Ig(i,r) = 0 if coeff. ig(i,r-1) = 0%		ModelVar		=	contains the information about the model to be identified%							structure with fields 'Transient', 'ThePlane', 'TheModel', 'Reciprocal', ...%								ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%								ModelVar.PlantPlane		=	plane of the plant model%																's':	continuous-time;%																'w':	sqrt(s)-domain%																'z':	discrete-time;%																'':		plane not defined%								ModelVar.Struct			=	model structure%																'OE':		output error (plant model only)%								ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%								ModelVar.nu				=	number of inputs%								ModelVar.ny				= 	number of outputs%								ModelVar.na				=	order polynomial A%								ModelVar.nb				= 	order matrix polynomial B%								ModelVar.nig			=	order vector polynomial Ig%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, 2004 % All rights reserved.% Software can be used freely for non-commercial applications only.% Version April, 2008%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculate the variation of the free model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Jacobian matrix of prediction error w.r.t. ALL model parametersJacob = LSJacob(data, xMat, ModelVar);% put the different frequency contributions on top of each other% size Jacob in: ny x ntheta x F% size Jacob out: ny*F x ntheta% size Error in: ny x F% size Error out: ny*F x 1ny = ModelVar.ny;F = size(data.Y,2);Error = zeros(ny, F);[Jacob, Error] = LeftWeighting(Jacob, Error, eye(ny, ny));% impose the common parameter structure and eliminate the excess parameters % size Jacob in: ny*F x ntheta% size Jacob out: ny*F x number of free model parametersJacob = Add_SelectColumns(Jacob, Sel, ModelVar);% scaling of the columns of the Jacobian matrix to improve the condition number TheScale = sum(abs(Jacob.^2), 1).^0.5;IndexZeroes = find(TheScale == 0);TheScale(IndexZeroes) = 1;Jacob = Jacob ./ repmat(TheScale, [size(Jacob, 1), 1]);% calculate the TLS solution[u, ss, v] = svd([real(Jacob); imag(Jacob)], 0);smax = ss(1,1);smin = ss(end-1,end-1);DeltaParam = v(:,end);% denormalisation parameter variationDeltaParam = DeltaParam ./ TheScale.';%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% extract the plant and noise model parameters from DeltaParam %% order in DeltaParam: a, b, ig, c, d, ih                      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%ny = ModelVar.ny;nu = ModelVar.nu;na = ModelVar.na;nb = ModelVar.nb;nig = ModelVar.nig;nc = ModelVar.nc;nd = ModelVar.nd;nih = ModelVar.nih;OldTheta.A = zeros(1, na + 1);OldTheta.B = zeros(ny, nu, nb + 1);OldTheta.Ig = zeros(ny, nig + 1);OldTheta.C = zeros(ny, ny, nc + 1);OldTheta.C(:,:,1) = eye(ny, ny);OldTheta.D = [1, zeros(1, nd)];OldTheta.Ih = zeros(ny, nih + 1);Theta = ExtractParam(DeltaParam, OldTheta, Sel);	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Impose constraints on updated parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Theta = Constrain(Theta, ModelVar);