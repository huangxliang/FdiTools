function [Sel, Theta0, ModelVar, IterVar] = DefaultValues(na, nb, nc, nd, nu, ny, PlantPlane, NoisePlane, ModelStruct, RecipPlant, RecipNoise);%%  [Sel, Theta0, ModelVar, ItterVar] = DefaultValues(na, nb, nc, nd, nu, ny, PlantPlane, NoisePlane, ModelStruct, RecipPlant, RecipNoise);%%		Generates the default values and structures for the estimation of%       MIMO Box-Jenkins model structures: see MIMOBoxJenkins for the definition%		of the variables%%					Box-Jenkins:		Y = B/A U + Ig/A  + C/D E + Jh/D%%%	Output parameters%%		Sel					=	structure with fields 'A', 'B', 'Ig', 'C', 'D', 'Ih'%									Sel = struct('A',[],'B',[], 'Ig', [], 'C',[],'D',[], 'Ih', [])%									Sel.A = 1 x (OrderA+1)%										Sel.A(r) = 1 if coeff. a(r-1) is unknown%										Sel.A(r) = 0 if coeff. a(r-1) = 0%									Sel.B = ny x nu x (OrderB+1)%										Sel.B(i,j,r) = 1 if coeff. b(i,j,r-1) is unknown%										Sel.B(i,j,r) = 0 if coeff. b(i,j,r-1) = 0%									Sel.Ig = ny x (OrderIg+1)%										Sel.Ig(i,r) = 1 if coeff. ig(i,r-1) is unknown%										Sel.Ig(i,r) = 0 if coeff. ig(i,r-1) = 0%									Sel.C = ny x ny x (OrderC+1)%										Sel.C(i,j,r) = 1 if coeff. c(i,j,r-1) is unknown%										Sel.C(i,j,r) = 0 if coeff. c(i,j,r-1) = 0%									Sel.D = 1 x (OrderD+1)%										Sel.D(r) = 1 if coeff. d(i,j,r-1) is unknown%										Sel.D(r) = 0 if coeff. d(i,j,r-1) = 0%									Sel.Ih = ny x (OrderIh+1)%										Sel.Ih(i,r) = 1 if coeff. ih(i,r-1) is unknown%										Sel.Ih(i,r) = 0 if coeff. ih(i,r-1) = 0%%		Theta0				=	starting value plant, noise, and initial conditions parameters%								structure with fields 'A', 'B', 'Ig', 'C', 'D', 'Ih'%									Theta0 = struct('A',[],'B',[], 'Ig', [], 'C',[],'D',[], 'Ih', [])%									Theta0.A = 1 x (OrderA+1)%										Theta0.A(r) = coefficient a(r-1) of Omega^(r-1) %									Theta0.B = ny x nu x (OrderB+1)%										Theta0.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%									Theta0.Ig = ny x (OrderIg+1)%										Theta0.Ig(i,r) = coefficient ig(i,r-1) of Omega^(r-1) %									Theta0.C = ny x ny x (OrderA+1)%										Theta0.C(i,j,r) = coefficient c(i,j,r-1) of Omega^(r-1) %									Theta0.D = 1 x (OrderD+1)%										Theta0.D(r) = coefficient d(r-1) of Omega^(r-1)%									Theta0.Ih = ny x (OrderIh+1)%										Theta0.Ih(i,r) = coefficient ih(i,r-1) of Omega^(r-1)%%		ModelVar			=	contains the information about the model to be identified%								structure with fields 'Transient', 'ThePlane', 'TheModel', 'Reciprocal'%									ModelVar = struct('Transient', [], 'PlantPlane', [], 'NoisePlane', [], 'Struct', [], 'Reciprocal',[])%									ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated %                                                               (default 1)%									ModelVar.PlantPlane		=	plane of the plant model%																	's':        continuous-time;%																	'w':        sqrt(s)-domain%																	'z':        discrete-time;%																	'':         plane not defined%									ModelVar.NoisePlane		=	plane of the plant model%																	's':        continuous-time;%																	'w':        sqrt(s)-domain%																	'z':        discrete-time;%																	'':         plane not defined%									ModelVar.Struct			=	model structure%																	'BJ':       Box-Jenkins %                                                                               (hybrid Box-Jenkins: PlantPlane = 's', NoisePlane = 'z') %																	'OE':       output error (plant model only)%																	'ARMA':		autoregressive moving average (noise model only)%																	'ARMAX':	autoregressive moving average with exogenous input%									ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%									ModelVar.RecipNoise		=	1 if noise model is reciprocal: H(i,j) = H(j,i)%%		IterVar				=	contains the information about the minimization procedure%								structure with fields 'LM', 'MaxIter', 'TolParam', 'TolCost', 'TraceOn'%									IterVar = struct('LM', [], 'MaxIter', [], 'TolParam', [], 'TolCost', [], 'TraceOn', [])%									IterVar.LM 			=	1 then then Levenberg-Marquardt minimization scheme is used%									IterVar.MaxIter 	=	maximum number of itterations of the minimization procedure %                                                           (optional, default 100) %									IterVar.TolParam 	=	relative precision on parameter estimates%									IterVar.TolCost 	=	relative precision on cost function%									IterVar.TraceOn 	=	1 then output iterations (optional)%									IterVar.NormJacob 	=	1 scales the columns of the Jacobian matrix such that the%                                                           columns have norm one (optional, default 1)%%	Input parameters%%		na                  =	order A polynomial%		nb                  =	order B matrix polynomial%		nc                  =	order C matrix polynomial%		nd                  =	order D polynomial%		nu                  =	number of inputs%                               (optional, default 1)%		ny                  =	number of outputs%		PlantPlane          =	domain plant model: 'z' for z-domain, 's' for s-domain, 'w' for sqrt(s)-domain %                               (optional, default 'z')%		NoisePlane          =	domain noise model: 'z' for z-domain, 's' for s-domain, 'w'for sqrt(s)-domain%                               (optional, default 'z')%       ModelStruct         =   model structure: 'OE', 'ARMA', 'ARMAX', or 'BJ'%                               (optional, default 'BJ')%       RecipPlant          =   1 if plant model reciprocal; otherwise zero  %                               (optional, default 0)%       RecipNoise          =   1 if noise model reciprocal; otherwise zero  %                               (optional, default 0)%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, 2004 % All rights reserved.% Software can be used freely for non-commercial applications only.% Version 14 October 2011%if isempty(na)    na = 0;endif isempty(nb)    nb = 0;endif isempty(nc)    nc = 0;endif isempty(nd)    nd = 0;endif isempty(nu)    nu = 1;endswitch nargin	case 6, PlantPlane = []; NoisePlane = []; ModelStruct = 'BJ'; RecipPlant = 0; RecipNoise = 0;	case 7, NoisePlane = []; ModelStruct = 'BJ'; RecipPlant = 0; RecipNoise = 0;    case 8, ModelStruct = 'BJ'; RecipPlant = 0; RecipNoise = 0;    case 9, RecipPlant = 0; RecipNoise = 0;    case 10, RecipNoise = 0;endnig = max(na, nb) - 1;		% correct in z-domain; should be increased for s- and sqrt(s)-domainsnih = max(nc, nd) - 1;		% correct in z-domain; should be increased for s- and sqrt(s)-domainsSel = struct('A',[], 'B',[], 'Ig', [], 'C', [], 'D',[], 'Ih', []);	Sel.A = ones(1, na+1);	Sel.B = ones(ny, nu, nb+1);	if nig < 0		nig = 0;		Sel.Ig = zeros(ny, nig+1);	else		Sel.Ig = ones(ny, nig+1);	end	Sel.C = ones(ny, ny, nc+1);	Sel.D = ones(1, nd+1);	if nih < 0		nih = 0;		Sel.Ih = zeros(ny, nih+1);	else		Sel.Ih = ones(ny, nih+1);	end	Theta0 = struct('A',[], 'B',[], 'Ig', [], 'C',[], 'D',[], 'Ih', []);	Theta0.A = zeros(1, na+1);	Theta0.A(1) = 1;	Theta0.B = zeros(ny, nu, nb+1);	Theta0.B(:,:,1) = eye(ny, nu);	Theta0.Ig = zeros(ny, nig+1);	Theta0.C = zeros(ny, ny, nc+1);	Theta0.C(:,:,1) = eye(ny, ny);	Theta0.D = zeros(1,nd+1);	Theta0.D(1) = 1;	Theta0.Ih = zeros(ny, nih+1);	ModelVar = struct('Transient', [], 'PlantPlane', [], 'NoisePlane', [], 'Struct', [], 'RecipPlant', [], 'RecipNoise', [],...				   'nu', [], 'ny', [], 'na', [], 'nb', [], 'nig', [], 'nc', [], 'nd', [], 'nih', []);	ModelVar.Transient = 1;	if isempty(PlantPlane)		ModelVar.PlantPlane = 'z';	else		ModelVar.PlantPlane = PlantPlane;	end	if isempty(NoisePlane)		ModelVar.NoisePlane = 'z';	else		ModelVar.NoisePlane = NoisePlane;	end	ModelVar.Struct = ModelStruct;    if strcmp(ModelVar.Struct, 'OE')        ModelVar.NoisePlane = '';    end % if OE model    if strcmp(ModelVar.Struct, 'ARMA')        ModelVar.PlantPlane = '';    end % if ARMA model	ModelVar.RecipPlant = RecipPlant;	ModelVar.RecipNoise = RecipNoise;	ModelVar.nu = nu;	ModelVar.ny = ny;	ModelVar.na = na;	ModelVar.nb = nb;	ModelVar.nig = nig;	ModelVar.nc = nc;	ModelVar.nd = nd;	ModelVar.nih = nih;	IterVar = struct('LM', [], 'MaxIter', [], 'TolParam', [], 'TolCost', [], 'TraceOn', [], 'NormJacob', []);	IterVar.LM = 1;	IterVar.MaxIter = 100;	IterVar.TolParam = 1e-6;	IterVar.TolCost = 1e-10;	IterVar.TraceOn = 1;    IterVar.NormJacob = 1;[Theta0, Sel, ModelVar] = ImposeModelCompatibility(Theta0, Sel, ModelVar);