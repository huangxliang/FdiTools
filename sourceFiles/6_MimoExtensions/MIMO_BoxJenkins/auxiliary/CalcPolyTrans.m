function PolyTrans = CalcPolyTrans(Theta, x);%% function PolyTrans = CalcPolyTrans(Theta, x);%%	Output parameters%%		PolyTrans	=	structure containing the polynomials and transfer functions evaluated in x%							PolyTrans.A		=	denominator polynomial plant transfer function evaluated in x.Plant, dimensions 1 x number of freq.%							PolyTrans.D		=	D polynomial evaluated in x.Noise, dimensions 1 x number of freq.%							PolyTrans.G		=	plant transfer matrix evaluated in x.Plant, dimensions ny x nu x number of freq.%							PolyTrans.H		=	noise transfer matrix evaluated in x.Noise, dimensions ny x ny x number of freq.%							PolyTrans.Hinv	=	inverse of the noise transfer matrix evaluated in x.Noise, dimensions ny x ny x number of freq.%							PolyTrans.Tg	=	plant transient term evaluated in x.Plant, dimension ny x number of freq.%							PolyTrans.Th	=	noise transient term evaluated in x.Noise, dimension ny x number of freq.%%	Input parameters%%		Theta				=	plant, noise, and initial conditions parameters%								structure with fields 'A', 'B', 'Ig', 'C', 'D', 'Ih'%									Theta = struct('A',[],'B',[], 'Ig', [], 'C',[],'D',[], 'Ih', [])%									Theta.A = 1 x (OrderA+1)%										Theta.A(r) = coefficient a(r-1) of x^(r-1) %									Theta.B = ny x nu x (OrderB+1)%										Theta.B(i,j,r) = coefficient b(i,j,r-1) of x^(r-1)%									Theta.Ig = ny x (OrderIg+1)%										Theta.Ig(i,r) = coefficient ig(i,r-1) of x^(r-1) %									Theta.C = ny x ny x (OrderA+1)%										Theta.C(i,j,r) = coefficient c(i,j,r-1) of x^(r-1) %									Theta.D = 1 x (OrderD+1)%										Theta.D(r) = coefficient d(r-1) of x^(r-1)%									Theta.Ih = ny x (OrderIh+1)%										Theta.Ih(i,r) = coefficient ih(i,r-1) of x^(r-1)%%		x                   =	structure containing (jwk) or (zk^-1) values%                                   x.Plant	=	plant model, dimension: number of frequencies x 1%                                   x.Noise	=	noise model, dimension: number of frequencies x 1%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, 2004 % All rights reserved.% Software can be used freely for non-commercial applications only.% Version April 2008%ny = size(Theta.B,1);		% number of outputsnu = size(Theta.B,2);		% number of inputsF = length(x.Plant);		% number of frequenciesPolyTrans = struct('A', zeros(1,F), 'D', zeros(1,F), 'G', zeros(ny, nu, F), 'H', zeros(ny, ny, F), ...                   'Hinv', zeros(ny, ny, F), 'Tg', zeros(ny, F), 'Th', zeros(ny, F));%%%%%%%%%%%%%%%%%%%%%%%% A and D polynomials %%%%%%%%%%%%%%%%%%%%%%%%PolyTrans.A = polyval(fliplr(Theta.A), x.Plant.');PolyTrans.D = polyval(fliplr(Theta.D), x.Noise.');%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% G ny x nu plant transfer matrix %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for ii = 1:ny	for jj = 1:nu		PolyTrans.G(ii, jj, :) = polyval(fliplr(squeeze(Theta.B(ii, jj, :)).'), x.Plant.');	end % jjend % iidummy = zeros(1,1,F);dummy(1,1,:) = PolyTrans.A;PolyTrans.G = PolyTrans.G./repmat(dummy, ny, nu);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ny x ny noise transfer matrix H and its inverse Hinv %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculate H = C/Dfor ii = 1:ny	for jj = 1:ny		PolyTrans.H(ii, jj, :) = polyval(fliplr(squeeze(Theta.C(ii, jj, :)).'), x.Noise.');	end % jjend % iidummy(1,1,:) = PolyTrans.D;PolyTrans.H = PolyTrans.H./repmat(dummy, ny, ny);% calculate the inverse Hinv = D*C^(-1)if ny > 1    for kk = 1:F        PolyTrans.Hinv(:, :, kk) = inv(PolyTrans.H(:, :, kk));    end % kkelse % ny = 1    PolyTrans.Hinv = 1./PolyTrans.H;end % if%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Plant and noise transient terms %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for ii = 1:ny	PolyTrans.Tg(ii,:) = polyval(fliplr(Theta.Ig(ii,:)), x.Plant.');	PolyTrans.Th(ii,:) = polyval(fliplr(Theta.Ih(ii,:)), x.Noise.');end % iiPolyTrans.Tg = PolyTrans.Tg./repmat(PolyTrans.A, ny, 1);PolyTrans.Th = PolyTrans.Th./repmat(PolyTrans.D, ny, 1);