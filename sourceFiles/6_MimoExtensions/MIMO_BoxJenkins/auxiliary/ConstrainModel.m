function [Theta, Sel] = ConstrainModel(Theta, Sel, ModelVar);%% function [Theta, Sel] = ConstrainModel(Theta, Sel, ModelVar);%%	The (normalised) coefficients of the BJ, OE, ARMA, and ARMAX model structures%	Y = B/A U + Ig/A + C/D E + Ih/D are constrained as follows%       z-domain:                   a0 = d0 = 1, ck = ck * CovE^(-1/2), and c0 is made symmetric through orthogonal transformations%       s-, and sqrt(s)-domains:    ana = dnd = 1, ck = ck * CovE^(-1/2), and cnc is made symmetric through orthogonal transformations%%	Output parameters%%		Theta				=	estimated value plant, noise, and initial conditions parameters%								Theta = struct('A', [], 'B', [], 'Ig', [], 'C', [], 'D', [], 'Ih', [])%									Theta.A     =   1 x (OrderA+1)%                                                       Theta.A(r) = coefficient a(r-1) of Omega^(r-1) %									Theta.B     =   ny x nu x (OrderB+1)%                                                       Theta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%									Theta.Ig    =   ny x (OrderIg+1)%                                                       Theta.Ig(i,r) = coefficient ig(i,r-1) of Omega^(r-1) %									Theta.C     =   ny x ny x (OrderC+1)%                                                       Theta.C(i,j,r) = coefficient c(i,j,r-1) of Omega^(r-1) %									Theta.D     =   1 x (OrderD+1)%                                                       Theta.D(r) = coefficient d(r-1) of Omega^(r-1)%									Theta.Ih    =   ny x (OrderIh+1)%                                                       Theta.Ih(i,r) = coefficient ih(i,r-1) of Omega^(r-1)%                                   Theta.CovE  =   covariance matrix ny x 1 driving white noise source %%		Sel					=	selects the free model parameters in the constrained case%								Sel = struct('A', [], 'B', [], 'Ig', [], 'C', [], 'D', [], 'Ih', [])%									Sel.A       =   1 x (OrderA+1)%                                                       Sel.A(r) = 1 if coeff. a(r-1) is unknown%                                                       Sel.A(r) = 0 if coeff. a(r-1) = 0%									Sel.B       =   ny x nu x (OrderB+1)%                                                       Sel.B(i,j,r) = 1 if coeff. b(i,j,r-1) is unknown%                                                       Sel.B(i,j,r) = 0 if coeff. b(i,j,r-1) = 0%									Sel.Ig      =   ny x (OrderIg+1)%                                                       Sel.Ig(i,r) = 1 if coeff. ig(i,r-1) is unknown%                                                       Sel.Ig(i,r) = 0 if coeff. ig(i,r-1) = 0%									Sel.C       =   ny x ny x (OrderC+1)%                                                       Sel.C(i,j,r) = 1 if coeff. c(i,j,r-1) is unknown%                                                       Sel.C(i,j,r) = 0 if coeff. c(i,j,r-1) = 0%									Sel.D       =   1 x (OrderD+1)%                                                       Sel.D(r) = 1 if coeff. d(i,j,r-1) is unknown%                                                       Sel.D(r) = 0 if coeff. d(i,j,r-1) = 0%									Sel.Ih      =   ny x (OrderIh+1)%                                                       Sel.Ih(i,r) = 1 if coeff. ih(i,r-1) is unknown%                                                       Sel.Ih(i,r) = 0 if coeff. ih(i,r-1) = 0%%	Input parameters%%       Theta               =   see output parameters, unconstrained model parameters%%		ModelVar			=	contains the information about the model to be identified%								structure with fields 'Transient', 'ThePlane', 'TheModel', 'Reciprocal'%									ModelVar = struct('Transient', [], 'PlantPlane', [], 'NoisePlane', [], 'Struct', [], 'Reciprocal',[])%									ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%									ModelVar.PlantPlane		=	plane of the plant model%																	's':	continuous-time;%																	'w':	sqrt(s)-domain%																	'z':	discrete-time;%																	'':		plane not defined%									ModelVar.NoisePlane		=	plane of the plant model%																	's':	continuous-time;%																	'w':	sqrt(s)-domain%																	'z':	discrete-time;%																	'':		plane not defined%									ModelVar.Struct			=	model structure%																	'BJ':		Box-Jenkins%																	'OE':		output error (plant model only)%																	'ARMA':		autoregressive moving average (noise model only)%																	'ARMAX':	autoregressive moving average with exogenous input%									ModelVar.DiagNoiseModel	=	1 if noise model is diagonal%									ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%									ModelVar.RecipNoise		=	1 if noise model is reciprocal: H(i,j) = H(j,i)%									ModelVar.nu				=	number of inputs%									ModelVar.ny				= 	number of outputs%									ModelVar.na				=	order polynomial A%									ModelVar.nb				= 	order matrix polynomial B%									ModelVar.nig			=	order vector polynomial Ig%									ModelVar.nc				=	order matrix polynomial C%									ModelVar.nd				=	order polynomial D%									ModelVar.nih			=	order vector polynomial Ih%%       Sel                 =   see output parameter, Selects the free model parameters in the unconstrained case%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, April 2005 % All rights reserved.% Software can be used freely for non-commercial applications only.% Version April 2008%Scale = struct('Plant', [], 'Noise', []);% constraining the plant model parametersswitch ModelVar.PlantPlane    case 'z'        Scale.Plant = Theta.A(1);        Sel.A(1) = 0;    case {'s', 'w'}        Scale.Plant = Theta.A(end);        Sel.A(end) = 0;    otherwise        Scale.Plant = 1;endTheta.A = Theta.A/Scale.Plant;Theta.B = Theta.B/Scale.Plant;Theta.Ig = Theta.Ig/Scale.Plant;% constraining the noise model parameters[ue, se, ve] = svd(Theta.CovE, 0);SqrtCovE = ue * diag(diag(se).^(0.5)) * ue.';    % symmetric square root of CovEswitch ModelVar.NoisePlane    case 'z'        Scale.Noise = Theta.D(1);        Sel.D(1) = 0;    case {'s', 'w'}        Scale.Noise = Theta.D(end);        Sel.D(end) = 0;   otherwise        Scale.Noise = 1;endfor rr = 1:(ModelVar.nc+1)    Theta.C(:,:,rr) = Theta.C(:,:,rr)*SqrtCovE;end % rrTheta.C = Theta.C/Scale.Noise;Theta.D = Theta.D/Scale.Noise;Theta.Ih = Theta.Ih/Scale.Noise;% make the leading or the last matrix coefficient symmetric through orthogonal transformations% this does not change the estimate of CovEswitch ModelVar.NoisePlane    case {'z', ''}        T = Theta.C(:,:,1);        for jj=2:ModelVar.ny            for ii = 1:jj-1                Sel.C(ii, jj, 1) = 0;            end % ii        end % jj    case {'s', 'w'}        T = Theta.C(:,:,end);        for jj=2:ModelVar.ny            for ii = 1:jj-1                Sel.C(ii, jj, end) = 0;            end % ii        end % jjend[uc, sc, vc] = svd(T, 0);T = vc * uc.';for rr = 1:(ModelVar.nc+1)    Theta.C(:,:,rr) = Theta.C(:,:,rr)*T;end % rr