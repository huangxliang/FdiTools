function [a, b, ig] = BJDeNormalise(a, b, ig, wscale, Transient);%%	[a, b, t, s] = BJDeNormalise(a, b, ig, s, wscale, Transient);%%	output parameters%		a		=	coefficients denominator polynomial plant model, dimension 1 x OrderA+1%		b		=	coefficients numerator polynomial plant model, dimension 1 x OrderB+1%		t		=	coefficients transient polynomial T, dimension 1 x OrderT+1%		ig		=	coefficients transient polynomial Tg, dimension 1 x OrderTg+1%%	input parameters%		a				=	normalised coefficients denominator polynomial plant model, dimension 1 x OrderA+1%		b				=	normalised coefficients numerator polynomial plant model, dimension 1 x OrderB+1%		ig				=	normalised coefficients transient polynomial T, dimension 1 x OrderT+1%		Transient		=	if Transient = 1 then transient polynomial T is estimated%		wscale			=	scaling angular frequency%% Rik Pintelon, 1998% version April, 2004%MaxOrder = max([length(a), length(b), length(ig)]) - 1;for ii = 0:MaxOrder	Scale(ii+1) = wscale^ii;end% denormalisation can also be applied when each row is another realisation[ra,ca] = size(a);[rb,cb] = size(b);[rig,cig] = size(ig);a = a./repmat(Scale(1:ca),ra,1);b = b./repmat(Scale(1:cb),rb,1);if Transient	ig = ig./repmat(Scale(1:cig),rig,1);end