function [Ch, Csh, Ca, Cf] = CR_NoiseModel(c, d, Cp, q, wscale, ThePlane, s2);%%	function [Ch, Csh, Ca, Cf] = CR_NoiseModel(c, d, Cp, q, wscale, ThePlane, s2)%%	output parameters%		Ch			=	Cramer-Rao bound on the estimates of the noise transfer function H assuming that%						the initial conditions are known, dimension number of frequencies x 1%		Csh			=	Cramer-Rao bound on the estimates sigma*abs(H) assuming that%						the initial conditions are known, dimension number of frequencies x 1%		Ca			=	Cramer-Rao bound on the estimates of the amplitude (in decibel) of the noise transfer function %						assuming that the initial conditions are known, dimension number of frequencies x 1%		Cf			=	Cramer-Rao bound on the estimates of the phase (in degrees) of the noise transfer function %						assuming that the initial conditions are known, dimension number of frequencies x 1%						NOW: VALID FOR OPEN LOOP BJ ONLY%%	input parameters%		c			=	coefficients numerator polynomial noise model, dimension 1 x OrderC%		d			=	coefficients denominator polynomial noise model, dimension 1 x OrderD%		Cp			=	Cramer-Rao bound on the estimates of the noise model parameters assuming that%							the initial conditions are known, dimension (OrderC + OrderD) x (OrderC + OrderD)%		q			=	vector of zk^-1 values, dimension: number of frequencies x 1%		wscale		=	scaling angular frequency%		ThePlane	=	'z', 's', 'w' => discrete-time or continous-time noise model%		s2			=	estimate of the variance of the white noise source%% Rik Pintelon, 1998% version May, 2004%%% normalisation frequency and noise model parametersif (ThePlane == 's') | (ThePlane == 'w')	q = q/wscale;	[c, d, dummy] = BJNormalise(c, d, [0], wscale, 0);end;NN = length(q);OrderC = length(c) - 1;OrderD = length(d) - 1;NumberParam = OrderC + OrderD;C = polyval(fliplr(c),q); C = C(:);D = polyval(fliplr(d),q); D = D(:);H = C./D;qMat = CalcBJOmegaMat(q, max(OrderC, OrderD));% derivative w.r.t. numerator coefficientsswitch ThePlane	case 'z', TheIndex = [2:OrderC+1];	case {'s','w'}, TheIndex = [1:OrderC];endP = qMat(:,TheIndex)./repmat(D,1,OrderC);Q = qMat(:,TheIndex)./repmat(C,1,OrderC);R = Q - repmat(mean(Q,1),NN,1);% derivative w.r.t. denominator coefficientsswitch ThePlane	case 'z', TheIndex = [2:OrderD+1];	case {'s','w'}, TheIndex = [1:OrderD];endP = [P qMat(:,TheIndex).*repmat(-C./(D.^2),1,OrderD)];dummy = qMat(:,TheIndex)./repmat(-D,1,OrderD);Q = [Q dummy];R = [R (dummy - repmat(mean(dummy,1),NN,1))];R = real(R);Ch = real(sum(P.'.*(Cp*P'))); Ch = Ch(:);Ca = (20/log(10))^2*sum(real(Q).'.*(Cp*real(Q).')); Ca = Ca(:);Cf = (180/pi)^2*sum(imag(Q).'.*(Cp*imag(Q).')); Cf = Cf(:);Csh = real(sum(R.'.*(Cp*R'))); Csh = s2*Csh(:).*abs(H.^2);