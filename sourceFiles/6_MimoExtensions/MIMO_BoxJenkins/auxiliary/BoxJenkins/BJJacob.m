function TheJacob = BJJacob(Y, U, sMat, qMat, Error, A, B, Ig, C, D, Jh, Gc, SelA, SelB, OrderI, ...							OrderC, OrderD, OrderJ, Transient, TheNoisePlane, TheModel, LogDet, DC, Nyquist);%%      TheJacob = BJJacob(Y, U, sMat, qMat, Error, A, B, Ig, C, D, Jh, Gc, SelA, SelB, OrderI, ...%							OrderC, OrderD, OrderJ, Transient, TheNoisePlane, TheModel, LogDet, DC, Nyquist)%% calculates the jacobian matrix w.r.t. the plant and transient model parameters%% output parameters% 	TheJacob 		=	jacobian matrix, dimensions number of frequencies x number of parameters%% input parameters%		Y				=	DFT spectrum output signal, dimensions: number of frequencies x 1%		U				=	DFT spectrum input signal, dimensions: number of frequencies x 1%		sMat			=	table of powers of (jwk)^r,  (jwk)^(r/2), or (zk^-r)%		qMat			=	table of powers of (zk^-r)%		Error			=	scaled error model equation: (A*Y-B*U-Ig-Jh*A/D)/(abs(A)*C/D)*gT%							where gT = g(c,d) contribution logdet term loglikelihood to cost function%							gT = 1 if logdet term is not present%		A				=	denominator plant model evaluated at the DFT frequencies, dimensions: number of frequencies x 1%		B				=	numerator plant model evaluated at the DFT frequencies, dimensions: number of frequencies x 1%		Ig				=	initial cond. plant model evaluated at the DFT frequencies, dimensions: number of frequencies x 1%		C				=	numerator noise model evaluated at the DFT frequencies, dimensions: number of frequencies x 1%		D				=	denominator noise model evaluated at the DFT frequencies, dimensions: number of frequencies x 1%		Jh				=	initial cond. noise model evaluated at the DFT frequencies, dimensions: number of frequencies x 1%		Gc				=	controller transfer function, zero or empty if unknown or not present%		SelA			=	if 1 then coeff. A-polynomial is unknown; if zero the coeff. is known equal to zero%		SelB			=	if 1 then coeff. B-polynomial is unknown; if zero the coeff. is known equal to zero%		OrderI			=	order initial cond. polynomial plant model%		OrderJ			=	order initial cond. polynomial noise model%		Transient		=	if Transient = 1 then initial conditions plant and/or noise model are estimated%		TheNoisePlane	=	'z', 's', 'w' => discrete-time or continous-time noise model%		TheModel		=	'BJ		=>	Box-Jenkins;%							'OE'	=>	output error (plant model only);%							'NO' => autoregressive moving average (noise model only)%		LogDet			=	1 if logdet(NoiseCovarianceMatrix) is present in loglikelihood; otherwise 0%		DC				=	1 if DC present otherwise 0%		Nyquist			=	1 if Nyquist frequency present otherwise 0%% Rik Pintelon, 1998% version April, 2004, added: CT and DT noise modeling in limited frequency band% version July, 2004, added: ARMAX%% note that DC and Nyquist have a contribution 1/2 to the cost function% therefore the appropriate variables must be scaled by 1/sqrt(2) at DC% and Nyquist; this is alreday done for the variable Errorif LogDet == 1	NN = length(Y);	gT = exp(mean(log(C./D./(1+Gc.*B./A))));	if DC == 1 gT = gT/(C(1)/D(1)./(1+Gc(1).*B(1)./A(1)))^(1/(2*NN)); end	if Nyquist == 1 gT = gT/(C(end)/D(end)./(1+Gc(end).*B(end)./A(end)))^(1/(2*NN)); endelse	gT = 1;endStdE = abs(A);if strcmp(TheModel,'BJ') | strcmp(TheModel,'OE') | strcmp(TheModel,'ARMAX')	% contribution parameters denominator plant model	sumA = sum(SelA);	if Transient == 1		dummy1 = gT*(D.*Y-Jh)./C./StdE;	else		dummy1 = gT*D.*Y./C./StdE;	end	if DC == 1 dummy1(1) = dummy1(1)/sqrt(2); end	if Nyquist == 1 dummy1(end) = dummy1(end)/sqrt(2); end	dummy2 = real(Error)./A;	dummy3 = imag(Error)./A;	dummy = sMat(:,SelA==1).*repmat(dummy1,1,sumA);	dummy = dummy - real(sMat(:,SelA==1).*repmat(dummy2,1,sumA)) - sqrt(-1)*real(sMat(:,SelA==1).*repmat(dummy3,1,sumA));	if LogDet == 1		dummy = dummy + Error*mean(sMat(:,SelA==1).*repmat(Gc.*B./A./(A+Gc.*B),1,sumA),1);	end	TheJacob = dummy;		% contribution parameters numerator plant model	sumB = sum(SelB);	dummy1 = -gT*D.*U./C./StdE;	if DC == 1 dummy1(1) = dummy1(1)/sqrt(2); end	if Nyquist == 1 dummy1(end) = dummy1(end)/sqrt(2); end	dummy = sMat(:,SelB==1).*repmat(dummy1,1,sumB);	if LogDet == 1		dummy = dummy - Error*mean(sMat(:,SelB==1).*repmat(Gc./(A+Gc.*B),1,sumB),1);	end	TheJacob = [TheJacob dummy];		% contribution parameters initial conditions plant model	if Transient == 1		dummy = -gT*D./C./StdE;		if DC == 1 dummy(1) = dummy(1)/sqrt(2); end		if Nyquist == 1 dummy(end) = dummy(end)/sqrt(2); end		TheJacob = [TheJacob sMat(:,1:OrderI+1).*repmat(dummy,1,OrderI+1)];	end;endif strcmp(TheModel,'BJ') | strcmp(TheModel,'ARMA') | strcmp(TheModel,'ARMAX')	% contribution parameters numerator noise model	dummy1 = -Error./C;	switch TheNoisePlane		case 'z', TheIndex = [2:OrderC+1];		case {'s','w'}, TheIndex = [1:OrderC+1];	end	dummy = qMat(:,TheIndex).*repmat(dummy1,1,length(TheIndex));	if LogDet == 1		dummy = dummy + Error*mean(qMat(:,TheIndex)./repmat(C,1,length(TheIndex)),1);	end	if strcmp(TheModel,'BJ') | strcmp(TheModel,'ARMAX')		TheJacob = [TheJacob dummy];	else		TheJacob = dummy;    end		% contribution parameters denominator noise model	if Transient == 1		dummy1 = gT*(A.*Y-B.*U-Ig)./C./StdE;	else		dummy1 = gT*(A.*Y-B.*U)./C./StdE;	end	if DC == 1 dummy1(1) = dummy1(1)/sqrt(2); end	if Nyquist == 1 dummy1(end) = dummy1(end)/sqrt(2); end	switch TheNoisePlane		case 'z',			TheIndex = [2:OrderD+1];			if  strcmp(TheModel,'ARMAX')				TheIndex = [1:OrderD+1];			end		case {'s','w'},			TheIndex = [1:OrderD+1];	end	dummy = qMat(:,TheIndex).*repmat(dummy1,1,length(TheIndex));	if LogDet == 1		dummy = dummy - Error*mean(qMat(:,TheIndex)./repmat(D,1,length(TheIndex)),1);	end	if  strcmp(TheModel,'ARMAX')		% for ARMAX models A = D so that the derivatives w.r.t. a and d should be added		TheJacob(:,1:sum(SelA)) = TheJacob(:,1:sum(SelA)) + dummy;	else		TheJacob = [TheJacob dummy];	end		% contribution parameters initial conditions noise model	if Transient == 1		dummy = -gT*A./C./StdE;		if DC == 1 dummy(1) = dummy(1)/sqrt(2); end		if Nyquist == 1 dummy(end) = dummy(end)/sqrt(2); end		TheJacob = [TheJacob qMat(:,1:OrderJ+1).*repmat(dummy,1,OrderJ+1)];	end;end