function s2 = varest(Y, U, G, Tg, feedback)%%	s2 = varest(Y, U, G, Tg, feedback)%%		Estimation of the noise variance%			Robust method%			1st differentiation of the output residuals reduces model errors on the transient%			2nd differentiation (after devision by differentiated input) reduces transfer function errors%%	Output parameter% 		s2	=	estimated variance as a function of frequency F%%	Input parameters%		Y			=	output Fourier data%		U			=	input Fourier data%		G			=	(optional) the modelled transfer function G (=B/A)%		Tg			=	(optional) the modelled transient in the output Tg (=Ig/A)%		feedback	=	'on' the data should be processed as being collected in feedback%						this option can only be used if a good estimate of B,A and T is available%% Modified by Rik Pintelon, April 1, 2004 (not a joke!) and April 2005%% n = width of the window 2*n+1 to average the final variance estimatesn = max(ceil(length(Y)/500),5);% select the proper algorithmif nargin < 5  	select = 1;  % use the robust methodelseif strcmp(feedback,'on')	select = 2;   % identify under feedback conditionselse	select = 1;   % use the robust methodend    if nargin < 4        Tg = zeros(size(Y));	% no transient parameters availableendif nargin < 3    G = zeros(size(Y));		% no transfer function parameters availableendN = length(Y);      % number of data pointsY = Y - Tg - G.*U;  % eliminate the model contributions to the outputswitch select    % select == 1  robust method                      %        == 2  feedback identification            case 1                 		UU = [U(2:end)' 0]';	UU = abs(UU).^2;		Y = diff([Y' 0]');     					% reduce impact of model errors on the transient	U = diff([U' 0]');	E = diff([(Y./U)' 0]');					% reduce impact of model errors on the transfer function		E = abs(E).^2;		U2 = abs(U).^2;		linesA = [0:2*n];	lines = [0:2*n-1];		for k = 1:2*n+1:N-2*n		i = k+lines;        s = sum(E(i).*U2(i).*U2(i+1))/sum(U2(i)+U2(i+1)+(abs(U(i+1)+U(i))).^2);		i = k+linesA;		s2(i,1)=s;	end		s2(k+2*n+1:N) = s;						% border effects --> can be improved		s2(s2<0) = eps*ones(size(s2(s2<0)));	% put negative values equal to zero	s2 = s2;    case 2    	E = abs(Y).^2;	linesA = [0:2*n];	lines = [0:2*n-1]; 		for k = 1:2*n+1:N-2*n		i = k+lines;		s = sum(E(i));		i = k+linesA;		s2(i,1) = s;	end		s2(k+2*n+1:N) = s;						% border effects --> can be improved	s2 = s2/(2*n);end