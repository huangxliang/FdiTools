function [Cg, Ca, Cf] = CR_PlantModel(an, bn, SelA, SelB, Cplant, s, wscale, ThePlane, ComplexParam, Taun, Delay);%%	function [Cg, Ca, Cf] = CR_PlantModel(an, bn, SelA, SelB, Cplant, s, wscale, ThePlane, ComplexParam, Taun, Delay)%%	output parameters%		Cg			=	Cramer-Rao bound on the estimates of the plant transfer function assuming that%						the initial conditions are known, dimension number of frequencies x 1%		Ca			=	Cramer-Rao bound on the estimates of the amplitude (in decibel) of the noise transfer function %						assuming that the initial conditions are known, dimension number of frequencies x 1%		Cf			=	Cramer-Rao bound on the estimates of the phase (in degrees) of the noise transfer function %						assuming that the initial conditions are known, dimension number of frequencies x 1%%	input parameters%		an				=	normalised coefficients denominator (including those which are not estimated) polynomial plant model, %                           dimension 1 x OrderA%                           the denominator polynomial is monic:%							    DT-model: a(1) = 1;%							    CT-model: a(end) = 1.%		bn				=	normalised coefficients numerator polynomial plant model (including those which are not estimated),%                           dimension 1 x OrderB%		SelA			=	if 1 then coeff. A-polynomial is unknown; if zero the coeff. is known equal to zero%		SelB			=	if 1 then coeff. B-polynomial is unknown; if zero the coeff. is known equal to zero%		Cplant			=	Cramer-Rao bound on the estimates of the scaled (normalised) plant model parameters assuming that%							the initial conditions are known, dimension (sum(SelA) + sum(SelB) - 1) x (sum(SelA) + sum(SelB) - 1)%							The scaling of the parameters in the Cramer-Rao bound is such that%							DT-model: a(1) = 1;%							CT-model: a(end) = 1.%		s				=	vector of (jwk) or zk^-1 or sqrt(jwk) values, dimension: number of frequencies x 1%		wscale			=	scaling angular frequency%		ThePlane		=	'z' => discrete-time plant model, 's' continuous-time plant model, 'w' sqrt(s)-model%		ComplexParam	=	ComplexParam = 1 => a and b are complex and noise is circular complex distributed%		Taun			=	normalised delay (optional parameter)%		Delay			=	if Delay = 1 then delay Taun is estimated; otherwise it is fixed (optional parameter)%% Rik Pintelon, 1998% version July, 2006%% verify the input parameters: the last three are optionalif nargin == 8	ComplexParam = 0;	Taun = [];end;if nargin == 9	Taun = [];end;if isempty(Taun)	Taun = 0;	Delay = 0;end;% normalisation frequencyif (ThePlane == 's') | (ThePlane == 'w')	s = s/wscale;end;s = s(:);% calculation delay contribution to transfer functionif ThePlane == 's'	qTau = exp(-Taun*s);elseif ThePlane == 'w'	qTau = exp(-Taun*(s.^2));elseif ThePlane == 'z'	qTau = s.^(Taun);end;sumA = sum(SelA);sumB = sum(SelB);OrderB = length(bn) - 1;OrderA = length(an) - 1;NumberParam = sumA + sumB;if Delay == 1	NumberParam = NumberParam + 1;end;B = polyval(fliplr(bn),s);A = polyval(fliplr(an),s);sMat = CalcBJOmegaMat(s, max(OrderB, OrderA));% derivative w.r.t. denominator coefficientsP = sMat(:,SelA == 1).*repmat(-qTau.*B./(A.^2),1,sumA);Q = sMat(:,SelA == 1)./repmat(-A,1,sumA);% derivative w.r.t. numerator coefficientsP = [P, sMat(:,SelB == 1).*repmat(qTau./A,1,sumB)];Q = [Q, sMat(:,SelB == 1)./repmat(B,1,sumB)];% derivative w.r.t. the delayif Delay == 1	if ThePlane == 's'		qd = s;	elseif ThePlane == 'w'		qd = s.^2;	elseif ThePlane == 'z'		qd = -log(s);	end;	P = [P, -qd.*qTau.*B./A];	Q = [Q, -qd];end;% first eliminate possible transient parametersCg = sum(P.'.*(Cplant*P')); Cg = real(Cg(:));	% precaution to eliminate eps imaginary partif ComplexParam == 0	Ca = (20/log(10))^2*sum(real(Q).'.*(Cplant*real(Q).')); Ca = real(Ca(:));	% precaution to eliminate eps imaginary part	Cf = (180/pi)^2*sum(imag(Q).'.*(Cplant*imag(Q).')); Cf = real(Cf(:));		% precaution to eliminate eps imaginary partelseif ComplexParam == 1	Ca = (20/log(10))^2*sum(Q.'.*(Cplant*Q')); Ca = real(Ca(:)/2);				% real part is necessary !!	Cf = (180/pi)^2*sum(Q.'.*(Cplant*Q')); Cf = real(Cf(:)/2);					% real part is necessary !!end;