function [a, b, ig, c, d, jh, s2, Cost, smax, smin, Cplant, Cnoise, wscale] = BoxJenkins(Y, U, freq, Ts, Gc, SelA, SelB, OrderI, OrderC, OrderD, OrderJ, astart, bstart, igstart, cstart, dstart, jhstart,...																						 Transient, ThePlane, TheModel, LevenbergMarquardt, MaxItterations, TolParam, TolCost, TraceOn, kuc);%% [a, b, ig, c, d, jh, s2, Cost, smax, smin, Cplant, Cnoise, wscale] = BoxJenkins(Y, U, freq, Ts, Gc, ...%																				  SelA, SelB, OrderI, OrderC, OrderD, OrderJ, ...%																				  astart, bstart, igstart, cstart, dstart, jhstart,...%																				  Transient, ThePlane, TheModel, LevenbergMarquardt, ...%																				  MaxItterations, TolParam, TolCost, TraceOn, kuc);%%				Box-Jenkins:	Y = B/A U + Ig/A + C/D E + Jh/D%				OE:				Y = B/A U + Ig/A + E				(no noise model)%				ARMA:			Y = C/D E + Jh/D					(no plant model)%				ARMAX:			Y = B/A U  + C/A E + J/A%%%	output parameters%		a		=	new estimate coefficients denominator polynomial plant model, dimension 1 x OrderA+1%		b		=	new estimate coefficients numerator polynomial plant model, dimension 1 x OrderB+1%		ig		=	new estimate coefficients initial conditions plant model, dimension 1 x OrderI+1%					Note:	all a, b, and ig coefficients are free during the minimization + %							norm([a, b, ig]) = 1 scaling in each iteration step.%					'z' plane:		the returned normalised a, b, ig values are scaled such that a(1) = 1.%					's','w' plane:	the returned normalised a, b, ig values are scaled such that a(end) = 1.%		c		=	new estimate coefficients numerator polynomial noise model, dimension 1 x OrderC+1%					'z' plane:		c(1) = 1 imposed during the minimization%					's', 'w' plane:	all coefficients are free during minimization + sum(c) = 1 scaling%									in each iteration step.%									The returned normalised value is scaled such that c(end) = 1.%		d		=	new estimate coefficients denominator polynomial noise model, dimension 1 x OrderB+1%					'z' plane:		d(1) = 1 imposed during the minimization%					's', 'w' plane:	all coefficients are free during the minimization + sum(d) = 1 scaling%									in each iteration step.%									The returned normalised value scaled such that d(end) = 1.%		jh		=	new estimate coefficients initial conditions noise model, dimension number of 1 x OrderJ+1%		s2		=	estimate of the variance of the white noise source%		Cost	=	value of the cost function in the last iteration step%		smax	=	largest singular value of the Jacobian matrix%		smin	=	smallest singular value of the Jacobian matrix%		Cplant	=	covariance matrix of the (normalised) plant model parameters  (a coefficient fixed to 1 excluded);%					size: (sum(SelA) + sum(SelB) - 1) x (sum(SelA) + sum(SelB) - 1)%					NOW: VALID FOR OPEN LOOP ONLY%		Cnoise	=	covariance matrix of the (normalised) noise model parameters (c, d coefficients fixed to 1 excluded);%					size: (OrderC+OrderD) x (OrderC+OrderD)%					NOW: VALID FOR OPEN LOOP ONLY%		wscale	=	1x2 vector containing the frequency scaling: wscale(1) for the plant model, and wscale(2) for the noise model%%	input parameters%		Y					=	DFT spectrum output signal, dimensions: number of frequencies x 1%		U					=	DFT spectrum input signal, dimensions: number of frequencies x 1%		freq				=	vector of frequency values (Hz), dimension: number of frequencies x 1%		Ts					=	sampling time%		Gc					=	controller transfer function, zero or empty if unknown or not present%		SelA				=	if 1 then coeff. A-polynomial is unknown; if zero the coeff. is known equal to zero%		SelB				=	if 1 then coeff. B-polynomial is unknown; if zero the coeff. is known equal to zero%		OrderI				=	order initial condition polynomial plant model%		OrderC				=	order numerator polynomial noise model%		OrderD				=	order denominator polynomial noise model%		OrderJ				=	order initial condition polynomial noise model%		astart				=	starting value coefficients denominator polynomial plant model, dimension 1 x OrderA+1%		bstart				=	starting value coefficients numerator polynomial plant model, dimension 1 x OrderB+1%		igstart				=	starting value coefficients initial conditions plant model, dimension 1 x OrderI+1%		cstart				=	starting value coefficients numerator polynomial noise model, dimension 1 x OrderC+1%		dstart				=	starting value coefficients denominator polynomial noise model, dimension 1 x OrderB+1%		jhstart				=	starting value coefficients initial conditions noise model, dimension number of 1 x OrderJ+1%		Transient			=	if Transient = 1 then the initial conditions of the plant and/or noise are estimated%		ThePlane			=	1x2 cell array of char:%									's' => continuous-time;%									'w'	=> sqrt(s)-domain%									'z' => discrete-time;%									''	=> plane not defined%								Theplane{1}	=>	defines the plane of the plant model%								Theplane{2}	=>	defines the plane of the noise model%		TheModel			=	'BJ'		=>	Box-Jenkins%								'OE'		=>	output error (plant model only)%								'ARMA'		=>	autoregressive moving average (noise model only)%								'BJdet'		=>	Box-Jenkins + logdet(NoiseCovarianceMatrix) term in cost function%								'ARMAdet'	=>	ARMA + logdet(NoiseCovarianceMatrix) term in cost function%								'ARMAXdet'	=>	ARMA + logdet(NoiseCovarianceMatrix) term in cost function%		LevenbergMarquardt	=	if LevenbergMarquardt = 1 then Levenberg-Marquardt minimization scheme is used%		MaxItterations		=	maximum number of itterations of the minimization procedure%		TolParam			=	relative precision on parameter estimates%		TolCost				=	relative precision on cost function%		TraceOn				=	if TraceOn == 1 then output iterations (optional)%		kuc					=	kurtosis factor of the pdf of the circular complex distributed noise (optional); default Gaussian%								It is related to the real kurtosis factor by kuc = (ku+1)/2%								Examples:%											ku = 3							for Gaussian noise%											ku = 9/5						for uniform noise%											ku = 9							for exponential noise%											ku = (8-3/4*pi^2)/(2-pi/2)^2	for Rayleigh noise%% Rik Pintelon, 1998% version April, 2004, added: BJdet, ARMAdet, CT-noise models% version July, 2004, added: ARMAXdet%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% initialisation variables %%%%%%%%%%%%%%%%%%%%%%%%%%%%%if nargin < 25	TraceOn = 1;	% display iteration resultsendif nargin < 26;	kuc = 2;		% default value: Gaussian noiseendThePlane = lower(ThePlane);TheModel = upper(TheModel);if isempty(Gc)	Gc = zeros(size(freq));end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% domain of the plant model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the vector s represents z^-1, s, or sqrt(s) of the plant modelswitch ThePlane{1}	case {'s','w'}		if ThePlane{1} == 's'			s = sqrt(-1)*2*pi*freq;		elseif ThePlane{1} == 'w'			s = (sqrt(-1)*2*pi*freq).^(0.5);		end;		wscale(1) = median(abs(s));		s = s/wscale(1);		if ~(isempty(astart) | isempty(bstart))			[astart, bstart, igstart] = BJNormalise(astart, bstart, igstart, wscale(1), Transient);		end	case 'z'		s = exp(-sqrt(-1)*2*pi*freq*Ts);		wscale(1) = 1;	case ''		s = ones(size(freq));		wscale(1) = 1;	otherwise, disp('Invalid plant plane ...'), returnend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% domain of the noise model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the vector q represents z^-1, s, or sqrt(s) of the noise modelswitch ThePlane{2}	case {'s','w'}		if ThePlane{2} == 's'			q = sqrt(-1)*2*pi*freq;		elseif ThePlane{2} == 'w'			q = (sqrt(-1)*2*pi*freq).^(0.5);		end;		wscale(2) = median(abs(q));		q = q/wscale(2);		if ~(isempty(cstart) | isempty(dstart))			[cstart, dstart, jhstart] = BJNormalise(cstart, dstart, jhstart, wscale(2), Transient);		end	case 'z'		q = exp(-sqrt(-1)*2*pi*freq*Ts);		wscale(2) = 1;	case ''		q = [];		wscale(2) = [];	otherwise, disp('Invalid noise plane ...'), returnendswitch TheModel	case 'BJ',			LogDet = 0; TheModel = 'BJ';	case 'OE',			LogDet = 0; TheModel = 'OE';	case 'ARMA',		LogDet = 0; TheModel = 'ARMA';	case 'BJDET',		LogDet = 1; TheModel = 'BJ';	case 'ARMADET',		LogDet = 1; TheModel = 'ARMA';	case 'ARMAXDET',	LogDet = 1; TheModel = 'ARMAX';	otherwise, disp('Invalid model ...'), returnend% order plant modelif strcmp(TheModel,'BJ') | strcmp(TheModel,'OE') | strcmp(TheModel,'ARMAX')	OrderA = length(SelA)-1;	OrderB = length(SelB)-1;	if strcmp(TheModel,'ARMAX')		SelA = ones(1,OrderA+1);	% at this moment: no fixed denominator parameters in ARMAX; 	end	MaxOrder = max([OrderA,OrderB,OrderI]);	sMat = CalcBJOmegaMat(s, MaxOrder);elseif strcmp(TheModel,'ARMA')	SelA = [];	astart = [1];	SelB = [];	bstart = [0];	OrderI = -1;	igstart = [0];	sMat = [];end% order noise modelswitch TheModel	case 'OE',		OrderC = 0;		cstart = [1];		OrderD = 0; 		dstart = [1];		jhstart = [0];	case 'ARMAX',		OrderD = OrderA;		OrderJ = -1;				% transients in jh-term; jh is not distinguishable from ig		jhstart = [0];		dstart = astart;			% D = A in an ARMAX model and hence the starting values									% should be the sameend% if strcmp(TheModel,'OE')% 	OrderC = 0;% 	cstart = [1];% 	OrderD = 0; % 	dstart = [1];% 	jhstart = [0];% end% OrderJ = max(OrderC, OrderD) - 1;	% order initial cond. polynomial noise modelqMat = CalcBJOmegaMat(q, max([OrderC, OrderD, OrderJ]));% Check if DC and Nyquist belong to the frequency setif freq(1) == 0 DC = 1; else DC = 0; endif freq(end) == 1/(2*Ts) Nyquist = 1; else Nyquist = 0; end% generate starting values for the plant model if necessaryif (strcmp(TheModel,'OE') | strcmp(TheModel,'BJ') | strcmp(TheModel,'ARMAX')) & (isempty(astart) | isempty(bstart))	% least square estimate of the model AY = B U + Ig	[astart, bstart, igstart, Cost, smax, smin] = PlantLeastSquares(Y, U, s, sMat, SelA, SelB, OrderI, Transient, DC, Nyquist);	if strcmp(TheModel,'ARMAX')		dstart = astart;	end	if TraceOn == 1		fprintf('condition number: %e \n',smax/smin);		Cost	endend% generate starting values for the noise model if necessaryif (strcmp(TheModel,'ARMA') | strcmp(TheModel,'BJ') | strcmp(TheModel,'ARMAX'))	if isempty(cstart)		cstart = [1 zeros(1, OrderC)];			end	if isempty(jhstart)		jhstart = zeros(1, OrderJ+1);	end	if isempty(dstart)		if OrderD ~= 0        			[a, b, ig, dummy, dstart, jhstart, Cost, smax, smin] = BJNewtonGaussStep(Y, U, s, q, sMat, qMat, Gc, astart, bstart, igstart, cstart(1), [1 zeros(1,OrderD)], jhstart, ...																					SelA, SelB, OrderI, 0, OrderD, OrderJ, 0, Transient, ThePlane{2}, TheModel, LogDet, DC, Nyquist,TraceOn);		else			dstart = [1];		end	else		% stabilise the starting values of the noise polynomials		% stabilise C polynomial otherwise: the cost function without logdet term can be made arbitrarily small		cstart = BJStabilizeRoots(cstart, ThePlane{2}, TraceOn);		% stabilise D polynomial except for ARMAX model		if ~strcmp(TheModel,'ARMAX')			dstart = BJStabilizeRoots(dstart, ThePlane{2}, TraceOn);		end	endend% maximum likelihood estimate of the modelCost = BJCost(Y, U, astart, bstart, igstart, cstart, dstart, jhstart, s, q, Gc, Transient, LogDet, DC, Nyquist); %calculate cost of the least square stepMaxRelErr = NaN;RelVarCost = NaN;DeltaCost = NaN;Olda = astart;Oldb = bstart;Oldig = igstart;Oldc = cstart;Oldd = dstart;Oldjh = jhstart;OldCost = Cost;OldMaxRelErr = MaxRelErr;OldRelVarCost = RelVarCost;OldDeltaCost = DeltaCost;if TraceOn == 1	fprintf('maximum relative variation parameters: %e \n',MaxRelErr);	fprintf('costfunction (Æcost): %e (%e ) \n',Cost,DeltaCost);end% starting values onlyif MaxItterations < 1	a = Olda;	b = Oldb;	ig = Oldig;	c = Oldc;	d = Oldd;	jh = Oldjh;end% Iterate to find also coefficients numerator noise modelLambda = 0; StartLM = 1; % initialization for Levenberg-Marquardt minimization schemeii = 1;while ii <= MaxItterations ii = ii + 1;	[a, b, ig, c, d, jh, Cost, smax, smin] = BJNewtonGaussStep(Y, U, s, q, sMat, qMat, Gc, Olda, Oldb, Oldig, Oldc, Oldd, Oldjh, SelA, SelB, OrderI, OrderC, OrderD, OrderJ,...																Lambda, Transient, ThePlane{2}, TheModel, LogDet, DC, Nyquist,TraceOn);		if ~((LevenbergMarquardt == 1) & (Cost > OldCost))		if strcmp(TheModel,'BJ') | strcmp(TheModel,'OE') | strcmp(TheModel,'ARMAX')			MaxRelErr = max([abs((a(SelA==1)-Olda(SelA==1))./a(SelA==1)), abs((b(SelB==1)-Oldb(SelB==1))./b(SelB==1))]);			if Transient == 1				MaxRelErr = max([MaxRelErr, abs((ig-Oldig)./ig)]);			end;		else			MaxRelErr = [];		end		if strcmp(TheModel,'ARMA') | strcmp(TheModel,'ARMAX') | strcmp(TheModel,'BJ')			MaxRelErr = max([MaxRelErr, abs((c-Oldc)./c), abs((d-Oldd)./d)]);			if (Transient == 1) & ~strcmp(TheModel,'ARMAX')				MaxRelErr = max([MaxRelErr, abs((jh-Oldjh)./jh)]);			end;		end		DeltaCost = Cost - OldCost;			RelVarCost = abs(DeltaCost)/Cost;		Olda = a;		Oldb = b;		Oldig = ig;		Oldc = c;		Oldd = d;		Oldjh = jh;		OldCost = Cost;		OldMaxRelErr = MaxRelErr;		OldRelVarCost = RelVarCost;		OldDeltaCost = DeltaCost;	end;		if (LevenbergMarquardt == 1)		if (Cost > OldCost)			if StartLM == 1				Lambda = smax^2;				StartLM = 0;		% initialization Lambda parameter is done			else				Lambda = 10*Lambda;			end;			a = Olda;			b = Oldb;			ig = Oldig;			c = Oldc;			d = Oldd;			jh = Oldjh;			Cost = OldCost;			MaxRelErr = OldMaxRelErr;			RelVarCost = OldRelVarCost;			DeltaCost = OldDeltaCost;		else			Lambda = 0.4*Lambda;		end;	end;	if TraceOn == 1		home		disp(['iteration # ',int2str(ii)]);		disp(['condition number:',num2str(smax/smin)]);		disp(['maximum relative variation parameters: ',num2str(MaxRelErr)]);	 	disp(['costfunction (DeltaCost): ',num2str(Cost),' (',num2str(DeltaCost),')']);		if LevenbergMarquardt == 1			disp(['lambda faktor Levenberg-Marquardt iteration scheme: ',num2str(Lambda)]);		end;	end		if (MaxRelErr < TolParam) | (RelVarCost < TolCost)		ii = MaxItterations+1;	end;end;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% return scaled  normalised a, b, ig, c, d, and jh coefficients %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% scaling such that a is monic ('z': a(1) = 1; 's', 'w': a(end) = 1)switch ThePlane{1}	case {'s','w'}, b = b/a(end); ig = ig/a(end); a = a/a(end);	case 'z', b = b/a(1); ig = ig/a(1); a = a/a(1);end% scaling such that c and d are monic  (for example, 'z': c(1) = 1; 's', 'w': c(end) = 1)switch ThePlane{2}	case {'s','w'}, c = c/c(end); jh = jh/d(end); d = d/d(end);	case 'z',		% in 'z' c(1) = d(1) = 1		if strcmp(TheModel,'ARMAX')			d = a;		endend% estimate the noise variance => cost function without logdet-term% for continuous-time noise models the highest power of s or sqrt(s)% is set to one.CostNoLogdet = BJCost(Y, U, a, b, ig, c, d, jh, s, q, Gc, Transient, 0, DC, Nyquist);switch TheModel	case 'ARMA', dummy = length(s)-(OrderC+OrderD+OrderJ+1)/2;	case 'OE', dummy = length(s)-(sum(SelA)+sum(SelB)+OrderI)/2;	case 'BJ', dummy = length(s)-(sum(SelA)+sum(SelB)+OrderI+OrderC+OrderD+OrderJ+1)/2;	case 'ARMAX', dummy = length(s)-(sum(SelA)+sum(SelB)+OrderI+OrderC)/2;end% DC and Nyquist only count for 1/2 in the cost functionif DC == 1 dummy = dummy - 1/2; endif Nyquist == 1 dummy = dummy - 1/2; ends2 = CostNoLogdet/dummy;% covariance matrix of the scaled normalised noise model parameters% at this moment: VALID FOR OPEN LOOP ONLYif strcmp(TheModel,'BJ') | strcmp(TheModel,'ARMA') | strcmp(TheModel,'ARMAX')	Cnoise = Cov_NoiseParam(c, d, q, ThePlane{2}, LogDet, kuc, DC, Nyquist);elseif strcmp(TheModel,'OE')	Cnoise = [];end% covariance matrix of the scaled normalised plant model parameters% at this moment: VALID FOR OPEN LOOP ONLYif strcmp(TheModel,'BJ') | strcmp(TheModel,'OE') | strcmp(TheModel,'ARMAX')	% note:	the logdet term does not appear in the uncertainty of	% 		plant model parameters	Cplant = Cov_PlantParam(U, s, q, ThePlane{1}, a, b, c, d, s2, SelA, SelB, DC, Nyquist);elseif strcmp(TheModel,'ARMA')	Cplant = [];end% uncertainty for ARMAX models in open loopif strcmp(TheModel,'ARMAX')	nn = sum(SelA) + sum(SelB) - 1 + OrderC;	nn2 = sum(SelA) - 1 + OrderC;	dummy = zeros(nn,nn);	dummy(1:nn2,1:nn2) = inv(Cnoise);	dummy(OrderC+1:end,OrderC+1:end) = dummy(OrderC+1:end,OrderC+1:end) + inv(Cplant);	dummy = inv(dummy);	Cnoise = dummy(1:nn2,1:nn2);	Cplant = dummy(OrderC+1:end,OrderC+1:end);end% denormalisation plant model parametersswitch ThePlane{1}	case {'s', 'w'}, [a, b, ig] = BJDeNormalise(a, b, ig, wscale(1), Transient);	otherwiseend% if (ThePlane{1} == 's') | (ThePlane{1} == 'w')% 	[a, b, ig] = BJDeNormalise(a, b, ig, wscale(1), Transient);% end% denormalisation noise model parametersswitch ThePlane{2}	case {'s', 'w'}, [c, d, jh] = BJDeNormalise(c, d, jh, wscale(2), Transient);	otherwiseend% if (ThePlane{2} == 's') | (ThePlane{2} == 'w')% 	[c, d, jh] = BJDeNormalise(c, d, jh, wscale(2), Transient);% end