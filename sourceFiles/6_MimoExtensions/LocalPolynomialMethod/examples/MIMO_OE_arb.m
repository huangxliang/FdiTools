%% Multiple-input, multiple-output (MIMO) system operating in open loop and excited by random inputs% Known input, noisy output case (generalized output error method) %% Rik Pintelon, 23 September 2011%clear allclose all%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition discrete-time plant and noise model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%load MIMO_PlantNoiseModelny = size(B, 1);        % number of outputsnu = size(B, 2);        % number of inputsN = 5000;               % number of time domain samplesfs = 5.5;               % sampling frequency in Hzfstart = 0.1;           % start frequency in Hz of the frequency band of interestfstop = 2;              % stop frequyency in Hz of the frequency band of interest%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Simulation known input - noisy output data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Contribution excitation to output %u0 = randn(nu, N);y0 = zeros(ny, N);for jj=1:ny    for ii=1:nu        y0(jj,:) = y0(jj,:) + filter(squeeze(B(jj,ii,:)), A, u0(ii,:));    end % iiend % jj% Contribution disturbing noise to output %Te = fliplr(hankel(ones(ny,1)));e = randn(ny, N);                       % driving white noise sourcese = Te*e;                               % linear combination of the driving white noise sourcesv = zeros(ny, N);for jj=1:ny    for ii=1:ny        v(jj,:) = v(jj,:) + filter(squeeze(C(jj,ii,:)), D, e(ii,:));    end % iiend % jj% noisy outputy = y0 + v;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calling the ArbLocalPolyAnal function %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% data data.u = u0;                            % row index is the input number; the column index the time instant (in samples) data.y = y;                             % row index is the output number; the column index the time instant (in samples) data.Ts = 1/fs;                         % sampling period% methodmethod.dof = 10;                        % degrees of freedom of the variance estimatemethod.order = 2;                       % order local polynomial approximationmethod.startfreq = fstart;              % defines the start frequency of the analysis method.stopfreq = fstop;                % defines the stop frequency of the analysis% local polynomial estimate FRF and its variance[CZ, Z, freq, G, CvecG, dof, CL] = ArbLocalPolyAnal(data, method);% estimated output noise power spectrumS = CZ.n(1:ny,1:ny,:); % estimated variances FRM entries: keep the diagonal elements CvecG onlyF = length(freq);varG = zeros(ny, nu, F);for kk=1:F    varG(:, :, kk) = reshape(diag(CvecG(:, :, kk)), [ny, nu]);end % kk%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Comparison estimates and true values %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%q = exp(-sqrt(-1)*2*pi*freq/fs);        % z^(-1) as a function of the frequency % true FRMG0 = zeros(ny, nu, F);AA = polyval(fliplr(A), q.');           % denominator plant transfer functionfor ii = 1:ny	for jj = 1:nu		G0(ii, jj, :) = polyval(fliplr(squeeze(B(ii, jj, :)).'), q.')./AA;	end % jjend % ii% true noise transfer functionH0 = zeros(ny, ny, F);DD = polyval(fliplr(D), q.');           % denominator plant transfer functionfor ii = 1:ny	for jj = 1:ny		H0(ii, jj, :) = polyval(fliplr(squeeze(C(ii, jj, :)).'), q.')./DD;	end % jjend % ii% true noise power spectrumS0 = zeros(ny, ny, F);CovE = Te*Te.';                         % covariance matrix of the driving white noise sources for kk = 1:F	S0(:,:,kk) = H0(:,:,kk) * CovE * H0(:,:,kk)';	% remove small imaginary parts on the main diagonal	S0(:,:,kk) = S0(:,:,kk) - diag(sqrt(-1)*imag(diag(S0(:,:,kk))));end % frequencies kk% comparison estimated and true FRMfigure(1)mm = 0;for jj = 1:ny	for ii = 1:nu		mm = mm+1;		subplot(ny, nu, mm)		plot(freq, db(squeeze(G(jj,ii,:))), 'r', freq, db(squeeze(G0(jj,ii,:))), 'k', ...             freq, db(squeeze(G(jj,ii,:)-G0(jj,ii,:))), 'k--', freq, db(squeeze(varG(jj,ii,:)))/2, 'r--');	end % iiend % jjsubplot(ny,nu,1);title('G_0: black; G: red; |G-G_0|: black --; var(G): red --');zoom on; shg% comparison estimated and true noise power spectrumfigure(2)mm = 0;for jj = 1:ny	for ii = 1:ny		mm = mm+1;		subplot(ny, ny, mm)		plot(freq, db(squeeze(S(jj, ii, :)))/2, 'r', freq, db(squeeze(S0(jj,ii,:)))/2, 'k');	end % iiend % jjsubplot(ny,ny,2);title('true noise power spectrum: black; estim. noise power spectrum: red');zoom on; shg