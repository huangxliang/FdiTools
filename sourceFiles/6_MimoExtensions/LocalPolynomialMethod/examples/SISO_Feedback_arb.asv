%% Single-input, single-output (SISO) system operating in unity feedback% excited by an random input% Known input, noisy output case (generalized output error) %% Rik Pintelon, 22 September 2011%clear allclose all%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition discrete-time plant and noise models %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% definition discrete-time plant modelB = [0 1 0.5]; A = [1 -1.5 0.7];% definition discrete-time noise modelC = [1 -1 0.9];D = [1 -0.2 0.85];N = 1000*4;             % number of time domain points fs = 1;                 % sampling frequency%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Simulation known input - noisy output data %% of the system operating in unity feedback  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% reference signalr = rand(1, N);% deterministic part input and outputu0 = filter(A, A+B, r);y0 = filter(B, A+B, r);% noisy part input and outpute = randn(1, N);v = filter(conv(C, A), conv(D, A+B), e);% known input, noisy outputu = u0 - v;y = y0 + v;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calling the ArbLocalPolyAnal function %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% data data.u = u;                             % row index is the input number; the column index the time instant (in samples) data.y = y;                             % row index is the output number; the column index the time instant (in samples) data.r = r;                             % the reference signal is needed to obtain consistent nonparametric FRF estimates in feedbackdata.Ts = 1/fs;                         % sampling period% methodmethod.dof = 6;                         % degrees of freedom of the variance estimatemethod.order = 2;                       % order local polynomial approximation% local polynomial estimate FRF and its variance[CZ, Z, freq, G, CvecG, dof, CL] = ArbLocalPolyAnal(data, method);G = squeeze(G);                         % FRF estimatevarG = squeeze(CvecG);                  % variance FRF estimatevarV = squeeze(CZ.n(1,1,:));            % estimate output noise variance%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Comparison estimates and true values %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% true FRFq = exp(-sqrt(-1)*2*pi*freq/fs);        % z^(-1) as a function of the frequency G0 = polyval(fliplr(B), q) ./ polyval(fliplr(A), q);G0 = G0.';% true noise modelH0 = polyval(fliplr(C), q) ./ polyval(fliplr(D), q);% true input variancevarVu_0 = abs((H0./(1+G0)).^2).';                     % true output noise variance	%%%%%%%%%%%%%%%% frequencies %%%%%%%%%%%%%%%%TheIndex = [1:1:N/2+1];							% from DC to NyquistTheIndexAll = [1:1:N+1].';						% from DC to Nyquist on 2*N pointsTheIndex = [ceil(0.05*N):1:ceil(0.3*N)];		% select a part of the band [DC, Nyquist]NN = length(TheIndex);freq = ((TheIndex-1)/N/Ts).';freqAll = ((TheIndexAll-1)/(2*N)/Ts).';q = exp(-sqrt(-1)*2*pi*freq*Ts); qAll = exp(-sqrt(-1)*2*pi*freqAll*Ts);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% true plant and noise models %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G0All = (polyval(fliplr(b0),sAll)./polyval(fliplr(a0),sAll)).';H0All = (polyval(fliplr(c0),qAll)./polyval(fliplr(d0),qAll)).';Gc0All = (polyval(fliplr(bc0),sAll)./polyval(fliplr(ac0),sAll)).';% true noise and plant modelsG0 = (polyval(fliplr(b0),s)./polyval(fliplr(a0),s)).';H0 = (polyval(fliplr(c0),q)./polyval(fliplr(d0),q)).';Gc0 = (polyval(fliplr(bc0),s)./polyval(fliplr(ac0),s)).';if ClosedLoop == 1	if TrueController == 1		Gc = Gc0(:);	else		Gc = [];	endelse	Gc = Gc0(:);end%%%%%%%%%%%%%%%%%%%% simulation loop %%%%%%%%%%%%%%%%%%%%% addition of numerator and denominator polynomial plantif OrderA >= OrderB	dd0 = a0 + [b0, zeros(1,OrderA-OrderB)];elseif OrderA+OrderAc < OrderB+OrderBc	dd0 = b0 + [a0, zeros(1,OrderB-OrderA)];endfor ii = 1:NumberOfSimulations	home	ii	% generate output signal y(t) = B/A u(t) + C/D e(t)		% driving white noise source	switch lower(NoisePdf)		case 'gaussian', e = sigma*randn(nn*N,1);		case 'uniform', e = sigma*(rand(nn*N,1)-0.5)*sqrt(12);		case 'exponential', [mu,va] = expstat(1); e = sigma*(exprnd(1,nn*N,1)-mu)/sqrt(va);		case 'rayleigh', [mu,va] = raylstat(1); e = sigma*(raylrnd(1,nn*N,1)-mu)/sqrt(va);	end		if ClosedLoop == 1		% closed loop case; any case: DT/DT, CT/CT, CT/DT, DT/CT		% if mixed plant/noise plane => Gc0 = 1		        % take each time the same reference signal        S = randn('state');        randn('state',0);		r = randn(np*N,1);													% reference signal        randn('state', S);                                                    % restore the original state		if (TheNoisePlane == 'z')			% calculation in time domain			v = filter(conv(c0,a0),conv(d0,dd0),e);						% contribution process noise to output			w = filter(bc0,ac0,v);											% contribution process noise to input		else			% calculation in frequency domain with transient simulation			E = fft(e);														% driving white noise source			E = E(TheIndexAll);			V = H0All./(1+G0All.*Gc0All).*E;								% contribution process noise to output			W = Gc0All.*V;													% contribution process noise to input			v = 2*real(ifft([0;V(2:end-1);zeros(N,1)]));			w = 2*real(ifft([0;W(2:end-1);zeros(N,1)]));			v = v(1:N);			w = w(1:N);		end				if (ThePlantPlane == 'z')			% calculation in time domain			u = filter(aa0,dd0,r);											% noiseless input plant			y = filter(conv(b0,ac0),dd0,r);									% noiseless output plant		else			% calculation in frequency domain with transient simulation			R = fft(r);														% reference signal			R = R(TheIndexAll);			U = 1./(1+G0All.*Gc0All).*R;									% noiseless input plant			u = 2*real(ifft([0;U(2:end-1);zeros(N,1)]));			Y = G0All./(1+G0All.*Gc0All).*R;								% noiseless output plant			y = 2*real(ifft([0;Y(2:end-1);zeros(N,1)]));			u = u(1:N);			y = y(1:N);		end			u = u - w;		y = y + v;			else		% open loop case; any case: DT/DT, CT/CT, CT/DT, DT/CT				u = randn(np*N,1);									% input plant		switch ThePlantPlane			case {'s','w'}				% calculation in frequency domain with transient simulation				U = fft(u);				Y = G0All.*U(TheIndexAll);				y = 2*real(ifft([0;Y(2:end-1);zeros(N,1)]));				u = u(1:N);				y = y(1:N);			case 'z'				% calculation in time domain				y = filter(b0,a0,u);						% noisy output plant		end			switch TheNoisePlane			case {'s','w'}				% calculation in frequency domain with transient simulation				E = fft(e);				V = H0All.*E(TheIndexAll);				v = 2*real(ifft([0;V(2:end-1);zeros(N,1)]));				v = v(1:N);			case 'z'				% calculation in time domain				v = filter(c0,d0,e);						% noisy output plant		end			y = y + v;	end			U1 = fft(u);	U = U1(TheIndex)/sqrt(N);	Y1 = fft(y);	Y = Y1(TheIndex)/sqrt(N);% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 	% starting values plant model: estimate a, b, ig %% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 	Transient = 1;	MaxItterations = 100;	LevenbergMarquardt = 1;	TolParam = 1e-10;	TolCost = 1e-12;% 	% 	[as, bs, igs, varY] = StartBoxJenkins(Y, U, freq, Ts, SelA, SelBstart, OrderI, ThePlane{1}, ClosedLoop, LevenbergMarquardt,...% 											MaxItterations, TolParam, TolCost, TraceOn);% % 	% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%																		% 	% starting values noise model: estimate c, d %	% 	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 	% 	Gs = polyval(fliplr(bs),s)./polyval(fliplr(as),s);% 	TGs = polyval(fliplr(igs),s)./polyval(fliplr(as),s);% 	V = Y - Gs.*U - TGs;% 	% 	css0 = [];% 	switch TheModelStructure% 		case 'BJ', dss = [];% 		case 'ARMAX', dss = as;% 	end% 	% 	[a1, b1, ig, cs, ds, jhs, s2s, CostNOdet] = BoxJenkins(V(:), zeros(size(V)), freq, Ts, Gc, SelA, SelB, 0, OrderC1, OrderD1, OrderJ1, [], [], [], css0, dss, zeros(1, OrderJ1+1),...% 																			Transient, ThePlane, 'ARMAdet', LevenbergMarquardt, MaxItterations, TolParam, TolCost,TraceOn);% % 	Hs = polyval(fliplr(cs),q)./polyval(fliplr(ds),q);% 	THs = polyval(fliplr(jhs),q)./polyval(fliplr(ds),q);% 	figure(1)% 	subplot(211)% 	plot(freq,db((Y-TGs)./U),freq, db(Gs),'k');% 	title('Starting values plant model')% 	subplot(212)% 	plot(freq, db(V-THs),freq,db(Hs*sqrt(s2s)),'k')% 	title('Starting values noise model: ARMA noise model with logdet term')% 	zoom on;% 																						%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	% full Box-Jenkins with logdet term %	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 	bs(SelB == 0) = 0;% 	bs = bs(ones(size(SelB)) == 1);	switch TheNoisePlane		case 'z', OrderJJ = OrderJ;		case {'s','w'}, OrderJJ = OrderD-1;	end% 	Olda = as;% 	Oldb = bs;% 	Oldig = igs;% 	Oldc = cs(1:OrderC+1);% 	Oldd = ds(1:OrderD+1);% 	Oldjh = jhs(1:OrderJJ+1);	switch TheModelStructure		case 'BJ', TheModel = 'BJdet';% 		case 'ARMAX', TheModel = 'ARMAXdet'; ds = as;		case 'ARMAX', TheModel = 'ARMAXdet';	end	switch EstimController				case 1						%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%			% starting values controller model: estimate ac, bc, igc %			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%					[Oldac, Oldbc, Oldigc] = BoxJenkins(U, -Y, freq, Ts, Gs, SelAc, SelBc, OrderIc, 0, 0, -1, [], [], [], [1], [1], [], ...												Transient, ThePlane, 'BJdet', LevenbergMarquardt, MaxItterations, TolParam, TolCost,TraceOn);			Gc = polyval(fliplr(Oldbc),s)./polyval(fliplr(Oldac),s);										jj = 0;			MaxRelErr = inf;			MaxItterations1=2;			while jj <= MaxItterations								jj = jj+1;				home, [ii,jj,MaxRelErr]							% estimate plant and noise model					[a, b, ig, c, d, jh, s2, CostBJld, smax, smin, Cp, Cn, wscale] = BoxJenkins(Y, U, freq, Ts, Gc, SelA, SelB, OrderI, OrderC, OrderD, OrderJJ, Olda, Oldb, Oldig, Oldc, Oldd, Oldjh,...				 																				Transient, ThePlane, 'BJdet', LevenbergMarquardt, MaxItterations1, TolParam, TolCost,0);				G = polyval(fliplr(b),s)./polyval(fliplr(a),s);								% estimate controller model					[ac, bc, igc, cc, dc, jhc, s2c, CostBJc, smaxc, sminc, Cc, Cnc, wscalec] = BoxJenkins(U, -Y, freq, Ts, G, SelAc, SelBc, OrderIc, 0, 0, -1, Oldac, Oldbc, Oldigc, [1], [1], [],...				 																						Transient, ThePlane, 'BJdet', LevenbergMarquardt, MaxItterations1, TolParam, TolCost,0);				Gc = polyval(fliplr(bc),s)./polyval(fliplr(ac),s);								MaxRelErr = max([abs((a(SelA==1)-Olda(SelA==1))./a(SelA==1)), abs((b(SelB==1)-Oldb(SelB==1))./b(SelB==1))]);				MaxRelErr = max([MaxRelErr, abs((c-Oldc)./c), abs((d-Oldd)./d)]);				MaxRelErr = max([MaxRelErr, abs((ac(SelAc==1)-Oldac(SelAc==1))./ac(SelAc==1)), abs((bc(SelBc==1)-Oldbc(SelBc==1))./bc(SelBc==1))]);								Olda = a;				Oldb = b;				Oldig = ig;				Oldc = c;				Oldd = d;				Oldjh = jh;				Oldac = ac;				Oldbc = bc;				Oldigc = igc;								if (MaxRelErr <= TolParam)					jj = MaxItterations+1;				end;			end					ald(ii,:) = a;			bld(ii,:) = b;			cld(ii,:) = c;			dld(ii,:) = d;			acld(ii,:) = ac;			bcld(ii,:) = bc;			s2ld(ii) = s2;			Gcld(ii,:) = (polyval(fliplr(bcld(ii,:)),s)./polyval(fliplr(acld(ii,:)),s)).';					case 0		            Olda = a0;            Oldb = b0;            Oldig = zeros(1,OrderI+1);            Oldc = c0;            Oldd = d0;            Oldjh = zeros(1,OrderJJ+1);			[ald(ii,:), bld(ii,:), igld, cld(ii,:), dld(ii,:), jhld, s2ld(ii), CostBJld, smax, smin, Cp, Cn, wscale] = BoxJenkins(Y, U, freq, Ts, Gc, SelA, SelB, OrderI, OrderC, OrderD, OrderJJ, Olda, Oldb, Oldig, ...																														 		Oldc, Oldd, Oldjh, Transient, ThePlane,...																														 		TheModel, LevenbergMarquardt, MaxItterations*4, TolParam, TolCost,TraceOn);	end		Hld(ii,:) = (polyval(fliplr(cld(ii,:)),q)./polyval(fliplr(dld(ii,:)),q)).';	absHld(ii,:) = sqrt(s2ld(ii))*abs(polyval(fliplr(cld(ii,:)),q)./polyval(fliplr(dld(ii,:)),q)).';	Gld(ii,:) = (polyval(fliplr(bld(ii,:)),s)./polyval(fliplr(ald(ii,:)),s)).';	Cplant = Cplant + Cp;	Cnoise = Cnoise + Cn;		%%%%%%%%%%%%%%%%%%%%%%%%%%%	% time domain Box-Jenkins %	%%%%%%%%%%%%%%%%%%%%%%%%%%%		if (ThePlantPlane == 'z') & (TheNoisePlane == 'z')		nb = OrderB;		nc = OrderC;		nd = OrderD;		nf = OrderA;		theta = bj([y(:),u(:)],[nb nc nd nf 1],100,1e-10,0);		[ft,bt(ii,:),ct(ii,:),dt(ii,:),at(ii,:)] = th2poly(theta);		Ht(ii,:) = (polyval(fliplr(ct(ii,:)),q)./polyval(fliplr(dt(ii,:)),q)).';		Gt(ii,:) = (polyval(fliplr(bt(ii,:)),q)./polyval(fliplr(at(ii,:)),q)).';	endend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Cramer-Rao lower bound estimated plant and noise models %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[Sel, Theta0, ModelVar, IterVar] = DefaultValues(OrderA, OrderB, OrderC, OrderD, 1, 1, ThePlantPlane, TheNoisePlane, TheModelStructure);Sel.A = SelA;Sel.B(1,1,:) = SelB;ModelVar.nig = OrderI;Sel.Ig = zeros(1, OrderI+1);Theta0.Ig = zeros(1, OrderI+1);ModelVar.nih = OrderJJ;Sel.Ih = zeros(1, OrderJJ+1);Theta0.Ih = zeros(1, OrderJJ+1);Theta0.A = a0;Theta0.B = zeros(1, 1, OrderB+1);Theta0.B(1,1,:) = b0;Theta0.C = zeros(1, 1, OrderC+1);Theta0.C(1,1,:) = c0;Theta0.D = d0;data.Ts = Ts;data.freq = freq;data.Y = Y.';data.U = U.';data.Gc = ones(1, 1, length(freq));% [CRbound, Thetan, Thewscale, TheCond] = MIMO_CR_bound(data, Sel, Theta0, sigma^2, ModelVar);Theta0.CovE = sigma^2;[CRbound, Theta0, CovThetan, Thetan, Seln, wscale, TheCond] = MIMO_CR_bound(data, Sel, Theta0, ModelVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% process, plot and print the simulation results %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Cnoise = Cnoise/NumberOfSimulations;Cplant = Cplant/NumberOfSimulations;if ThePlantPlane == 's'	[an, bn] = BJNormalise(ald, bld, [], wscale.Plant, 0);	SelAA = SelA;	SelAA(end) = 0;	teta = [an(:,SelAA == 1),bn(:,SelB == 1)];	if EstimController == 1		[acn, bcn] = BJNormalise(acld, bcld, [], wscale.Plant, 0);		SelAAc = SelAc;		SelAAc(end) = 0;		tetac = [acn(:,SelAAc == 1),bcn(:,SelBc == 1)];	endelse	SelAA = SelA;	SelAA(1) = 0;	teta = [ald(:,SelAA == 1),bld(:,SelB == 1)];	if EstimController == 1		SelAAc = SelAc;		SelAAc(1) = 0;		tetac = [acld(:,SelAAc == 1),bcld(:,SelBc == 1)];	endendTheSign = sign(teta(:,1));teta = teta./repmat(TheSign,1,sum(SelA)+sum(SelB)-1);Covab = cov(teta);if EstimController == 1	TheSign = sign(tetac(:,1));	tetac = tetac./repmat(TheSign,1,sum(SelAc)+sum(SelBc)-1);	Covacbc = cov(tetac);endif TheNoisePlane == 's'	[cn, dn] = BJNormalise(cld, dld, [], wscale.Noise, 0);	teta = [cn(:,1:end-1),dn(:,1:end-1)];else	teta = [cld(:,2:end),dld(:,2:end)];endCovcd = cov(teta);% mean values plant model parameters% scale plant model parameters before averagingif ThePlantPlane == 'z'	bld = bld./repmat(ald(:,1),1,OrderB+1);	ald = ald./repmat(ald(:,1),1,OrderA+1);else	bld = bld./repmat(ald(:,end),1,OrderB+1);	ald = ald./repmat(ald(:,end),1,OrderA+1);endaldm = mean(ald,1);bldm = mean(bld,1);% mean values noise model parametersif TheNoisePlane == 's'	cld = cld./repmat(cld(:,end),1,OrderC+1);	dld = dld./repmat(dld(:,end),1,OrderD+1);endcldm = mean(cld,1);dldm = mean(dld,1);% mean plant transfer functionGldm = mean(Gld,1);% mean noise transfer functionHldm = mean(Hld,1);absHldm = mean(absHld,1);if EstimController == 1	% mean values controller model parameters	% scale controller model parameters before averaging	if ThePlantPlane == 'z'		bcld = bcld./repmat(acld(:,1),1,OrderBc+1);		acld = acld./repmat(acld(:,1),1,OrderAc+1);	else		bcld = bcld./repmat(acld(:,end),1,OrderBc+1);		acld = acld./repmat(acld(:,end),1,OrderAc+1);	end		acldm = mean(acld,1);	bcldm = mean(bcld,1);		% mean plant transfer function	Gcldm = mean(Gcld,1);	endif NumberOfSimulations > 1		% std plant model parameters	stdaldm = std(ald,[],1)/sqrt(NumberOfSimulations);	stdbldm = std(bld,[],1)/sqrt(NumberOfSimulations);		% std noise model parameters	stdcldm = std(cld,[],1)/sqrt(NumberOfSimulations);	stddldm = std(dld,[],1)/sqrt(NumberOfSimulations);		% std plant transfer function	stdGldm = std(Gld,[],1)/sqrt(NumberOfSimulations);		% std noise transfer function	stdHldm = std(Hld,[],1)/sqrt(NumberOfSimulations);    stdabsHldm = std(absHld,[],1)/sqrt(NumberOfSimulations);		if EstimController == 1				% std controller model parameters		stdacldm = std(acld,[],1)/sqrt(NumberOfSimulations);		stdbcldm = std(bcld,[],1)/sqrt(NumberOfSimulations);				% std controller transfer function		stdGcldm = std(Gcld,[],1)/sqrt(NumberOfSimulations);			end	else		stdaldm = zeros(size(aldm));	stdbldm = zeros(size(bldm));	Covab = [];		% std noise model parameters	stdcldm = zeros(size(cldm));	stddldm = zeros(size(dldm));	Covcd = [];		% std plant transfer function	stdGldm = zeros(size(Gldm));	% std noise transfer function	stdHldm = zeros(size(Hldm));		if EstimController == 1				% std controller model parameters		stdacldm = zeros(size(acldm));		stdbcldm = zeros(size(bcldm));				% std controller transfer function		stdGcldm = zeros(size(Gcldm));			end	endif (ThePlantPlane == 'z') & (TheNoisePlane == 'z')		bt = bt./repmat(at(:,1),1,OrderB+1);	at = at./repmat(at(:,1),1,OrderA+1);	atm = mean(at,1);	btm = mean(bt,1);	ctm = mean(ct,1);	dtm = mean(dt,1);	Gtm = mean(Gt,1);	Htm = mean(Ht,1);	if NumberOfSimulations > 1				% std plant model parameters		stdbtm = std(bt,[],1)/sqrt(NumberOfSimulations);		stdatm = std(at,[],1)/sqrt(NumberOfSimulations);		% std noise model parameters		stdctm = std(ct,[],1)/sqrt(NumberOfSimulations);		stddtm = std(dt,[],1)/sqrt(NumberOfSimulations);		% std plant transfer function		stdGtm = std(Gt,[],1)/sqrt(NumberOfSimulations);			% std noise transfer function		stdHtm = std(Ht,[],1)/sqrt(NumberOfSimulations);			else				stdatm = zeros(size(atm));		stdbtm = zeros(size(btm));			% std noise model parameters		stdctm = zeros(size(ctm));		stddtm = zeros(size(dtm));		% std plant transfer function		stdGtm = zeros(size(Gtm));			% std noise transfer function		stdHtm = zeros(size(Htm));			endendif (ThePlantPlane == 'z') & (TheNoisePlane == 'z')	disp('plant model')	disp('    true value          BJdet                time')	[a0.'/a0(1),aldm.',stdaldm.',atm.',stdatm.']	[b0.'/a0(1),bldm.',stdbldm.',btm.',stdbtm.']		disp('noise model')	disp('    true value           BJdet               time')	[c0.',cldm.',stdcldm.',ctm.',stdctm.']	[d0.',dldm.',stddldm.',dtm.',stddtm.']	if EstimController == 1				disp('controller model')		disp('    true value          BJdet')		[ac0.'/ac0(1),acldm.',stdacldm.']		[bc0.'/ac0(1),bcldm.',stdbcldm.']			end		disp('estimated noise standard deviation');	sldm = sqrt(mean(s2ld));	[sigma, sldm]			disp('cov matrix plant model parameters')	Cplant	Covab	disp('cov matrix noise model parameters')	Cnoise	Covcd		if NumberOfSimulations > 1		disp('ratio estimated/actual covariance matrix plant model parameters')		Cplant./Covab		disp('ratio estimated/actual covariance matrix noise model parameters')		Cnoise./Covcd		disp('uncertainty sample variance')		[lb,ub] = varconfidence(NumberOfSimulations,0.95)	end	figure(2);	switch EstimController		case 0, subplot(221);		case 1, subplot(321);	end	plot(freq,db(G0),freq,db(Gldm),freq,db(G0-Gldm),'k',freq,db(stdGldm),'k:');	title('BJ with logdet plant model');	xx=axis;	xx(1:2) = [floor(freq(1)*100)/100, ceil(freq(end)*100)/100];	axis(xx);	switch EstimController		case 0, subplot(222);		case 1, subplot(322);	end	plot(freq,db(H0),freq,db(Hldm),freq,db(H0-Hldm),'k',freq,db(stdHldm),'k:')	title('BJ with logdet noise model');	yy=axis;	yy(1:2) = [floor(freq(1)*100)/100, ceil(freq(end)*100)/100];	axis(yy);	switch EstimController		case 0, subplot(223);		case 1, subplot(323);	end	plot(freq,db(G0),freq,db(Gtm),freq,db(G0-Gtm),'k',freq,db(stdGtm),'k:')	title('time domain plant model');	axis(xx);	switch EstimController		case 0, subplot(224);		case 1, subplot(324);	end	plot(freq,db(H0),freq,db(Htm),freq,db(H0-Htm),'k',freq,db(stdHtm),'k:')	title('time domain noise model')	axis(yy)	if EstimController == 1		subplot(325)		plot(freq,db(Gc0),freq,db(Gcldm),freq,db(Gc0-Gcldm),'k',freq,db(stdGcldm),'k:');		title('BJ with logdet controller model');		xx=axis;		xx(1:2) = [floor(freq(1)*100)/100, ceil(freq(end)*100)/100];		axis(xx);	end	zoom on	shg	else		disp('plant model')	disp('    true value          BJdet')	[a0.'/a0(end),aldm.',stdaldm.']	[b0.'/a0(end),bldm.',stdbldm.']		disp('noise model')	disp('    true value           BJdet')	[c0.',cldm.',stdcldm.']	[d0.',dldm.',stddldm.']	if EstimController == 1				disp('controller model')		disp('    true value          BJdet')		[ac0.'/ac0(end),acldm.',stdacldm.']		[bc0.'/ac0(end),bcldm.',stdbcldm.']			end		disp('estimated noise standard deviation');	sldm = sqrt(mean(s2ld));	[sigma, sldm]			disp('cov matrix plant model parameters')	Cplant	Covab	disp('cov matrix noise model parameters')	Cnoise	Covcd		if NumberOfSimulations > 1		disp('ratio estimated/actual covariance matrix plant model parameters')		Cplant./Covab		disp('ratio estimated/actual covariance matrix noise model parameters')		Cnoise./Covcd		disp('uncertainty sample variance')		[lb,ub] = varconfidence(NumberOfSimulations,0.95)	end		figure(2);    subplot(311);	plot(freq,db(G0),freq,db(Gldm),freq,db(G0-Gldm),'k',freq,db(stdGldm),'k:', freq, db(squeeze(CRbound.G(1,1,:))/NumberOfSimulations)/2,'g');	title('BJ with logdet plant model');	xx=axis;	xx(1:2) = [floor(freq(1)*100)/100, ceil(freq(end)*100)/100];	axis(xx);    subplot(312);	plot(freq,db(sigma*H0),freq,db(sldm*Hldm),freq,db(sigma*H0-sldm*Hldm),'k',freq,db(sldm*stdHldm),'k:', freq, db(squeeze(CRbound.H(1,1,:))/NumberOfSimulations)/2,'g')	title('BJ with logdet noise model');	yy=axis;	yy(1:2) = [floor(freq(1)*100)/100, ceil(freq(end)*100)/100];	axis(yy);	axis(yy)    subplot(313);	plot(freq,db(sigma*H0),freq,db(absHldm),freq,db(sigma*abs(H0)-absHldm),'k',freq,db(stdabsHldm),'k:', freq, db(squeeze(CRbound.SqrtNoisePower(1,1,:))/NumberOfSimulations)/2,'g')	title('BJ with logdet noise model');	yy=axis;	yy(1:2) = [floor(freq(1)*100)/100, ceil(freq(end)*100)/100];	axis(yy);	axis(yy)	if EstimController == 1		subplot(313)		plot(freq,db(Gc0),freq,db(Gcldm),freq,db(Gc0-Gcldm),'k',freq,db(stdGcldm),'k:');		title('BJ with logdet controller model');		xx=axis;		xx(1:2) = [floor(freq(1)*100)/100, ceil(freq(end)*100)/100];		axis(xx);	end	zoom on	shgendtoc% save ResultsOLDTgauss% save GaussianOLMonteCarlo% save ResultsCLDT% save ResultsOLDTFullUnitCircle% save ResultsCLDTFullUnitCircle% disp('        OE           NO          NOdet         BJ         BJld');% [CostOE,CostNO,CostNOdet,CostBJ,CostBJld]