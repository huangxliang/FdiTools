function [CY, CYm, Ym, dof, CL] = PeriodLocalPolyAnal(data, method);%%		Estimates the noise covariance matrix of P periods of the periodic ny x 1 signal y(t) %       via a local polynomial least squares approximation of the noise transient term.%       %	function [CY, CYm, Ym, dof, CL] = PeriodLocalPolyAnal(data, method);%%	Output parameters%%		CY      =	sample covariance matrix output noise calculated at the excited harmonics; %                   size ny x ny x Fexc %%		CYm     =	sample covariance matrix sample mean at the excited harmonics; %                   size ny x ny x Fexc %%       Ym      =   sample mean at excited harmonics with noise transient removed %                   size ny x Fexc%%       dof     =   actual degrees of freedom of the residuals used for the covariance estimate %                   (= equivqlent number of independent experiments-1)%%       CL      =   correlation length (over the frequency) of the sample mean and sample covariance %                   expressed in EXCITED frequencies:%                   Ym(k) is correlated with Ym(r) with r in [k-CL, k+CL]%%%	Input parameters%%		data	=	structure containing the input/output data in the frequency band of interest%                   struct{'Y', [], 'ExcitedHarm', [])%                       data.Y              =   DFT of P periods of the output signal, size ny x F %                                                   data.Y(:, P)        = first excited frequency%                                                   data.Y(:, end-P+1)  = last excited frequency%                                                   %                       data.ExcitedHarm    =   excited harmonics; size 1 x Fexc  %%       method  =   structure containing the parameters of the method used %                   struct('order', [], 'dof', [], 'period', [])%                       method.order        =	order of the polynomial approximation (optional; default 2) %                       method.dof          =   degrees of freedom of the (co-)variance estimates = equivalent number of %                                               independent experiments - 1 (default ny) %                       method.period       =   number of periods P of the periodic signal %                       method.transient    = 	determines the estimation of the transient term (optional; default 1)  %                                                   1: transient term is estimates %                                                   0: no transient term is estimates %% Rik Pintelon, March 2009% version March 2, 2010%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Initialisation variables %%%%%%%%%%%%%%%%%%%%%%%%%%%%%[ny, F] = size(data.Y);                                     % number of outputs ny, and number of frequencies Ftry	if isempty(method.order)		method.order = 2;	endcatch	method.order = 2;end % trytry	if isempty(method.dof)		method.dof = ny;	endcatch	method.dof = ny;end % tryif method.dof < ny    method.dof = ny;end % iftry	if isempty(method.transient)		method.transient = 1;	endcatch	method.transient = 1;end % tryif method.transient ~= 1    method.transient = 0;end % ifR = method.order;                                           % order polynomial methodTransient = method.transient;                               % default the transient is estimatedP = method.period;                                          % number of periodsExcitedHarm = data.ExcitedHarm;                             % excited harmonicsfreq = [1:1:F];                                             % relative DFT numbering representing all entries of data.Yfreq_exc = P*(ExcitedHarm-ExcitedHarm(1)+1);                % position excited frequencies in freq        Fexc = length(freq_exc);                                    % number of excited frequencies % selection excited frequencies in DFT spectrum = mean signal spectrumYm = zeros(ny, Fexc);Ym = data.Y(:, freq_exc);% removal of all potential excited frequencies in the data (= more than the% excited frequencies because of, for example, nonlinear distortions% what remains are those DFT lines that can never contain signal energySelDelete = [P:P:F];data.Y(:, SelDelete) = [];freq(SelDelete) = [];Fnoise = length(freq);                                      % number of noise DFT lines% half the frequency width in DFT samples of the polynomial method% nn DFT lines left and nn DFT lines right of the excited frequency at% which the noise covariance matrix is calculated; the excited line contains % signal energy and is not used for calculating the noise covariance matrix  nn = ceil((method.dof + Transient*(R+1))/2);% correlation length sample mean and sample covariance expressed in excited frequencies CL = ceil(2*nn/(P-1)-1);if CL < 0    CL = 0;end % if CL negative% number of degrees of freedom in the residuals = number of DFT lines - number of parameters qq = 2*nn - Transient*(R+1);% actual degrees of freedom of the covariance estimatedof = qq;% output noise sample covariance matrixCY = zeros(ny, ny, Fexc);% sample covariance matrix sample meanCYm = zeros(ny, ny, Fexc);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation of the regressor matrix Kn %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% regressor matrix; size parameters x DFT linesif Transient    Kn = zeros(R+1, 2*nn);end % if transient is estimated% loop over all excited frequenciesfor fk = 1:Fexc                                 % fk = index output parameter         % selection position kk in freq    kk = find(freq < freq_exc(fk), 1, 'last');        % range of DFT frequencies around kk    if kk < nn        r_index = [-kk+1:1:2*nn-kk];    end % if    if (kk >= nn) & (kk <= Fnoise-nn)        r_index = [-nn+1:1:nn];    end % if    if kk >= Fnoise-nn+1        r_index = [-2*nn+Fnoise-kk+1:1:Fnoise-kk];    end % if        if Transient                % intermediate variable: powers of r        r_power = freq(kk+r_index) - freq_exc(fk);        for ii = 1:R+1            Kn(ii,:) = (r_power).^(ii-1);        end % ii            % normalise the rows of Kn for improving the numerical stability of        % the calculations        Scale = sum(abs(Kn.^2), 2).^0.5;                        % 2-norm rows Kn        FindZeros = find(Scale == 0);                           % if the input is exactly zero in the band kk-n:kk+n        Scale(FindZeros) = 1;                                   % then the scaling is set equal to one        Kn = Kn./repmat(Scale, [1, 2*nn]);        % numerical stable LS estimate noise transient        [Un, Sn, Vn] = svd(Kn', 0);        Yn = (data.Y(:, kk+r_index)*Un)*Un';                    % Yn = data.Y(:, kk+r_index)*Qn; with Qn = Un * Un'            end % if transient is estimated        % numerical stable LS estimate of the noise covariance matrix                          En = data.Y(:, kk+r_index);                            if Transient        En = En - Yn;                                           % LS residuals En = data.Y(:, kk+r_index)*Pn; with Pn = I2n - Qn                                   end % if transient is estimated        CY(:,:,fk) = (En*En')/qq;        if Transient                % estimate noise transient TH at the excited frequency fk        ss = diag(Sn);        IndexZeros = find(ss == 0);        ss(IndexZeros) = inf;        ss = diag(1./ss);        Theta = Yn * (Un * ss * Vn');        TH = Theta(:, 1) / Scale(1);                            % denormalisation parameters         % covariance noise transient estimate TH        CTH = (norm(Vn(1,:).'.*diag(ss),2)/Scale(1))^2 * CY(:,:,fk);         % sample mean with noise transient removed        Ym(:, fk) = Ym(:, fk) - TH;          end % if transient is estimated        % sample covariance of the sample mean: noise at the excited frequency    % is independent of TH estimate because the excited frequencies have    % not been used for estimating TH    CYm(:,:,fk) = CY(:,:,fk);    if Transient        CYm(:,:,fk) = CYm(:,:,fk) + CTH;           end % if transient is estimated    end % kk iteration over all frequencies