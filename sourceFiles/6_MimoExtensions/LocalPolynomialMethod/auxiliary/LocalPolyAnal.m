function [CY, Y, TY, G, CvecG, dof, CL] = LocalPolyAnal(data, method);%%		Estimates the frequency response function (FRF) and the output noise covariance matrix from %       the DFT spectra of arbitrary input/output data via a local polynomial least squares approximation %       of the plant transfer function and the plant and noise transient terms. The input signal may be%       exactly zero in (parts of) the frequency band of interest.%%       For nonlinear systems the FRF is the best linear approximation and the output covariance%       is the sum of the noise covariance and the covariance of the stochastic nonlinear distortions. %%       If no input data is provided, then the algorithm simplifies to nonparametric %       time series analysis (noise power spectrum estimation).%%       Warning: the estimated frequency response matrix is meaningless in those %       frequency bands were the input is exactly zero.%       %%	function [CY, Y, TY, G, CvecG, dof, CL] = LocalPolyAnal(data, method);%%%	Output parameters%%		CY      =	struct('n', [], 'm', [], 'm_nt', [])%                       CY.n	:   sample covariance matrix output noise (+ nonlinear distortions), size ny x ny x F%                                       Usage: calculation uncertainty bounds on FRF%                       CY.m	:	sample covariance matrix sample mean output, size ny x ny x F%                                       Usage: weighting in frequency domain maximum likelihood estimation %                       CY.m_nt	:	sample covariance matrix sample mean output with transient(s) removed, size ny x ny x F%                                       Usage: weighting in frequency domain maximum likelihood estimation %%		Y      =   struct('m', [], 'm_nt', [])%                       Y.m     :   sample mean output, size ny x F%                                       Usage: frequency domain maximum likelihood estimation %                       Y.m_nt  :   sample mean output with transient(s) removed, size ny x F%                                       Usage: - frequency domain maximum likelihood estimation%                                              - leakage free output DFT spectra %%		TY      =	sum plant and noise (+ concatenation) transient contributions at output, size ny x F%                       Usage: - transient removal in sample mean Ym(k) %                              - transient removal in output spectrum Y(k)%%       G       =   estimated frequency response matrix, size ny x nu x F%%       CvecG   =   covariance matrix vec(G), size (ny*nu) x (ny*nu) x F %                   if the output noise covariance data.CY is available for nonlinear systems then %                   CvecG = struct('NL', [], 'n', []) where%                       CvecG.NL            =   estimated total covariance vec(G), size (ny*nu) x (ny*nu) x F %                       CvecG.n             =   noise covariance vec(G) calculated from data.CY, size (ny*nu) x (ny*nu) x F  %%       dof     =   actual degrees of freedom of the residuals used for the covariance estimate %                   (= equivalent number of independent experiments-1) %%       CL      =   ± CL is the correlation length (over the frequency) of the sample mean and sample covariance:%                   Y(k) is correlated with Y(m) with m in [k-CL, k+CL]%                   Note: CL+1 = the frequency width (in samples) of the local polynomial estimate %%%	Input parameters%%		data	=	structure containing the input/output data in the frequency band of interest%                   struct('Y', [], 'U', [], 'freq', [])%                       data.Y              =   output signal; size ny x F%                       data.U              =   input signal; size nu x F%                       data.freq           =   frequency vector in Hz or in DFT numbers; size 1 x F (optional) %                                               default: [1:1:F] %                       data.CY             =   optional parameter (default empty) for nonlinear systems; size ny x ny x F %                                               noise covariance matrix data.Y => the total covariance on the frequency response %                                               matrix can be split in noise and nonlinear contributions %                       data.nu_add         =   optional parameter (default empty) for handling concatenated data sets; %                                               nu_add = number of concatenated sets -1 = last nu_add inputs in data.U %%       method  =   structure containing the parameters of the method used (optional) %                   struct('order', [], 'dof', [], 'transient', [], 'step', [])%                       method.order        =	order of the polynomial approximation (optional; default 2) %                       method.dof          =	determines the degrees of freedom noise covariance estimate CY %                                               (optional; default ny)%                       method.transient    = 	determines the estimation of the transient term (optional; default 1)  %                                                   1: transient term is estimated %                                                   0: no transient term is estimated %                       method.step         =   determines at which entries of data.freq the output parameters are calculated: %                                               (optional; default 1)%                                                   data.freq(1:step:end) %%% Rik Pintelon, July 2008% version September 19, 2011%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Initialisation variables %%%%%%%%%%%%%%%%%%%%%%%%%%%%%[ny, F] = size(data.Y);                                     % number of outputs ny, and number of frequencies Ftry    if isempty(data.freq)        data.freq = [1:1:F];    else        data.freq = data.freq(:).';        data.freq = data.freq/min(diff(data.freq));         % normalisation for improving the numerical conditioning    end % if   catch	data.freq = [1:1:F];    end % try% number of concatenated data sets have been concatenated = nu_add + 1 try    if isempty(data.nu_add)        data.nu_add = 0;    end % if   catch    data.nu_add = 0;end % trynu_add = data.nu_add;try    if isempty(method)        method = struct('order', 2, 'dof', 0);    endcatch    method = struct('order', 2, 'dof', 0);end % trytry	if isempty(method.order)		method.order = 2;	endcatch	method.order = 2;end % trytry	if isempty(method.dof)		method.dof = ny;	endcatch	method.dof = ny;end % tryif method.dof < ny    method.dof = ny;end % iftry	if isempty(method.transient)		method.transient = 1;	endcatch	method.transient = 1;end % tryif method.transient ~= 1    method.transient = 0;end % iftry    if isempty(method.step)        method.step = 1;    end % if   catch	method.step = 1;    end % trytry	if isempty(data.U)		data.U = [];	endcatch	data.U = [];endtry	if isempty(data.CY)		data.CY = [];        NoiseCov = 0;           % no noise covariance matrix available    else        NoiseCov = 1;           % noise covariance available	endcatch	data.CY = [];    NoiseCov = 0;endR = method.order;               % order polynomial methodtransient = method.transient;   % if 1 then transient is estimated (default); otherwise 0Fstep = method.step;            % frequency stepSelectFreq = [1:Fstep:F].';     % entries of data.freq at which the output parameters are calculated Fselect = length(SelectFreq);   % number of frequencies at which the output parameters are calculated  nu = size(data.U, 1);           % number of inputs nu switch transient    case 1        nu1 = nu+1;             % +1 accounts for the transient parameters    case 0        nu1 = nu;               % no transient parameters are estimatedend % switch% half the frequency width in DFT samples of the polynomial method% nn = ceil((ny + (R+1)*nu1 - 1 + mm)/2);nn = ceil((method.dof + (R+1)*nu1 - 1)/2);% correlation length nonparametric estimatesCL = 2*nn;% number of degrees of freedom in the residualsqq = 2*nn+1 - (R+1)*nu1;% degrees of freedom of the covariance estimatedof = qq;% covariance matricesCY = struct('n', zeros(ny, ny, Fselect), 'm', zeros(ny, ny, Fselect), 'm_nt', zeros(ny, ny, Fselect));% sample mean outputY = struct('m', zeros(ny, Fselect), 'm_nt', zeros(ny, Fselect));% plant and noise transient contribution at outputTY = zeros(ny, Fselect);% frequency response matrix from U (without additional inputs) to YG = zeros(ny, nu-nu_add, Fselect);% covariance matrix FRMif NoiseCov == 0	% no output noise covariance available    CvecG = zeros(ny*(nu-nu_add), ny*(nu-nu_add), Fselect);else                % output noise covariance available    CvecG = struct('NL', [], 'n', []);    CvecG.NL = zeros(ny*(nu-nu_add), ny*(nu-nu_add), Fselect);    CvecG.n = zeros(ny*(nu-nu_add), ny*(nu-nu_add), Fselect);end % if no noise covariance available%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation of the regressor matrix Kn %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% regressor matrixKn = zeros((R+1)*nu1, 2*nn+1);% intermediate variablePower_r = ones(R+1, 2*nn+1);% loop over all frequenciesfk = 0;                                     % frequency index of the output parametersfor kk = 1:Fstep:F        fk = fk + 1;        % range of DFT frequencies around kk    if kk <= nn        r_index = [-kk+1:1:2*nn-kk+1];    end % if    if (kk >= nn+1) & (kk <= F-nn)        r_index = [-nn:1:nn];    end % if    if kk >= F-nn+1        r_index = [-2*nn+F-kk:1:F-kk];    end % if        % intermediate variable: powers of r    r_power = data.freq(kk+r_index)-data.freq(kk);    for ii = 2:R+1        Power_r(ii,:) = (r_power).^(ii-1);    end % ii        % regressor matrix    if nu > 0        Ukr = data.U(:, kk+r_index);        for jj = 1:2*nn+1            Kn(1:(R+1)*nu, jj) = kron(Power_r(:, jj), Ukr(:, jj));        end % jj     end % if nu > 0    if transient        Kn((R+1)*nu+1:end, :) = Power_r;    end % if transient        % normalise the rows of Kn for improving the numerical stability of    % the calculations    Scale = sum(abs(Kn.^2), 2).^0.5;                            % 2-norm rows Kn    FindZeros = find(Scale == 0);                               % if the input is exactly zero in the band kk-n:kk+n    Scale(FindZeros) = 1;                                       % then the scaling is set equal to one    Kn = Kn./repmat(Scale, [1, 2*nn+1]);    % numerical stable LS estimate output (= "sample mean")    [Un, Sn, Vn] = svd(Kn', 0);    Yn = (data.Y(:, kk+r_index)*Un)*Un';                        % Yn = data.Y(:, kk+r_index)*Qn; with Qn = Un * Un'    Index_kk = find(r_index == 0);    Y.m(:, fk) = Yn(:, Index_kk);            % numerical stable LS estimate of the noise covariance matrix (= "sample covariance matrix")                          En = data.Y(:, kk+r_index) - Yn;                            % LS residuals En = data.Y(:, kk+r_index)*Pn; with Pn = I2n+1 - Qn    CY.n(:,:,fk) = (En*En')/qq;        % sample covariance of the sample mean    Qnkk = Un(Index_kk, :) * Un(Index_kk, :)';    CY.m(:,:,fk) = real(Qnkk) * CY.n(:,:,fk);                   % CYm(:,:,fk) = real(Qn(Index_kk, Index_kk)) * CYn(:,:,fk);        if transient || (nu > 0)                 % LS estimate model parameters (Theta matrix)        ss = diag(Sn);        IndexZeros = find(ss == 0);        ss(IndexZeros) = inf;        ss = diag(1./ss);        Theta = Yn * (Un * ss * Vn');           end % if transient or input signal available        if transient                % LS estimate transient contribution at output        IndexTrans = nu*(R+1)+1;                             	% position transient parameters in Theta matrix        TY(:, fk) = Theta(:, IndexTrans) / Scale(IndexTrans);	% denormalisation parameters         if nu_add > 0            % estimate FRM of the additional inputs due to concatenation             IndexFRMadd = [nu-nu_add+1:nu];                     % position parameters in Theta matrix            Gadd = Theta(:, IndexFRMadd) ./ repmat(Scale(IndexFRMadd).', [ny, 1]);            % estimate additional transients due to concatenation            Uadd = data.U(IndexFRMadd, kk);            TY(:, fk) = TY(:, fk) + Gadd * Uadd;          end % if additional inputs        Y.m_nt(:, fk) = Y.m(:, fk) - TY(:, fk);                 % output without transient                % covariance matrix Ym-TY        % qkk = Un * (Un(Index_kk, :)' - bmm - cmm);        % bmm = diag(ss) .* Vn(IndexTrans, :)' / Scale(IndexTrans);  % denormalisation parameters         % cmm = diag(ss) .* (Vn(IndexFRMadd, :)' * (Ukr(IndexFRMadd)./Scale(IndexFRMadd)));  % denormalisation parameters         bmm = diag(ss) .* Vn(IndexTrans, :)' /Scale(IndexTrans);        if nu_add > 0            % Uadd = the additional inputs due to the concatenation            cmm = diag(ss) .* (Vn(IndexFRMadd, :)' * (Uadd./Scale(IndexFRMadd)));        else            cmm = zeros(size(bmm));        end % if concatenated data sets        qkk = Un * (Un(Index_kk, :)' - bmm - cmm);        CY.m_nt(:,:,fk) = norm(qkk, 2)^2 * CY.n(:,:,fk);            end % if transient        if nu > 0                % estimate FRM from U (without the additional inputs due to the concatenation) to Y          IndexFRM = [1:nu-nu_add];                                        % position FRM parameters in Theta matrix        G(:, :, fk) = Theta(:, IndexFRM) ./ repmat(Scale(IndexFRM).', [ny, 1]);        % covariance matrix vec(G)        dimVn = size(Vn, 2);                VV =  (Vn(IndexFRM, :) ./ repmat(Scale(IndexFRM), [1, dimVn])) * ss;    % intermediate variable         if NoiseCov == 0            CvecG(:, :, fk) = kron(conj(VV * VV'), CY.n(:,:,fk));        else            CvecG.NL(:, :, fk) = kron(conj(VV * VV'), CY.n(:,:,fk));            CvecG.n(:, :, fk) = kron(conj(VV * VV'), data.CY(:,:,fk));                    end % if no noise covariance available        end % nu > 0    end % kk iteration over all frequencies