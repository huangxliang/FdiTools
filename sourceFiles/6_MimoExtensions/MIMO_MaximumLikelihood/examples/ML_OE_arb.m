%% Paramteric transfer function modeling of a multiple-input, multiple-output (MIMO) discrete-time % or continuous-time system operating in open loop and excited by random inputs. The transient% is removed by the local polynomial method via the function "ArbLocalPolyAnal". % Known input, noisy output case (generalized output error method) %% Rik Pintelon, 10 October 2011%%clear allclose all%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Choice discrete-time or continuous-time models, noise standard deviation % % number of samples, sampling period, number of inputs and outputs         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%N = 5000;		% number of time domain samples% discrete-time plant and noise modelsNoisePlane = 'z';PlantPlane = 'z';% continuous-time plant and noise models% NoisePlane = 's';       % continuous-time noise model% PlantPlane = 's';       % continuous-time plant model% sqrt(s) domain plant and noise models% NoisePlane = 'w';% PlantPlane = 'w';RecipPlant = 1;         % 1 => plant model is reciprocal% standard deviation output noiseswitch PlantPlane	case 'z', stde = 1;	case 's', stde = 0.05;    case 'w', stde = 1;end% sampling period Ts, sampling frequency fsTs = 1/5.5;fs = 1/Ts;% number of outputs ny and inputs nuny = 3;         % 1 <= ny <= 3nu = 2;         % 1 <= nu <= 3%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition noise model %%%%%%%%%%%%%%%%%%%%%%%%%%%switch NoisePlane    	case 'z',		c0 = zeros(3,3,3);		c0(1,1,:) = fliplr([3.5666e-01   0.9830e-01   3.3444e-01]);		c0(2,2,:) = fliplr([1 -1 0.9]);		c0(3,3,:) = fliplr([9.6478e-01   -5.4142e-01   9.4233e-01]);		c0(3,1,:) = [0.1   -0.15    0];		c0(1,3,:) = c0(3,1,:);		c0(2,3,:) = [0.2 0 0];		c0(3,2,:) = [0.35 0.5 -0.25];		d0 = [1 -0.2 0.85];        	case 's',		c0 = zeros(3,3,3);		% entry 1,1		fz = 1.5/2;		deltaz = 0.1;		TheZero = 2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz);		c0(1,1,:) = fliplr(real(poly([TheZero,conj(TheZero)])));		% entry 2,2		fz = 1.2;		deltaz = 0.05;		TheZero = 2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz);		c0(2,2,:) = fliplr(real(poly([TheZero,conj(TheZero)])));        % c0(2,2,:) = [1 0 0];		% entry 3,3		fz = 0.35;		deltaz = 0.15;		TheZero = 2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz);		c0(3,3,:) = fliplr(real(poly([TheZero,conj(TheZero)])));				fp1 = 0.25;		deltap1 = 0.2;		ThePole1 = 2*pi*sqrt(-1)*fp1*(1 + sqrt(-1)*deltap1);		fp2 = 1;		deltap2 = 0.05;		ThePole2 = 2*pi*sqrt(-1)*fp2*(1 + sqrt(-1)*deltap2);		d0 = real(poly([ThePole1,conj(ThePole1),ThePole2,conj(ThePole2)]));		d0 = real(poly([ThePole2,conj(ThePole2)]));       		d0 = fliplr(d0);             case 'w',		c0 = zeros(3,3,3);		% entry 1,1		fz = 1.5/2;		deltaz = 0.1;		TheZero = (2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz)).^0.5;		c0(1,1,:) = fliplr(real(poly([TheZero,conj(TheZero)])));		% entry 2,2		fz = 1.2;		deltaz = 0.05;		TheZero = (2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz)).^0.5;		c0(2,2,:) = fliplr(real(poly([TheZero,conj(TheZero)])));        % c0(2,2,:) = [1 0 0];		% entry 3,3		fz = 0.35;		deltaz = 0.15;		TheZero = (2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz)).^0.5;		c0(3,3,:) = fliplr(real(poly([TheZero,conj(TheZero)])));				fp1 = 0.25;		deltap1 = 0.2;		ThePole1 = (2*pi*sqrt(-1)*fp1*(1 + sqrt(-1)*deltap1)).^0.5;		fp2 = 1;		deltap2 = 0.05;		ThePole2 = (2*pi*sqrt(-1)*fp2*(1 + sqrt(-1)*deltap2)).^0.5;		d0 = real(poly([ThePole1,conj(ThePole1),ThePole2,conj(ThePole2)]));		d0 = real(poly([ThePole2,conj(ThePole2)]));       		d0 = fliplr(d0);end% simulate a non-diagonal noise modelswitch NoisePlane        case 'z',        c0(1,2,:) = [0.1 -0.05 0.07]*2;        c0(2,1,:) = c0(1,2,:);        c0(2,1,end) = c0(2,1,end)*0.4;            case {'s','w'}        c0(1,2,:) = 0.1*c0(3,3,:);        c0(2,1,:) = 0.1*c0(1,1,:);        end % switchnc = size(c0, 3) - 1;nd = length(d0) - 1;%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition plant model %%%%%%%%%%%%%%%%%%%%%%%%%%%nmax = 3;switch PlantPlane    	case 'z',        rand('state',0);		b0 = rand(nmax, nmax, 5);		% chebychev polynomial for noise model		[b110, a0] = cheby1(4, 3, 0.5);        	case {'s','w'}        rand('state',0);		b0 = rand(nmax, nmax, 4);		% inverse chebychev polynomial for plant		[b110, a0] = cheby2(4, 40, 2*2*pi,'s');		b110 = fliplr(b110(2:end));		b110(2) = 5e-4;        if PlantPlane == 'w'            ThePoles = roots(a0);            ThePoles = ThePoles.^0.5;            a0 = poly(ThePoles);        end % if sqrt(s)-domain		a0 = fliplr(a0);		b0(1,1,:) = 0.1*b110;        b0(1,2,:) = b0(1,1,:);        b0(1,3,:) = b0(1,2,:);        b0(2,1,:) = b0(2,1,:);		b0(2,2,:) = fliplr([a0(1) 0 2e-3 1])/100;		b0(3,3,:) = fliplr([2e-3 a0(1) 0 1]);		b0(3,2,:) = fliplr([0 5e-4 a0(1) 1]);        end % switchna = length(a0) - 1;nb = size(b0,3) - 1;% make the plant model reciprocal if requiredif RecipPlant == 1	for ll = 1:nb+1		b0(:,:,ll) = (b0(:,:,ll) + b0(:,:,ll).')/2;	endend%%%%%%%%%%%%%%%%%%%%%%%%%%% Set the default values %%%%%%%%%%%%%%%%%%%%%%%%%%%[Sel, Theta0, ModelVar, IterVar] = MIMO_ML_DefaultValues(na, nb, nu, ny, PlantPlane);% output noise only; passing this information to the parametric step % simplifies the calculationsModelVar.Struct = 'OE';% reciprocity of the plant model is imposed belowModelVar.RecipPlant = RecipPlant;fmin = 0.1;fmax = 2;Select = [ceil(fmin/(fs/N))+1:1:floor(fmax/(fs/N))+1].';	% select from 0.1 Hz to 2 Hzfreq = (Select-1)*fs/N;SelectAll = [1:1:N+1].';                                    % from DC to Nyquist on 2*N pointsfreqAll = ((SelectAll-1)/(2*N)/Ts);% powers of jw or exp(-jw*Ts)switch PlantPlane	case 's', sAll = sqrt(-1)*2*pi*freqAll;	case 'w', sAll = (sqrt(-1)*2*pi*freqAll).^0.5;endswitch NoisePlane	case 's', sAll = sqrt(-1)*2*pi*freqAll;	case 'w', sAll = (sqrt(-1)*2*pi*freqAll).^0.5;end%%%%%%%%%%%%%%%%%%%%%%%%%% True model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%Theta0.A = a0;for ii = 1:ny	for jj = 1:nu		Theta0.B(ii,jj,:) = b0(ii,jj,:);	end % jjend % iiTheta0.B = Theta0.B(1:ny,1:nu,:);Theta0.D = d0;for ii = 1:ny	for jj = 1:ny		Theta0.C(jj,ii,:) = c0(jj,ii,:);	endendTheta0.C = Theta0.C(1:ny,1:ny,:);% transient terms are not used and set to zeronig = 0;ModelVar.nig = nig;Sel.Ig = zeros(ny, nig+1);Theta0.Ig = zeros(ny, nig+1);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Deterministic part output %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%switch ModelVar.PlantPlane   	case 'z',                   % calculation in time domain via filter		u = randn(nu, N);		y0 = zeros(ny, N);		for jj=1:ny			for ii=1:nu				y0(jj,:) = y0(jj,:) + filter(squeeze(b0(jj,ii,:)), a0, u(ii,:));			end % ii		end % jj        	case {'s','w'}               % calculation via the frequency domain on twice the number of time domain points 		u = randn(nu, 2*N);		U = fft(u,[],2);		Y0 = zeros(ny, length(SelectAll));		for jj=1:ny			for ii=1:nu				Y0(jj,:) = Y0(jj,:) + ((polyval(fliplr(squeeze(b0(jj,ii,:)).'),sAll)./polyval(fliplr(a0),sAll)).').*U(ii,SelectAll);			end % ii		end % jj		y0 = 2*real(ifft([zeros(ny,1),Y0(:,2:end-1),zeros(ny,N)],[],2));		u = u(:,1:N);		y0 = y0(:,1:N);        end % switch%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Contribution noise to output %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Te = fliplr(hankel(ones(ny,1)));switch NoisePlane    	case 'z',		e = stde*randn(ny, N);		v = zeros(ny, N);		e = Te*e;		for jj=1:ny			for ii=1:ny				v(jj,:) = v(jj,:) + filter(squeeze(c0(jj,ii,:)),d0,e(ii,:));			end % ii		end % jj        	case {'s', 'w'}		e = stde*randn(ny, 2*N);		e = Te*e;		E = fft(e,[],2);		V = zeros(ny, length(SelectAll));		for jj=1:ny			for ii=1:ny				V(jj,:) = V(jj,:) + ((polyval(fliplr(squeeze(c0(jj,ii,:)).'),sAll)./polyval(fliplr(d0),sAll)).').*E(ii,SelectAll);			end % ii		end % jj		v = 2*real(ifft([zeros(ny,1),V(:,2:end-1),zeros(ny,N)],[],2));		v = v(:,1:N);        end % switch%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Local polynomial estimate of the FRM, its noise covariance, %% and the input-output sample mean and sample covariances     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% data for ArbLocalPolyAnaldata.y = y0 + v;data.u = u;data.Ts = 1/fs;% defintion methodmethod.dof = 10;method.startfreq = fmin;method.stopfreq = fmax;[CZ, Z, freq, G, CvecG, dof, CL] = ArbLocalPolyAnal(data, method);%%%%%%%%%%%%%%%%%%%%%%%%%%%% Data for identification %%%%%%%%%%%%%%%%%%%%%%%%%%%%F = length(freq);              % number of frequenciesdata_fit.Y = Z.m_nt(1:ny,:);            % sample mean with transient removaldata_fit.U = Z.m_nt(ny+1:end,:);        % noiseless input DFT spectrumdata_fit.freq = freq;data_fit.Ts = Ts;data_fit.CY = CZ.m_nt(1:ny,1:ny,:);     % sample covariance sample mean with transient removaldata_fit.CU = zeros(nu,nu,F);data_fit.CYU = zeros(ny,nu,F);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Parametric estimate plant model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% starting values plant modeldata_fit.W = data_fit.CY;[ThetaWTLS, smax, smin, wscale] = MIMO_WTLS(data_fit, Sel, ModelVar);[ThetaIQML, CostIQML, smax, smin, wscale] = MIMO_IQML(data_fit, Sel, ThetaWTLS, ModelVar, IterVar);% SML estimate[ThetaML, CostML, smax, smin, wscale] = MIMO_ML(data_fit, Sel, ThetaIQML, ModelVar, IterVar);%%%%%%%%%%%%%%%%%%%%%%%%%%% Cramer-Rao lower bound %%%%%%%%%%%%%%%%%%%%%%%%%%%data_fit.dof = dof;                     % the CR-bound needs variability of the estimated noise covariancedata_fit.CY = CZ.n(1:ny,1:ny,:);        % the CR-bound requires the noise covariance; not the covariance of the sample mean% Calculation parametric TF model and its covariance; the poles (+ resonance frequency, damping, time constant) and their covariances; % and residue matrices (+ singular values and left and right singular vectors) and their covariances [CRbound, GML, ThetaML, CovThetan, Thetan, Seln, wscale, TheCond] = MIMO_ML_CRbound(data_fit, Sel, ThetaML, ModelVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation true plant model and noise power spectrum %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% powers of jw or exp(-jw*Ts)switch PlantPlane	case 'z', x.Plant = exp(-sqrt(-1)*2*pi*freq.'*Ts);	case 's', x.Plant = sqrt(-1)*2*pi*freq.';	case 'w', x.Plant = (sqrt(-1)*2*pi*freq.').^0.5;endswitch NoisePlane	case 'z', x.Noise = exp(-sqrt(-1)*2*pi*freq.'*Ts);	case 's', x.Noise = sqrt(-1)*2*pi*freq.';	case 'w', x.Noise = (sqrt(-1)*2*pi*freq.').^0.5;end% true plant transfer functionPolyTrans0 = MIMO_ML_CalcPolyTrans(Theta0, x);% true noise transfer function H0 = C0/D0H0 = zeros(ny, ny, F);D0 = polyval(fliplr(Theta0.D), x.Noise.');       % true noise denominator for ii = 1:ny	for jj = 1:ny		H0(ii, jj, :) = polyval(fliplr(squeeze(Theta0.C(ii, jj, :)).'), x.Noise.');	end % jjend % iidummy(1,1,:) = D0;H0 = H0./repmat(dummy, ny, ny);% true noise power spectrumCovE = stde^2*Te*Te.';                  % true covariance driving white noise disturbancesS0 = zeros(ny, ny, F);for kk = 1:F	S0(:,:,kk) = H0(:,:,kk) * CovE * H0(:,:,kk)';	% remove small imaginary parts on the main diagonal	S0(:,:,kk) = S0(:,:,kk) - diag(sqrt(-1)*imag(diag(S0(:,:,kk))));end % frequencies kk%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation true poles, resonance frequencies, %% damping ratios, time constants                 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the covariance has no meaning here[CovPoles0, Poles0] = CovRoots(Theta0.A, eye(na+1), Sel.A, PlantPlane, Ts);%%%%%%%%%%%%%%%%%%%%% Plot the results %%%%%%%%%%%%%%%%%%%%%% comparison true noise covariance and nonparametric local polynomial estimateCYn = CZ.n(1:ny,1:ny,:);           % nonparametric estimate noise covarianceFigNum = 1;figure(FigNum)clfmm = 0;for jj = 1:ny	for ii = 1:ny		mm = mm+1;        subplot(ny, ny, mm)        plot(freq, db(squeeze(S0(jj,ii,:)))/2, 'k', freq, db(squeeze(CYn(jj,ii,:)))/2, 'r');	end % iiend % jjsubplot(ny, ny, ceil(ny/2))title('True noise cov.: black; Nonparametric estimate: red');zoom on; shg% comparison true plant model and parametric estimateFigNum = FigNum+1;figure(FigNum)mm = 0;for jj = 1:ny	for ii = 1:nu		mm = mm+1;		subplot(ny, nu, mm)		plot(freq, db(squeeze(GML(jj,ii,:))), 'r', freq, db(squeeze(PolyTrans0.G(jj,ii,:))), 'k', ...		     freq, db(squeeze(PolyTrans0.G(jj,ii,:)-GML(jj,ii,:))), 'k--', ...             freq, db(squeeze(CRbound.G(jj,ii,:)))/2, 'r--');	end % iiend % jjsubplot(ny, nu, ceil(nu/2))title('G_0: black; G: red; |G-G_0|: black --; var(G): red --');zoom on; shg% whitness test residuals every CL frequency[Auto_Corr0, Lags0, Conf_Bound0, Fraction0] = WhitenessTestResiduals(G, CvecG, GML, CL, dof);if nu*ny == 1    Fraction0m = squeeze(Fraction0);elseif ny == 1    Fraction0m = squeeze(mean(Fraction0, 2));elseif nu == 1    Fraction0m = squeeze(mean(Fraction0, 1));else    Fraction0m = mean(mean(Fraction0));end % if disp(['mean fraction outside 50% and 95% confidence bounds: ',num2str(Fraction0m(1)),', and ',num2str(Fraction0m(2))]);F=length(freq);ntheta = sum(Sel.A)+sum(sum(sum(Sel.B))+sum(sum(Sel.Ig))) - 1;Cost0 = dof/(dof-ny)*ny*(F-ntheta/2);stdCost0 = sqrt(3*(dof)^3*ny/(dof-ny)^2/(dof-ny-1)*(F-ntheta/2));disp(['Expected value true cost, std true cost, and actual value cost: ',num2str(Cost0),', ',num2str(stdCost0),', and ',num2str(CostML)]);% comparison true and estimated resonance frequenciesdisp('Estim. f0 [Hz], std(f0) [Hz], estim. - true [Hz]')[ThetaML.poles.freq, CRbound.poles.freq.^0.5, ThetaML.poles.freq-Poles0.freq]% comparison true and estimated damping ratiosdisp('Estim. damping, std(damping), estim. - true')[ThetaML.poles.damp, CRbound.poles.damp.^0.5, ThetaML.poles.damp-Poles0.damp]