%% Single-input, single-output discrete-time system operating in unity feedback% excited by a random input. The transient is removed by the local polynomial method % via the function "ArbLocalPolyAnal".% A comparison is made between the estimate with and without reference signal. % Known input, noisy output case (generalized output error) %% Rik Pintelon, 12 October 2011%clear allclose all%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition discrete-time plant and noise models %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% definition discrete-time plant modelB = 0.5*[0 1 0.5]; A = [1 -1.5 0.7];% definition discrete-time noise modelC = 0.1*[1 -1 0.9];D = [1 -0.2 0.5];N = 8000;               % number of time domain points Ts = 1;fs = 1/Ts;              % sampling frequency%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Set the default values for the parametric identification %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%na = length(A)-1;       % denominator order plant modelnb = length(B)-1;       % numerator order plant modelnu = 1;                 % number of inputsny = 1;                 % number of outputsPlantPlane = 'z';       % discrete-time model[Sel, Theta0, ModelVar, IterVar] = MIMO_ML_DefaultValues(na, nb, nu, ny, PlantPlane);Theta0.A = A;Theta0.B(1,1,:) = B;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Simulation known input - noisy output data %% of the system operating in unity feedback  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% reference signalr = rand(1, N);% deterministic part input and outputu0 = filter(A, A+B, r);y0 = filter(B, A+B, r);% noisy part input and outputstde = 4;                       % value chosen such that value std(v) ~ std(u0)e = stde*randn(1, N);v = filter(conv(C, A), conv(D, A+B), e);% known input, noisy outputu = u0 - v;y = y0 + v;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calling the ArbLocalPolyAnal function %% case 1: reference signal is known     %%         => errors-in-variables        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% data data1.u = u;                             % row index is the input number; the column index the time instant (in samples) data1.y = y;                             % row index is the output number; the column index the time instant (in samples) data1.r = r;                             % the reference signal is needed to obtain consistent nonparametric FRF estimates in feedbackdata1.Ts = 1/fs;                         % sampling period% methodmethod.dof = 6;                         % degrees of freedom of the variance estimatemethod.order = 2;                       % order local polynomial approximation% local polynomial estimate FRF and its variance[CZ1, Z1, freq, G1, CvecG1, dof1, CL1] = ArbLocalPolyAnal(data1, method);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calling the ArbLocalPolyAnal function %% case 2: no reference available        %%         => generalized output error   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% data data2.u = u;                             % row index is the input number; the column index the time instant (in samples) data2.y = y;                             % row index is the output number; the column index the time instant (in samples) data2.Ts = 1/fs;                         % sampling period% methodmethod.dof = 6;                         % degrees of freedom of the variance estimatemethod.order = 2;                       % order local polynomial approximation% local polynomial estimate FRF and its variance[CZ2, Z2, freq, G2, CvecG2, dof2, CL2] = ArbLocalPolyAnal(data2, method);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Data for identification           %% case 1: reference signal is known %%         => errors-in-variables    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%data_fit1.Y = Z1.m_nt(1:ny,:);            % sample mean with transient removaldata_fit1.U = Z1.m_nt(ny+1:end,:);        % noiseless input DFT spectrumdata_fit1.freq = freq;data_fit1.Ts = 1/fs;data_fit1.CY = CZ1.m_nt(1:ny,1:ny,:);     % sample covariance sample mean with transient removaldata_fit1.CU = CZ1.m_nt(ny+1:end,ny+1:end,:);data_fit1.CYU = CZ1.m_nt(1:ny,ny+1:end,:);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Data for identification               %% case 2: no reference signal available %%         => generalized output error   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%data_fit2.Y = Z2.m_nt(1:ny,:);            % sample mean with transient removaldata_fit2.U = Z2.m_nt(ny+1:end,:);        % noiseless input DFT spectrumdata_fit2.freq = freq;data_fit2.Ts = 1/fs;data_fit2.CY = CZ2.m_nt(1:ny,1:ny,:);     % sample covariance sample mean with transient removaldata_fit2.CU = CZ2.m_nt(ny+1:end,ny+1:end,:);data_fit2.CYU = CZ2.m_nt(1:ny,ny+1:end,:);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Parametric estimate plant model   %% case 1: reference signal is known %%         => errors-in-variables    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% starting values plant modeldata_fit1.W = data_fit1.CY;[ThetaWTLS1, smax, smin, wscale] = MIMO_WTLS(data_fit1, Sel, ModelVar);[ThetaIQML1, CostIQML1, smax, smin, wscale] = MIMO_IQML(data_fit1, Sel, ThetaWTLS1, ModelVar, IterVar);% SML estimate[ThetaML1, CostML1, smax, smin, wscale] = MIMO_ML(data_fit1, Sel, ThetaIQML1, ModelVar, IterVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Parametric estimate plant model     %% case 2: reference signal is known   %%         => generalized output error %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% starting values plant modeldata_fit2.W = data_fit2.CY;[ThetaWTLS2, smax, smin, wscale] = MIMO_WTLS(data_fit2, Sel, ModelVar);[ThetaIQML2, CostIQML2, smax, smin, wscale] = MIMO_IQML(data_fit2, Sel, ThetaWTLS2, ModelVar, IterVar);% SML estimate[ThetaML2, CostML2, smax, smin, wscale] = MIMO_ML(data_fit2, Sel, ThetaIQML2, ModelVar, IterVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Cramer-Rao lower bound            %% case 1: reference signal is known %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%data_fit1.dof = dof1;                     % the CR-bound needs variability of the estimated noise covariancedata_fit1.CY = CZ1.n(1:ny,1:ny,:);        % the CR-bound requires the noise covariance; not the covariance of the sample meandata_fit1.CU = CZ1.n(ny+1:end,ny+1:end,:);data_fit1.CYU = CZ1.n(1:ny,ny+1:end,:);% Calculation parametric TF model and its covariance; the poles (+ resonance frequency, damping, time constant) and their covariances; % and residue matrices (+ singular values and left and right singular vectors) and their covariances [CRbound1, GML1, ThetaML1] = MIMO_ML_CRbound(data_fit1, Sel, ThetaML1, ModelVar);GML1 = squeeze(GML1);varGML1 = squeeze(CRbound1.vecG);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Cramer-Rao lower bound                %% case 2: no reference signal available %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%data_fit2.dof = dof1;                     % the CR-bound needs variability of the estimated noise covariancedata_fit2.CY = CZ2.n(1:ny,1:ny,:);        % the CR-bound requires the noise covariance; not the covariance of the sample meandata_fit2.CU = CZ2.n(ny+1:end,ny+1:end,:);data_fit2.CYU = CZ2.n(1:ny,ny+1:end,:);% Calculation parametric TF model and its covariance; the poles (+ resonance frequency, damping, time constant) and their covariances; % and residue matrices (+ singular values and left and right singular vectors) and their covariances [CRbound2, GML2, ThetaML2] = MIMO_ML_CRbound(data_fit2, Sel, ThetaML2, ModelVar);GML2 = squeeze(GML2);varGML2 = squeeze(CRbound2.vecG);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation true plant model and noise variances %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% true FRFq = exp(-sqrt(-1)*2*pi*freq/fs);        % z^(-1) as a function of the frequency G0 = polyval(fliplr(B), q) ./ polyval(fliplr(A), q);G0 = G0.';% true noise modelH0 = stde*polyval(fliplr(C), q) ./ polyval(fliplr(D), q);H0 = H0.';% true input-output variances for case 1varVu_0 = abs((H0./(1+G0)).^2).';                     % true input noise variancevarVy_0 = abs((H0./(1+G0)).^2).';                     % true output noise variance% true output variance for case 2varY0 = abs(H0.^2).';%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation true poles, resonance frequencies, %% damping ratios, time constants                 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the covariance has no meaning here[CovPoles0, Poles0] = CovRoots(Theta0.A, eye(na+1), Sel.A, PlantPlane, Ts);%%%%%%%%%%%%%%%%%%%%% Plot the results %%%%%%%%%%%%%%%%%%%%%% case 1: nonparametric estimates input-output noise variancesvarVy = squeeze(CZ1.n(1,1,:));           % estimate output noise variancevarVu = squeeze(CZ1.n(2,2,:));           % estimate input noise variance% case 2: nonparametric estimates output noise variancevarY = squeeze(CZ2.n(1,1,:)); % comparison true and estimated input-output noise variancesfigure(1)subplot(211)plot(freq, db(varVu)/2, 'r', freq, db(varVu_0)/2, 'k');xlabel('Frequency (Hz)')ylabel('Input variance (dB)')title('Reference signal available: EIV solution');legend('variance estimate', 'true variance', 'Location', 'EastOutside');subplot(212)plot(freq, db(varVy)/2, 'r', freq, db(varVy_0)/2, 'k');xlabel('Frequency (Hz)')ylabel('Output variance (dB)')legend('variance estimate', 'true variance', 'Location', 'EastOutside');zoom on;shg% comparison true plant model and parametric estimatefigure(2)plot(freq, db(GML1), 'r', freq, db(G0), 'k', freq, db(GML1-G0), 'k--', ...     freq, db(varGML1)/2, 'r--')xlabel('Frequency (Hz)')ylabel('Amplitude (dB)')legend('G-estimate', 'G_0', '|G-G_0|', 'var(G)', 'Location', 'EastOutside');title('Reference signal available: EIV solution');zoom on;shg% comparison true and estimated input-output noise variancesfigure(3)plot(freq, db(varY)/2, 'r', freq, db(varY0)/2, 'k');xlabel('Frequency (Hz)')ylabel('Output variance (dB)')title('No reference available: generalized OE solution');legend('variance estimate', 'true variance', 'Location', 'EastOutside');zoom on;shg% comparison true plant model and parametric estimatefigure(4)plot(freq, db(GML2), 'r', freq, db(G0), 'k', freq, db(GML2-G0), 'k--', ...     freq, db(varGML2)/2, 'r--')xlabel('Frequency (Hz)')ylabel('Amplitude (dB)')legend('G-estimate', 'G_0', '|G-G_0|', 'var(G)', 'Location', 'EastOutside');title('No reference signal available: generalized OE solution');zoom on;shgF = length(freq);   % number of frequenciesntheta = sum(Sel.A)+sum(sum(sum(Sel.B))+sum(sum(Sel.Ig))) - 1;Cost0 = dof1/(dof1-ny)*ny*(F-ntheta/2);stdCost0 = sqrt(3*(dof1)^3*ny/(dof1-ny)^2/(dof1-ny-1)*(F-ntheta/2));disp(['Expected value true cost, std true cost, and actual value cost: ',num2str(Cost0),', ',num2str(stdCost0),', and ',num2str(CostML1)]);% comparison true and estimated resonance frequencies: case 1, known reference signal disp('Estimates with reference signal')disp('Estim. f0 [Hz], std(f0) [Hz], estim. - true [Hz]')[ThetaML1.poles.freq, CRbound1.poles.freq.^0.5, ThetaML1.poles.freq-Poles0.freq]% comparison true and estimated damping ratios: case 1, known reference signal disp('Estim. damping, std(damping), estim. - true')[ThetaML1.poles.damp, CRbound1.poles.damp.^0.5, ThetaML1.poles.damp-Poles0.damp]