function TheJacob = MIMO_ML_Jacob(data, xMat, Error, PolyTrans, ModelVar);%%      TheJacob = MIMO_ML_Jacob(data, xMat, Error, PolyTrans, ModelVar)%%   Calculates the jacobian matrix w.r.t. ALL the plant and transient model%   parameters.%	The selection of the free model parameters, and the imposition of the model constraints%	(norm one, reciprocity) is done in the routine MIMO_ML_Add_SelectColumns%%% Output parameters%% 	TheJacob 		=	jacobian matrix, size: ny x ntheta x F %% Input parameters%%		data		=	structure containing the non-parametric data%							data.Y                  =	DFT spectrum ny x 1 output signal, size: ny x F %							data.U                  =	DFT spectrum nu x 1 input signal, size: nu x F %							data.freq               =	vector of frequency values (Hz), size: F x 1%							data.Ts                 =	sampling time (s)%							data.CY                 =	(sample) noise covariance matrix of Y, size: ny x ny x F %                           data.CU                 =   (sample) noise covariance matrix of U, size: nu x nu x F %                           data.CYU                =   (sample) noise covariance matrix of U, size: ny x nu x F %							data.sqrtCYinv          =	CY^(-0.5), size: ny x ny x F %							data.DC                 =	1 if DC present otherwise 0%							data.Nyquist            =	1 if Nyquist frequency present otherwise 0%%		xMat		=	structure with tables of powers of (jwk)^r or (zk^-r)%							xMat.Plant              =	plant model, size: F x max order%%		Error       =	prediction error model equations, size ny x F %%		PolyTrans	=	structure containing the polynomials and transfer functions evaluated in x%							PolyTrans.A             =	denominator polynomial plant transfer function evaluated in x.Plant %                                                       size 1 x F %							PolyTrans.G             =	plant transfer matrix evaluated in x.Plant%                                                       size ny x nu x F %							PolyTrans.Tg            =	plant transient term evaluated in x.Plant%                                                       size ny x F %                           PolyTrans.sqrtCEinv     =   hermitian symmetric square root of the inverse of the covariance of the %                                                       output error (Cov(NY-G*NU)) %%		ModelVar	=	contains the information about the model to be identified%						structure with fields 'Transient', 'ThePlane', 'TheModel', 'Reciprocal', ...%							ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%							ModelVar.PlantPlane		=	plane of the plant model%															's':	continuous-time;%															'w':	sqrt(s)-domain%															'z':	discrete-time;%															'':		plane not defined%							ModelVar.Struct			=	model structure%															'EIV':  errors-in-variables (noisy input-output data)%															'OE':	generalised output error (known input, noisy output)%							ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%							ModelVar.nu				=	number of inputs%							ModelVar.ny				= 	number of outputs%							ModelVar.na				=	order polynomial A%							ModelVar.nb				= 	order matrix polynomial B%							ModelVar.nig			=	order vector polynomial Ig%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, 27 November 2009% All rights reserved.% Software can be used freely for non-commercial applications only.%% note that DC and Nyquist have a contribution 1/2 to the cost function% therefore the appropriate variables must be scaled by 1/sqrt(2) at DC% and Nyquist; this is already done for the variable Error%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculate the derivative of the transfer functions w.r.t. the model parameters %%   a = Theta.A(:)                                                               %      %   b = reshape(permute(Theta.B, [3,1,2]), [ny*nu*(nb+1),1])                     % %   ig = reshape(permute(Theta.Ig, [2,1]), [ny*(nig+1),1])                       % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Deriv = MIMO_ML_CalcDeriv(xMat, PolyTrans, ModelVar);% derivatives of the hermitian transpose of the plant transfer function w.r.t. the model parametersif strcmp(ModelVar.Struct, 'EIV')    Deriv.vecGHa = MIMO_ML_DvecZ2DvecZH(Deriv.vecGa, ModelVar.ny, ModelVar.nu);    Deriv.vecGHb = MIMO_ML_DvecZ2DvecZH(Deriv.vecGb, ModelVar.ny, ModelVar.nu);    end % if errors-in-variables%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% derivative prediction error w.r.t. ALL model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% number of frequenciesF = size(xMat.Plant,1);% order polynomialsna = ModelVar.na;nb = ModelVar.nb;nig = ModelVar.nig;% number of outputs and inputsny = ModelVar.ny;nu = ModelVar.nu;% total number of model parametersntheta = (na+1) + (nb+1)*nu*ny + (nig+1)*ny;TheJacob = zeros(ny, ntheta, F);if strcmp(ModelVar.Struct, 'EIV')        % EIV part Jacobian matrix    Jac_eiv = zeros(ny, ntheta, F);               %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    % Fast calculation of matrices needed for calculating Jac_eiv. The lines below are equivalent with %    % M_vecG = zeros(ny, ny*nu, F);                                                                    %           % M_vecGH = zeros(ny, ny*nu, F);                                                                   % 	% for kk = 1:F                                                                                     %  	%    M1(:,:,kk) = PolyTrans.G(:,:,kk) * data.CU(:,:,kk) - data.CYU(:,:,kk);                        % 	%    V1(:,kk) = PolyTrans.sqrtCEinv(:,:,kk) * Error(:,kk);                                         % 	%    M_vecG(:,:,kk) = kron(V1(:,kk).'*conj(M1(:,:,kk)), PolyTrans.sqrtCEinv(:,:,kk));              %  	%    M_vecGH(:,:,kk) = kron(V1(:,kk).', PolyTrans.sqrtCEinv(:,:,kk)*M1(:,:,kk));                   %  	% end % kk, frequencies                                                                            %     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        M1 = Mat_Mult(PolyTrans.G, data.CU) - data.CYU;                     % Mat_Mult = matrix multiplication    ErrorT = zeros(ny, 1, F);    ErrorT(:,1,:) = Error;    V1 = Mat_Mult(PolyTrans.sqrtCEinv, ErrorT);    V1 = permute(V1, [2,1,3]);                                          % transpose of V1    M_vecG = Kron_Row_Mat(Mat_Mult(V1, conj(M1)), PolyTrans.sqrtCEinv); % Kron_Row_Mat = Kronecker product of a row and a matrix     M_vecGH = Kron_Row_Mat(V1, Mat_Mult(PolyTrans.sqrtCEinv, M1));    end % if errors-in-variables% hermitian square root of the inverse of % the covariance matrix Cov(NY-G*NU)sqrtCEinv = PolyTrans.sqrtCEinv;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative w.r.t. a. The lines below are equivalent with               % % Low = 1;                                                                                       % % Upp = (na+1);                                                                                  % % for kk = 1:F                                                                                   % %	Mat = kron(data.U(:,kk).', sqrtCEinv(:,:,kk));                                               % %	TheJacob(:,Low:Upp,kk) = - Mat * Deriv.vecGa(:,:,kk) - sqrtCEinv(:,:,kk) * Deriv.Tga(:,:,kk) % % end                                                                                            % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% fast calculation Kronecker product dataUT = zeros(1,nu,F);dataUT(1,:,:) = data.U;Mat = Kron_Row_Mat(dataUT, sqrtCEinv);% fast calculation Jacobian matrix w.r.t. aLow = 1;Upp = (na+1);TheJacob(:,Low:Upp,:) = - Mat_Mult(Mat, Deriv.vecGa) - Mat_Mult(sqrtCEinv, Deriv.Tga);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative w.r.t. a. The lines below are equivalent with                         % % Low = 1;                                                                                                 % % Upp = (na+1);                                                                                            % % for kk = 1:F                                                                                             % %	Jac_eiv(:,Low:Upp,kk) = M_vecG(:,:,kk) * Deriv.vecGa(:,:,kk) + M_vecGH(:,:,kk) * Deriv.vecGHa(:,:,kk); % % end                                                                                                      % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if strcmp(ModelVar.Struct, 'EIV')        % fast calculation EIV part Jacobian matrix w.r.t a    Jac_eiv(:,Low:Upp,:) = Mat_Mult(M_vecG, Deriv.vecGa) + Mat_Mult(M_vecGH, Deriv.vecGHa);    end % if errors-in-variables%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative w.r.t. b. The lines below are equivalent with              % % Low = Upp + 1;                                                                                % % Upp = Upp = Low + (nb+1)*ny*nu - 1;                                                           % % for kk = 1:F                                                                                  % %	TheJacob(:,Low:Upp,kk) = - Mat * Deriv.vecGb(:,:,kk)                                        % % end                                                                                           % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% fast calculation derivative w.r.t. bLow = Upp + 1;Upp = Low + (nb+1)*ny*nu - 1;TheJacob(:,Low:Upp,:) = - Mat_Mult(Mat, Deriv.vecGb);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative w.r.t. b. The lines below are equivalent with                         % % Low = Upp+1;                                                                                             % % Upp = Upp = Low + (nb+1)*ny*nu - 1;                                                                      % % for kk = 1:F                                                                                             % %	Jac_eiv(:,Low:Upp,kk) = M_vecG(:,:,kk) * Deriv.vecGb(:,:,kk) + M_vecGH(:,:,kk) * Deriv.vecGHb(:,:,kk); % % end                                                                                                      % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if strcmp(ModelVar.Struct, 'EIV')    % fast calculation EIV part Jacobian matrix w.r.t b    Jac_eiv(:,Low:Upp,:) = Mat_Mult(M_vecG, Deriv.vecGb) + Mat_Mult(M_vecGH, Deriv.vecGHb);    end % if errors-in-variables%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative w.r.t. ig. The lines below are equivalent with             % % for kk = 1:F                                                                                  % %	Low = Upp+1;                                                                                % %	Upp = Low + (nig+1)*ny - 1;                                                                 % %	TheJacob(:,Low:Upp,kk) = - sqrtCEinv(:,:,kk) * Deriv.Tgig(:,:,kk)                           % % end                                                                                           % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% fast calculation derivative w.r.t. igLow = Upp+1;Upp = Low + (nig+1)*ny - 1;TheJacob(:,Low:Upp,:) = - Mat_Mult(sqrtCEinv, Deriv.Tgig);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Set the scaling for DC and Nyquist and add the EIV part %% DC and Nyquist count for 1/sqrt(2)                      %% This is already done in Error and hence also in Jac_eiv %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if data.DC == 1	TheJacob(:,:,1) = TheJacob(:,:,1)/sqrt(2);endif data.Nyquist == 1	TheJacob(:,:,end) = TheJacob(:,:,end)/sqrt(2);endif strcmp(ModelVar.Struct, 'EIV')    TheJacob = TheJacob - 0.5*Jac_eiv;end % if errors-in-variables