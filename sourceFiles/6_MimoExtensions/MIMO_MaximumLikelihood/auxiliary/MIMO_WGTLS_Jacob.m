function TheJacob = MIMO_WGTLS_Jacob(data, xMat, ModelVar);%%      TheJacob = MIMO_WGTLS_Jacob(data, xMat, ModelVar)%%   Calculates the jacobian matrix w.r.t. ALL the plant and transient model parameters.%	The selection of the free model parameters, and the imposition of the model constraints%	(reciprocity) is done in the routine MIMO_ML_AddSelectColumns%%% Output parameters%% 	TheJacob 		=	jacobian matrix, size: ny x ntheta x F%%% Input parameters%%		data		=	structure containing the non-parametric data%							data.Y			=	DFT spectrum ny x 1 output signal, size: ny x F %							data.U			=	DFT spectrum nu x 1 input signal, size: nu x F %							data.freq		=	vector of frequency values (Hz), size: F x 1%							data.Ts			=	sampling time (s)%							data.sqrtWinv	=	square root of the inverse of the weighting matrix W, size: ny x ny x F %							data.DC			=	1 if DC present otherwise 0%							data.Nyquist	=	1 if Nyquist frequency present otherwise 0%%		xMat		=	structure with tables of powers of (jwk)^r or (zk^-r)%							xMat.Plant		=	plant model, size: F x max order%%		ModelVar	=	contains the information about the model to be identified%						structure with fields 'Transient', 'ThePlane', 'TheModel', 'Reciprocal', ...%							ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%							ModelVar.PlantPlane		=	plane of the plant%							model%															's':	continuous-time;%															'w':	sqrt(s)-domain%															'z':	discrete-time;%															'':		plane not defined%							ModelVar.Struct			=	model structure%															'EIV':  errors-in-variables (noisy input-output data)%															'OE':	generalised output error (known input, noisy output)%							ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%							ModelVar.nu				=	number of inputs%							ModelVar.ny				= 	number of outputs%							ModelVar.na				=	order polynomial A%							ModelVar.nb				= 	order matrix polynomial B%							ModelVar.nig			=	order vector polynomial Ig%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, 27 November 2009% All rights reserved.% Software can be used freely for non-commercial applications only.%% note that DC and Nyquist have a contribution 1/2 to the cost function% therefore the appropriate variables must be scaled by 1/sqrt(2) at DC% and Nyquist; this is already done for the variable Error%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% derivative prediction error w.r.t. ALL model parameters     %%   a = Theta.A(:)                                            %      %   b = reshape(permute(Theta.B, [3,1,2]), [ny*nu*(nb+1),1])  % %   ig = reshape(permute(Theta.Ig, [2,1]), [ny*(nig+1),1])    % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% number of frequenciesF = size(xMat.Plant,1);% order polynomialsna = ModelVar.na;nb = ModelVar.nb;nig = ModelVar.nig;% number of outputs and inputsny = ModelVar.ny;nu = ModelVar.nu;% total number of model parametersntheta = (na+1) + (nb+1)*nu*ny + (nig+1)*ny;TheJacob = zeros(ny, ntheta, F);Deriv.Aa = xMat.Plant(:, 1:na+1).';	% derivative A w.r.t. aHinv = data.sqrtWinv;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative of vec(B) w.r.t. b. The lines below are equivalent with % % for kk = 1:F                                                                               % %	 Deriv.vecBb(:,:,kk) = kron(eye(nu*ny, nu*ny), xMat.Plant(kk, 1:nb+1));                  %   % end                                                                                        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Deriv.vecBb = zeros(ny*nu, ny*nu*(nb+1), F);for ii = 1:nu*ny        vii = zeros(nu*ny, 1);    vii(ii) = 1;    Deriv.vecBb(ii,:,:) = kron(vii, (xMat.Plant(:, 1:nb+1)).');    end % ii%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative of Ig w.r.t. ig. The lines below are equivalent with    % % for kk = 1:F                                                                               % %	 Deriv.Igig(:,:,kk) = kron(eye(ny, ny), xMat.Plant(kk, 1:nig+1));                        %   % end                                                                                        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Deriv.Igig = zeros(ny, ny*(nig+1), F);for ii = 1:ny        vii = zeros(ny, 1);    vii(ii) = 1;    Deriv.Igig(ii,:,:) = kron(vii, (xMat.Plant(:, 1:nig+1)).');    end % ii%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative w.r.t. a. The lines below are equivalent with              % % for kk = 1:F                                                                                  % %	Low = 1;                                                                                    % %	Upp = (na+1);                                                                               % %	TheJacob(:,Low:Upp,kk) = (Hinv(:,:,kk) * data.Y(:,kk)) * (Deriv.Aa(:,kk).');                % % end                                                                                           % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculation of the derivative of the residual w.r.t. a for all frequencies DerivResa = zeros(ny,na+1,F);for ii = 1:ny    dataY = data.Y(ii, :).';    DerivResa(ii,:,:) = (Deriv.Aa(1:na+1,:).' .* repmat(dataY, [1, na+1])).';    end % ii% derivative w.r.t. aLow = 1;Upp = (na+1);for ii = 1:ny        Hinvii = squeeze(Hinv(ii,:,:));    if ny == 1        Hinvii = Hinvii.';                                      % squeeze on 1 x 1 x F gives F x 1 !!!    end % if        for jj = Low:Upp                jk = jj-Low+1;        DerivResajj = squeeze(DerivResa(:,jk,:));        if ny == 1            DerivResajj = DerivResajj.';                        % squeeze on 1 x 1 x F gives F x 1 !!!        end % if        TheJacob(ii,jj,:) = sum(Hinvii.*DerivResajj, 1);            end %jj    end % ii%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative w.r.t. b. The lines below are equivalent with              % % for kk = 1:F                                                                                  % %	Low = Upp+1;                                                                                % %	Upp = Low + (nb+1)*ny*nu - 1;                                                               % %	Mat = kron(data.U(:,kk).', squeeze(Hinv(:,:,kk)));                                          % %	TheJacob(:,Low:Upp,kk) = - Mat * Deriv.vecBb(:,:,kk);                                       % % end                                                                                           % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculation of the matrix Mat for all frequenciesUii = zeros(1,1,F);Mat = zeros(ny, nu*ny, F);for ii = 1:nu    Uii(1,1,:) = data.U(ii,:);    columns = [(ii-1)*ny+1:ii*ny];    Mat(:, columns, :) = Hinv .* repmat(Uii, [ny, ny, 1]);end % ii% derivative w.r.t. bLow = Upp+1;Upp = Low + (nb+1)*ny*nu - 1;for ii = 1:ny        Matii = squeeze(Mat(ii,:,:));    if ny*nu == 1        Matii = Matii.';                                        % squeeze on 1 x 1 x F gives F x 1 !!!      end % if    Hinvii = squeeze(Hinv(ii,:,:));    if ny == 1        Hinvii = Hinvii.';                                      % squeeze on 1 x 1 x F gives F x 1 !!!    end % if        for jj = Low:Upp                jk = jj-Low+1;        DerivvecBbjj = squeeze(Deriv.vecBb(:,jk,:));        if nu*ny == 1            DerivvecBbjj = DerivvecBbjj.';                      % squeeze on 1 x 1 x F gives F x 1 !!!        end % if        TheJacob(ii,jj,:) = - sum(Matii.*DerivvecBbjj, 1);            end %jj    end % ii%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the derivative w.r.t. ig. The lines below are equivalent with             % % for kk = 1:F                                                                                  % %	Low = Upp+1;                                                                                % %	Upp = Low + (nig+1)*ny - 1;                                                                 % %	TheJacob(:,Low:Upp,kk) = - Hinv(:,:,kk) * Deriv.Igig(:,:,kk);                               % % end                                                                                           % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% derivative w.r.t. igLow = Upp+1;Upp = Low + (nig+1)*ny - 1;for ii = 1:ny        Hinvii = squeeze(Hinv(ii,:,:));    if ny == 1        Hinvii = Hinvii.';                                      % squeeze on 1 x 1 x F gives F x 1 !!!    end % if        for jj = Low:Upp                jk = jj-Low+1;        DerivIgigjj = squeeze(Deriv.Igig(:,jk,:));        if ny == 1            DerivIgigjj = DerivIgigjj.';                        % squeeze on 1 x 1 x F gives F x 1 !!!        end % if        TheJacob(ii,jj,:) = - sum(Hinvii.*DerivIgigjj, 1);            end %jj    end % ii% DC and Nyquist count for 1/sqrt(2)if data.DC == 1	TheJacob(:,:,1) = TheJacob(:,:,1)/sqrt(2);endif data.Nyquist == 1	TheJacob(:,:,end) = TheJacob(:,:,end)/sqrt(2);end