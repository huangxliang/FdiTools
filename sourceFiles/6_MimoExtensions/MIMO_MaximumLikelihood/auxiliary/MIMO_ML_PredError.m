function TheError = MIMO_ML_PredError(data, PolyTrans);%%	TheError = MIMO_ML_PredError(data, PolyTrans)%%	Output parameters%%		TheError	=	prediction error model equations, size ny x F%						TheError = CY^(-1/2) * (Y - G * U - Tg)%%	Input parameters%%		data		=	structure containing the non-parametric data%							data.Y              =	DFT spectrum ny x 1 output signal, size: ny x F %							data.U              =	DFT spectrum nu x 1 input signal, size: nu x F %							data.freq           =	vector of frequency values (Hz), size: F x 1%							data.Ts             =	sampling time (s)%							data.CY             =	(sample) noise covariance matrix of Y, size: ny x ny x F %                           data.CU             =   (sample) noise covariance matrix of U, size: nu x nu x F %                           data.CYU            =   (sample) noise covariance matrix of U, size: ny x nu x F %							data.sqrtCYinv      =	CY^(-0.5), size: ny x ny x F %							data.DC             =	1 if DC present otherwise 0%							data.Nyquist        =	1 if Nyquist frequency present otherwise 0%%		PolyTrans	=	structure containing the polynomials and transfer functions evaluated in x%							PolyTrans.A             =	denominator polynomial plant transfer function evaluated in x.Plant %                                                       size 1 x F %							PolyTrans.G             =	plant transfer matrix evaluated in x.Plant%                                                       size ny x nu x F %							PolyTrans.Tg            =	plant transient term evaluated in x.Plant%                                                       size ny x F %                           PolyTrans.sqrtCEinv     =   hermitian symmetric square root of the inverse of the covariance of the %                                                       output error (Cov(NY-G*NU)) %%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, November 2009% All rights reserved.% Software can be used freely for non-commercial applications only.%ny = size(data.Y, 1);	% number of outputsnu = size(data.U, 1);	% number of outputsF = size(data.Y, 2);	% number of frequenciesY = data.Y;U = data.U;G = PolyTrans.G;sqrtCEinv = PolyTrans.sqrtCEinv;Tg = PolyTrans.Tg;TheError = zeros(ny, F); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fast calculation of the prediction error TheError: the lines below are equivalent with %% for kk = 1:F                                                                           %% 	TheError(:, kk) = sqrtCEinv(:, :, kk)*(Y(:, kk) - G(:, :, kk)*U(:, kk) - Tg(:, kk)); %% end                                                                                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%UT = zeros(1, nu, F);UT(1,:,:) = U;GU = sum(G.*repmat(UT, ny, 1), 2);[rows, columns, depth] = size(GU);GU = squeeze(GU);% squeeze function on 1 x 1 x F delivers F x 1 !!!if rows*columns == 1	GU = GU.'; endE = Y - GU - Tg;ET = zeros(1, ny, F);ET(1,:,:) = E;TheError = sum(sqrtCEinv.*repmat(ET, ny, 1), 2);[rows, columns, depth] = size(TheError);TheError = squeeze(TheError);% squeeze function on 1 x 1 x F delivers F x 1 !!!if rows*columns == 1	TheError = TheError.'; end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DC and Nyquist have half of the weight in the ML cost function %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if data.DC == 1	TheError(:, 1) = TheError(:, 1)/sqrt(2);end % if DCif data.Nyquist == 1	TheError(:, end) = TheError(:, end)/sqrt(2);end % if Nyquist