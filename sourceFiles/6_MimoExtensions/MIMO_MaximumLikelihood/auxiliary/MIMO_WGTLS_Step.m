function [Theta, smax, smin] = MIMO_WGTLS_Step(data, x, xMat, Sel, ModelVar);%%	[Theta, smax, smin] = MIMO_WGTLS_Step(data, x, xMat, Sel, ModelVar)%%%	Output parameters%%		Theta		=	new estimate plant, noise, and initial conditions parameters%						structure with fields 'A', 'B', 'Ig'%							Theta = struct('A',[],'B',[], 'Ig', [])%							Theta.A = 1 x (OrderA+1)%								Theta.A(r) = coefficient a(r-1) of Omega^(r-1) %							Theta.B = ny x nu x (OrderB+1)%								Theta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%							Theta.Ig = ny x (OrderIg+1)%								Theta.Ig(i,r) = coefficient ig(i,r-1) of Omega^(r-1) %						Note:	all coefficients (except those for which Sel = 0) are free%								during the minimization + in each iteration step the following%								constraints are imposed:%									norm([a, vec(b), vec(ig)] = 1%%		smax		=	largest singular value of the Jacobian matrix%%		smin		=	smallest singular value of the Jacobian matrix%%%	Input parameters%%		data        =	structure containing the non-parametric data required for the identification%							data.Y          =	output DFT spectra of 1 or nu independent MIMO experiments %                                                   1 MIMO experiment:   ny x F %                                                   nu MIMO experiments: ny x nu x F %							data.U          =	input DFT spectra of 1 or nu independent MIMO experiments %                                                   1 MIMO experiment:   nu x F %                                                   nu MIMO experiments: nu x nu x F %							data.freq       =	vector of frequency values (Hz), size: F x 1%							data.Ts         =	sampling time (s)%							data.CY         =	(sample) noise covariance matrix of Y %                                               	1 MIMO experiment:   ny x ny x F %                                               	nu MIMO experiments: ny x ny x nu x F %                           data.CU         =   (sample) noise covariance matrix of U  %                                               	1 MIMO experiment:   nu x nu x F %                                               	nu MIMO experiments: nu x nu x nu x F %                           data.CYU        =   (sample) noise covariance matrix of U %                                                	1 MIMO experiment:   ny x nu x F %                                               	nu MIMO experiments: ny x nu x nu x F %							data.sqrtWinv   =	square root of the inverse weighting matrix %                                                   1 MIMO experiment:   ny x ny x F %                                                   nu MIMO experiments: ny x ny x nu x F %							data.DC			=	1 if DC present otherwise 0%							data.Nyquist	=	1 if Nyquist frequency present otherwise 0%                           data.NumberExp  =   number of independent MIMO experiments (1 or nu) %%		x			=	structure containing (jwk) or (zk^-1) values%							x.Plant	=	plant model, dimension: F x 1 %%		xMat		=	structure with tables of powers of (jwk)^r or (zk^-r)%							xMat.Plant		=	plant model, dimension: F x max order%%		Sel			=	structure with fields 'A', 'B', 'Ig'%							Sel = struct('A',[],'B',[], 'Ig', [])%							Sel.A = 1 x (OrderA+1)%								Sel.A(r) = 1 if coeff. a(r-1) is unknown%								Sel.A(r) = 0 if coeff. a(r-1) = 0%							Sel.B = ny x nu x (OrderB+1)%								Sel.B(i,j,r) = 1 if coeff. b(i,j,r-1) is unknown%								Sel.B(i,j,r) = 0 if coeff. b(i,j,r-1) = 0%							Sel.Ig = ny x (OrderIg+1)%								Sel.Ig(i,r) = 1 if coeff. ig(i,r-1) is unknown%								Sel.Ig(i,r) = 0 if coeff. ig(i,r-1) = 0%%		ModelVar		=	contains the information about the model to be identified%							structure with fields 'Transient', 'ThePlane', 'TheModel', 'Reciprocal', ...%								ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%								ModelVar.PlantPlane		=	plane of the plant model%																's':	continuous-time;%																'w':	sqrt(s)-domain%																'z':	discrete-time;%																'':		plane not defined%								ModelVar.Struct			=	model structure%                                                               'EIV':  errors-in-variables (noisy input-output data)%                                                               'OE':	generalised output error (known input, noisy output)%								ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%								ModelVar.nu				=	number of inputs%								ModelVar.ny				= 	number of outputs%								ModelVar.na				=	order polynomial A%								ModelVar.nb				= 	order matrix polynomial B%								ModelVar.nig			=	order vector polynomial Ig%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, 30 November 2009% All rights reserved.% Software can be used freely for non-commercial applications only.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% initialisation of the variables %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%F = length(data.freq);                              % number of frequenciesNumberExp = data.NumberExp;                         % number of independent MIMO experimentsny = ModelVar.ny;                                   % number of outputsnu = ModelVar.nu;                                   % number of inputsna = ModelVar.na;                                   % order A polynomialnb = ModelVar.nb;                                   % order B matrix polynomialnig = ModelVar.nig;                                 % order Ig vector polynomialntheta = (na+1) + (nb+1)*nu*ny + (nig+1)*ny;        % total number of parametersTheJacob = zeros(NumberExp*ny*F, ntheta);           % the jacobian matrix of all MIMO experimentsTheCovJacob = zeros(NumberExp*F, ntheta, ntheta);   % column covariance matrix of the jacobian matrix of all MIMO experimentsdataee = data;                                      % information about 1 MIMO experiment (see below)dataee.Y = zeros(ny, F);                            % output of 1 MIMO experimentdataee.U = zeros(nu, F);                            % input of 1 MIMO experimentdataee.sqrtWinv = zeros(ny, ny, F);                 % square root of the inverse weigthing matrix of 1 MIMO experimentdataee.CY = zeros(ny, ny, F);                       % output covariance matrix matrix of 1 MIMO experimentdataee.CU = zeros(nu, nu, F);                       % input covariance matrix of 1 MIMO experimentdataee.CYU = zeros(ny, nu, F);                      % output-input covariance matrix of 1 MIMO experiment%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Jacobian matrix and its column covariance matrix w.r.t. the free model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for ee = 1:NumberExp        % data of MIMO experiment no. ee    if NumberExp > 1        dataee.Y(:,:) = data.Y(:,ee,:);        dataee.U(:,:) = data.U(:,ee,:);        dataee.sqrtWinv(:,:,:) = data.sqrtWinv(:,:,ee,:);        dataee.CY(:,:,:) = data.CY(:,:,ee,:);        dataee.CU(:,:,:) = data.CU(:,:,ee,:);        dataee.CYU(:,:,:) = data.CYU(:,:,ee,:);    else % 1 MIMO experiment        dataee.Y(:,:) = data.Y;        dataee.U(:,:) = data.U;        dataee.sqrtWinv(:,:,:) = data.sqrtWinv;        dataee.CY(:,:,:) = data.CY;        dataee.CU(:,:,:) = data.CU;        dataee.CYU(:,:,:) = data.CYU;    end % if more than 1 MIMO experiment        % Jacobian matrix of prediction error w.r.t. ALL model parameters    % size Jacob: ny x ntheta x F    Jacob = MIMO_WGTLS_Jacob(dataee, xMat, ModelVar);    % put the different frequency contributions on top of each other    % size Jacob in: ny x ntheta x F    % size Jacob out: ny*F x ntheta    Jacob = reshape(permute(Jacob, [1,3,2]), [ny*F, ntheta]);        % put experiment no. ee in the Jacobian matrix and prediction error vector    SelectRows = [(ee-1)*ny*F+1:ee*ny*F];    TheJacob(SelectRows, :) = Jacob;        % column covariance matrix jacobian matrix w.r.t. ALL model parameters    % size CovJacob: ntheta x ntheta x F    CovJacob = MIMO_LS_CovJacob(dataee, xMat, ModelVar);        % put experiment no. ee in the Jacobian matrix and prediction error vector    SelectRows = [(ee-1)*F+1:ee*F];    TheCovJacob(SelectRows,:,:) = permute(CovJacob, [3,1,2]);        end % ee, number of MIMO experiments% column covariance matrix jacobian matrix w.r.t. ALL model parametersTheCovJacob = squeeze(sum(TheCovJacob, 1));% impose the common parameter structure and eliminate the excess parameters % size TheJacob in:  NumberExp*ny*F x ntheta% size TheJacob out: NumberExp*ny*F x number of free model parameters% size TheCovJacob in:  ntheta x ntheta% size TheCovJacob out: number of free model parameters x number of free model parameters[TheJacob, TheCovJacob] = MIMO_WGTLS_AddSelectColumns(TheJacob, TheCovJacob, Sel, ModelVar);% scaling of the columns of the Jacobian matrix to improve the condition number TheScale = sum(abs(TheJacob.^2), 1).^0.5;IndexZeroes = find(TheScale == 0);TheScale(IndexZeroes) = 1;TheJacob = TheJacob ./ repmat(TheScale, [size(TheJacob, 1), 1]);% scaling of the column covariance matrix of the jacobian matrixCovScale = TheScale.' * TheScale;TheCovJacob = TheCovJacob ./ CovScale;% calculation of a symmetric square root of the real part of the column% covariance matrix of the jacobian matrix[uc, sc, vc] = svd(real(TheCovJacob), 0);sqrtCovJacob = vc * diag(diag(sc).^0.5) * vc.';%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculate the GTLS-solution %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[U, V, X, C, S] = gsvd([real(TheJacob); imag(TheJacob)], sqrtCovJacob, 0);% solution requires GSVD(A,B) with A = Ua*Sa*inv(X) and B = Ub*Sb*inv(X) while Matlab routine% gives A = Ua*Sa*X' and B = Ub*Sb*X'X = inv(X');% remove singular values equal to infinityCd = diag(C);Sd = diag(S);index = find(Sd~=0);Cd = Cd(index);Sd = Sd(index);X = X(:,index);% select smallest singular valueSingVal = Cd./Sd;[smin, index] = min(SingVal);Param = X(:,index);Param = Param/norm(Param);% denormalisation parameter variationParam = Param ./ TheScale.';% calculate the condition number of the GTLS solutionSingVal = sort(SingVal);smax = SingVal(end);if length(SingVal) > 1	smin = SingVal(2);else	smin = smax;end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% extract the plant model parameters from Param %% order in Param: a, b, ig                      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%ny = ModelVar.ny;nu = ModelVar.nu;na = ModelVar.na;nb = ModelVar.nb;nig = ModelVar.nig;OldTheta.A = zeros(1, na + 1);OldTheta.B = zeros(ny, nu, nb + 1);OldTheta.Ig = zeros(ny, nig + 1);Theta = MIMO_ML_ExtractParam(Param, OldTheta, Sel);	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Impose constraints on updated parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Theta = MIMO_ML_Constrain(Theta, ModelVar);