function TheCost = MIMO_ML_Cost(data, Theta, x, ModelVar);%%	TheCost = MIMO_ML_Cost(data, Theta, x, ModelVar); %% Calculates the cost function for identifying plant models with arb. signals%%%	Output arguments%%		TheCost 	=	value cost function%%%	Input arguments%%		data		=	structure containing the non-parametric data required for the identification%							data.Y          =	output DFT spectra of 1 or nu independent MIMO experiments %                                                   1 MIMO experiment:   ny x F %                                                	nu MIMO experiments: ny x nu x F %							data.U          =	input DFT spectra of 1 or nu independent MIMO experiments %                                                	1 MIMO experiment:   nu x F %                                               	nu MIMO experiments: nu x nu x F %							data.freq       =	vector of frequency values (Hz), size: F x 1%							data.Ts         =	sampling time (s)%							data.CY         =	(sample) noise covariance matrix of Y %                                               	1 MIMO experiment:   ny x ny x F %                                                	nu MIMO experiments: ny x ny x nu x F %                           data.CU         =   (sample) noise covariance matrix of U  %                                                   1 MIMO experiment:   nu x nu x F %                                                	nu MIMO experiments: nu x nu x nu x F %                           data.CYU        =   (sample) noise covariance matrix of U %                                                	1 MIMO experiment:   ny x nu x F %                                               	nu MIMO experiments: ny x nu x nu x F %							data.sqrtCYinv	=	CY^(-0.5); if OE %                                                	1 MIMO experiment:   ny x ny x F %                                               	nu MIMO experiments: ny x ny x nu x F %							data.DC			=	1 if DC present otherwise 0%							data.Nyquist	=	1 if Nyquist frequency present otherwise 0%                           data.NumberExp  =   number of independent MIMO experiments (1 or nu) %%		Theta		=	estimated value plant, noise, and initial conditions parameters%						structure with fields 'A', 'B', 'Ig'%							Theta = struct('A',[],'B',[], 'Ig', [])%							Theta.A = 1 x (OrderA+1)%								Theta.A(r) = coefficient a(r-1) of Omega^(r-1) %							Theta.B = ny x nu x (OrderB+1)%								Theta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%							Theta.Ig = ny x (OrderIg+1)%								Theta.Ig(i,r) = coefficient ig(i,r-1) of Omega^(r-1) %%		x			=	structure containing (jwk) or (zk^-1) values%							x.Plant	=	plant model, dimension: F x 1%%		ModelVar	=	contains the information about the model to be identified%							structure with fields 'Transient', 'ThePlane', 'TheModel', 'Reciprocal', ...%								ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%								ModelVar.PlantPlane		=	plane of the plant model%																's':	continuous-time;%																'w':	sqrt(s)-domain%																'z':	discrete-time;%																'':		plane not defined%								ModelVar.Struct			=	model structure%                                                               'EIV':  errors-in-variables (noisy input-output data)%                                                               'OE':	generalised output error (known input, noisy output)%								ModelVar.nu				=	number of inputs%								ModelVar.ny				= 	number of outputs%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, November 2009% All rights reserved.% Software can be used freely for non-commercial applications only.%% initialisation variablesNumberExp = data.NumberExp;ny = ModelVar.ny;nu = ModelVar.nu;F = length(data.freq);TheError = zeros(NumberExp*ny, F);dataee = data;                                  % information about 1 MIMO experiment (see below)dataee.Y = zeros(ny, F);                        % output of 1 MIMO experimentdataee.U = zeros(nu, F);                        % input of 1 MIMO experimentdataee.CY = zeros(ny, ny, F);                   % output covariance of 1 MIMO experimentswitch ModelVar.Struct    case 'EIV'        dataee.CU = zeros(nu, nu, F);           % input covariance of 1 MIMO experiment        dataee.CYU = zeros(ny, nu, F);          % output-input covariance of 1 MIMO experiment    case 'OE'        dataee.sqrtCYinv = zeros(ny, ny, F);end % switch% transfer functions and polynomialsPolyTrans = MIMO_ML_CalcPolyTrans(Theta, x);for ee = 1:NumberExp        % data of MIMO experiment no. ee    if NumberExp > 1        dataee.Y(:,:) = data.Y(:,ee,:);        dataee.U(:,:) = data.U(:,ee,:);        dataee.CY(:,:,:) = data.CY(:,:,ee,:);         switch ModelVar.Struct            case 'EIV'                dataee.CU(:,:,:) = data.CU(:,:,ee,:);                dataee.CYU(:,:,:) = data.CYU(:,:,ee,:);                          case 'OE'                dataee.sqrtCYinv(:,:,:) = data.sqrtCYinv(:,:,ee,:);        end % switch    else % 1 MIMO experiment        dataee.Y(:,:) = data.Y;        dataee.U(:,:) = data.U;        dataee.CY(:,:,:) = data.CY;        switch ModelVar.Struct            case 'EIV'                dataee.CU(:,:,:) = data.CU;                dataee.CYU(:,:,:) = data.CYU;                          case 'OE'                dataee.sqrtCYinv(:,:,:) = data.sqrtCYinv;        end % switch    end % if more than 1 MIMO experiment         % calculate a hermitian square root of the inverse       % of the covariance of the output error (NY-G*NU)    switch ModelVar.Struct        case 'EIV'            PolyTrans = MIMO_ML_InvCovOutputError(dataee, PolyTrans);        case 'OE'            PolyTrans.sqrtCEinv = dataee.sqrtCYinv;    end % switch    % prediction Error; size ny x F    Error = MIMO_ML_PredError(dataee, PolyTrans);        % put experiment no. ee in the prediction error vector    SelectRows = [(ee-1)*ny+1:ee*ny];    TheError(SelectRows, :) = Error;end % ee, number of MIMO experiments% cost functionTheCost = norm(TheError(:))^2;