function TheJacob = MIMO_ML_AddSelectColumns(TheJacob, TheSel, ModelVar);%% function TheJacob = MIMO_ML_AddSelectColumns(TheJacob, TheSel, ModelVar);%%	Imposes the common parameter structure (reciprocal) by%	adding the appropriate columns, and selects the columns of the %	Jacobian matrix corresponding to the parameters to be estimated%%%	Output parameter%%		TheJacob			=	Jacobian matrix after imposing the common parameter structure,%								all other parameters (except those who are zero) are free%								size: ny * number of freq. x number of parameters%%%	Input parameter%%		TheJacob			=	Jacobian matrix before imposing the common parameter structure:%								all parameters (even those who are zero) are free%								size: ny * F x ntheta %%		TheSel				=	structure with fields 'A', 'B', 'Ig'%									TheSel = struct('A',[],'B',[], 'Ig', [])%									TheSel.A = 1 x (OrderA+1)%										TheSel.A(r) = 1 if coeff. a(r-1) is unknown%										Sel.A(r) = 0 if coeff. a(r-1) = 0%									TheSel.B = ny x nu x (OrderB+1)%										TheSel.B(i,j,r) = 1 if coeff. b(i,j,r-1) is unknown%										TheSel.B(i,j,r) = 0 if coeff. b(i,j,r-1) = 0%									TheSel.Ig = ny x (OrderIg+1)%										TheSel.Ig(i,r) = 1 if coeff. ig(i,r-1) is unknown%										TheSel.Ig(i,r) = 0 if coeff. ig(i,r-1) = 0%%		ModelVar			=	contains the information about the model to be identified%									ModelVar.Transient		=	1 then the initial conditions of the plant are estimated%									ModelVar.PlantPlane		=	plane of the plant model%																	's':	continuous-time;%																	'w':	sqrt(s)-domain%																	'z':	discrete-time;%																	'':		plane not defined%									ModelVar.Struct			=	model structure%																	'BJ':		Box-Jenkins%																	'OE':		output error (plant model only)%																	'ARMA':		autoregressive moving average (noise model only)%																	'ARMAX':	autoregressive moving average with exogenous input%									ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%									ModelVar.nu				=	number of inputs%									ModelVar.ny				=	number of outputs%									ModelVar.na				=	order polynomial A%									ModelVar.nb				=	order matrix polynomial B%									ModelVar.nig			=	order vector polynomial Ig%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, November 2009% All rights reserved.% Software can be used freely for non-commercial applications only.%% order polynomialsna = ModelVar.na;nb = ModelVar.nb;nig = ModelVar.nig;% inputs and outputsnu = ModelVar.nu;ny = ModelVar.ny;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% summing columns Jacobian matrix in case of a reciprocal plant model structure %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if ModelVar.RecipPlant	    start = (na+1) + 1;								% ofset for coefficients A polynomial    for jj = 1:nu									% column index        for ii = 1+jj:ny							% row index            lij = ii + ny*(jj-1);					% block position coefficients b(ii,jj) polynomial            lji = jj + ny*(ii-1);					% block position coefficients b(jj,ii) polynomial            if lji <= nu*ny							% test for rectangular matrices                startij = start + (lij-1)*(nb+1);                stopij = start + lij*(nb+1) - 1 ;                startji = start + (lji-1)*(nb+1);                stopji = start + lji*(nb+1) - 1 ;                TheJacob(:, startij:stopij) = TheJacob(:, startij:stopij) + TheJacob(:, startji:stopji);            end % if        end % ii    end % jjend % if reciprocal plant model%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% create row vector that selects the columns of the Jacobian %% matrix corresponding to the parameters to be estimated 	 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% A polynomialSelect = TheSel.A;% B ny x nu matrix polynomial% for jj = 1:nu% 	for ii = 1:ny% 		Select = [Select, squeeze(TheSel.B(ii,jj,:)).'];% 	end % ii% end % jjSelB = permute(TheSel.B,[3, 1, 2]);     %  reason: vec(B) is calculated as: vecB = permute(B, [3, 1, 2]); vecB = vecB(:);Select = [Select, SelB(:).'];% Ig ny x 1 vector polynomial% for ii = 1:ny% 	Select = [Select, TheSel.Ig(ii,:)];% end % iiSelIg = TheSel.Ig.';Select = [Select, SelIg(:).'];%%%%%%%%%%%%%%%%%%%%%%%%%%%% selection columns Jacob %%%%%%%%%%%%%%%%%%%%%%%%%%%%TheJacob = TheJacob(:, Select == 1);