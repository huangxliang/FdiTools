function [CRbound, G, Theta, CovThetan, Thetan, Seln, wscale, TheCond] = MIMO_ML_CRbound(data, Sel, Theta, ModelVar);%% [CRbound, G, Theta, CovThetan, Thetan, Seln, wscale, TheCond] = MIMO_ML_CRbound(data, Sel, Theta, ModelVar);%%   Calculates the CR-bound of the physical plant model parameters%   (asymptotically the influence of the plant and noise transients is zero)%					%				Stochastic framework: errors-in-variables%					Y = B/A U0 + NY%					U = U0 + NU	%%				System with nu inputs and ny outputs%					Y:					ny x 1 observed output%					U:					nu x 1 observed input%%				Model class: common denominator model%					G = B/A:			ny x nu plant transfer function%					A:					polynomial of order OrderA%					B:					ny x nu matrix polynomial of order OrderB%%				Coefficients polynomials in raising powers of Omega, where%					s-domain			Omega = j*2*pi*freq%					sqrt(s)-domain		Omega = sqrt(j*2*pi*freq)%					z-domain			Omega = exp(-j*2*pi*freq*Ts)%%       References:%%                   Pintelon, R., P. Guillaume, and J. Schoukens (2007). Uncertainty calculation in (operational) modal analysis, %                   Mechanical Systems and Signal Processing, vol. 21, no. 6, pp. 2359-2373.%%                   Pintelon, R., J. Schoukens, G. Vandersteen, and K. Barbé (2010). Estimation of nonparametric noise and %                   FRF models for multivariable systems - Part II: extensions, applications, Mechanical Systems and %                   Signal Processing, vol. 24, no. 3, pp. 596-616.%%                   Pintelon, R., G. Vandersteen, J. Schoukens, and Y. Rolain (2011). Improved (non-)parametric identification of dynamic %                   systems excited by periodic signals - The multivariate case, Mechanical Systems and Signal Processing, vol. 25, no. 8, %                   pp. 2892-2922.%%                   Pintelon, R., and J. Schoukens (2012). System Identification: A Frequency Domain Approach, second edition, %                   IEEE Press-Wiley, Piscataway (USA). %%	Output parameters%%		CRbound				=	Cramer-Rao bound of the estimated plant model parameters %								CRbound = struct('A', [], 'AvecB', [], 'vecB', [], 'vecG', [], 'res', [], 'poles')%									CRbound.A               =   FreeParam.A x FreeParam.A%                                                                   CRbound.A(i,j)      =	covariance between free coefficients  %                                                                                           a(i-1) and a(j-1) %							        CRbound.AvecB           =   FreeParam.A x FreeParam.B%                                                                   CRbound.AvecB(i,j)	=   covariance between free coefficients %                                                                                           a(i-1) and vecB(j) %									CRbound.vecB            =   FreeParam.B x FreeParam.B%                                                                   CRbound.vecB(i,j)   =   covariance between vecB(i) and vecB(j) %                                                                                           where vecB = permute(B, [3, 1, 2]); %                                                                                           vecB = vecB(:)%									CRbound.vecG            =   (ny*nu) x (ny*nu) x F%                                                                   CRbound.vecG(i,j,r) =   covariance between vecG(i,r) and %                                                                                           vecG(j,r)%									CRbound.G               =   ny x nu x F%                                                                   CRbound.G(i,j,r)    =   variance G(i,j,r)%%                                   CRbound.res             =   struct{'all', 'sv', 'lsv', 'rsv'}%                                                                   CRbound.res.all     =   covariance matrix of (vec(Res))re; where ()re puts the real%                                                                                           and imaginary parts of the matrix on top of each other; vec()%                                                                                           stacks the columns of the matrix on top of each other; and Res%                                                                                           is a residue matrix of the ny x nu transfer function matrix G = B/A;%                                                                                           size: (2*ny*nu) x (2*ny*nu) x na%                                                                   CRbound.res.sv      =   variance singular values of the residues;%                                                                                           size: min(ny, nu) x na%                                                                   CRbound.res.lsv     =   covariance left singular vectors of the residues [real(ur); imag(ur)];%                                                                                           size: 2*ny x 2*ny x min(ny, nu) x na%                                                                   CRbound.res.rsv     =   covariance right singular vectors of the residues [real(vr); imag(vr)];%                                                                                           size: 2*nu x 2*nu x min(ny, nu) x na%                                   CRbound.poles           =   struct{'root', 'all', 'damp', 'freq', 'time'}%                                                                   CRbound.poles.root	=   cov((root)re); where ()re stacks the real and imaginary part of the root%                                                                                           on top of each other; ; size 2 x 2 x number of roots%                                                                   CRbound.poles.all	=   Cov(roots.all) = cov((roots)re); where the real and imaginary parts of%                                                                                           the vector roots are stacked on top of each other;%                                                                                           size 2*(number of roots) x 2*(number of roots)%                                                                   CRbound.poles.damp	=   variance damping complex roots; entry is NaN for real roots%                                                                   CRbound.poles.freq	=   variance frequency complex roots; entry is NaN for real roots%                                                                   CRbound.poles.time	=   variance time constant real roots; entry is NaN for complex roots%                                   Notes:%                                       - Theta = [A; vec(B)]; size: Number of free parameters x 1%                                       - vec(B) is calculated as follows: vecB = permute(B, [3, 1, 2]); vecB = vecB(:);%                                       - for discrete-time systems the damping (damp), resonance frequency (freq), and time constants %                                         (time) are calculated via the inverse impulse invariant transformation s = log(z)/Ts %                                       - for w = sqrt(s) systems the damping (damp), resonance frequency (freq), and time constants %                                         (time) are calculated via the transformation s = w^2 %%       G                   =	plant transfer matrix evaluated at data.freq, size ny x nu x F%%       Theta               =   constrained physical model parameters, where the free input parameters are defined in Seln,%                               and where the poles, residue matrices, and singular value decomposition of the residue matrices%                               have been added%                               struct('A', [], 'B', [], 'res', [], 'poles', [], 'sv') %									Theta.A         =   1 x (OrderA+1)%                                                           Theta.A(r) = coefficient a(r-1) of Omega^(r-1) %									Theta.B         =   ny x nu x (OrderB+1)%                                                           Theta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%                                   Theta.res       =   struct{'all', 'sv', 'lsv', 'rsv'}%                                                           Theta.res.all       =   residue matrices of the transfer function matrix G = B/A;%                                                                                   size: ny x nu x na %                                                           Theta.res.sv        =   singular values of the residue matrices;%                                                                                   size: min(ny, nu) x na%                                                           Theta.res.lsv       =   left singular vectors of the residue matrices;%                                                                                   size: ny x min(ny, nu) x na%                                                           Theta.res.rsv       =   right singular vectors of the residue matrices;%                                                                                   size: nu x min(ny, nu) x na%                                                           Notes:%                                                                 - the residues are sorted in the same order as the poles %                                                                 - the largest element of the right singular vector is made positive real%                                                                   by multiplying the left and right singular vectors by exp(-j*fi) where%                                                                   fi is the phase of the largest element of the right singular vector%                                   Theta.poles     =   struct{'root', 'damp', 'freq', 'time}%                                                           Theta.poles.root    =   poles of the transfer function matrix G = B/A;%                                                                                   size na x 1%                                                           Theta.poles.damp    =   damping ratio of the poles;%                                                                                   size na x 1%                                                           Theta.poles.freq    =   resonance frequency in Hz of the poles;%                                                                                   size na x 1%                                                           Theta.poles.time    =   time constant in seconds of the real poles;%                                                                                   size na x 1%                                   Notes:%                                       - for discrete-time systems the damping (damp), resonance frequency (freq), and time constants %                                         (time) are calculated via the inverse impulse invariant transformation s = log(z)/Ts %                                       - for w = sqrt(s) systems the damping (damp), resonance frequency (freq), and time constants %                                         (time) are calculated via the transformation s = w^2 %%		CovThetan           =	Cramer-Rao bound of the normalised estimated model parameters, the estimated plant model, and the estimated noise model%								CovThetan = struct('A', [], 'AvecB', [], 'vecB', [], 'all', [], 'poles', [], 'res', [])%                               See CRbound for the defintion of the structure. %                               Should be used for numerical stable calculation of uncertainty bounds; to guarantee the%                               positive semi-definiteness of X.' * CovThetan * X, one should calculate%                                                 (sqrtCovThetan * X).' * (sqrtCovThetan * X) %                               where sqrtCovThetan is a square root of CovThetan calculated via an SVD. %%       Seln                =   structure containing the information about the estimated parameters of Thetan; %                               see Sel in the input parameters%%		Thetan				=	(normalised) estimated plant and noise parameters (see input parameters) were the%								following constraints have been imposed:%                                       - in s-, sqrt(s) domains the parameters are normalised with wscale,%                                         for example, ar * s^r => (ar*wscale^r) * (s/wscale)^r%                                         where wscale.Plant and wscale.Noise are used for the plant and noise model%                                         parameters respectively%                                       - the following constraints on the (normalised) model parameters are imposed%                                           z-domain:               a(0)  =  1,%                                           s-, sqrt(s)-domains:    a(na) =  1%%		wscale				=	angular frequency scaling%%		TheCond				=	condition number Jacobian matrix used to calculate the CR-bound; cond(CR-bound) = TheCond^2%%%	Input parameters%%		data				=	structure containing the non-parametric data required for the identification%									data.U          =	For random signals one of the two following cases: %                                                           - input DFT spectrum 1 MIMO experiment:         nu x F %                                                           - power spectrum 1 MIMO experiment:             nu x nu x F %                                                       For periodic signals one of the two following cases: %                                                           - input DFT spectrum of 1 MIMO experiment:      nu x F %                                                           - input DFT specta of nexp MIMO experiments:	nu x nexp x F %                                                             with nexp >= 1 %									data.freq       =	vector of frequency values (Hz), size: F x 1%									data.Ts         =	sampling time (s)%									data.CY         =	(sample) noise covariance matrix of Y.%                                                       For random signals:%                                                           - covariance of 1 MIMO experiment:              ny x ny x F %                                                       For periodic signals one of the two following cases:  %                                                           - 1 MIMO experiment:                            ny x ny x F %                                                           - nexp MIMO experiments (nexp >= 1):            ny x ny x nexp x F %                                   data.CU         =   (sample) noise covariance matrix of U  %                                                       For random signals:%                                                           - covariance of 1 MIMO experiment:  nu x nu x F %                                                       For periodic signals one of the two following cases:  %                                                           - 1 MIMO experiment:                            nu x nu x F %                                                           - nexp MIMO experiments (nexp >= 1):            nu x nu x nexp x F %                                   data.CYU        =   (sample) noise covariance matrix of U %                                                       For random signals:%                                                           - covariance of 1 MIMO experiment:  ny x nu x F %                                                       For periodic signals one of the two following cases:  %                                                           - 1 MIMO experiment:                            ny x nu x F %                                                           - nexp MIMO experiments (nexp >= 1):            ny x nu x nexp x F %                                   data.dof        =   degrees of freedom of the sample covariance estimates%                                                       (optional, default value dof = inf) %%		Sel					=	struct('A', [], 'B', [])%									Sel.A           =   1 x (OrderA+1)%                                                           Sel.A(r) = 1 if coeff. a(r-1) is unknown%                                                           Sel.A(r) = 0 if coeff. a(r-1) = 0%									Sel.B           =   ny x nu x (OrderB+1)%                                                           Sel.B(i,j,r) = 1 if coeff. b(i,j,r-1) is unknown%                                                           Sel.B(i,j,r) = 0 if coeff. b(i,j,r-1) = 0%%		Theta				=	estimated plant model parameters%								Theta = struct('A', [], 'B', [])%									Theta.A         =   1 x (OrderA+1)%                                                           Theta.A(r) = coefficient a(r-1) of Omega^(r-1) %									Theta.B         =   ny x nu x (OrderB+1)%                                                           Theta.B(i,j,r) = coefficient b(i,j,r-1) of Omega^(r-1)%%		ModelVar			=	contains the information about the model to be identified%								struct('Transient', [], 'PlantPlane', [], 'Struct', [], 'RecipPlant', [])%									ModelVar.Transient		=	1 then the initial conditions of the plant and/or noise are estimated%									ModelVar.PlantPlane		=	plane of the plant model%																	's':	continuous-time;%																	'w':	sqrt(s)-domain%																	'z':	discrete-time;%																	'':		plane not defined%									ModelVar.Struct			=	model structure%                                                                   'EIV':  errors-in-variables (noisy input-output data)%                                                                   'OE':	generalised output error (known input, noisy output)%									ModelVar.RecipPlant		=	1 if plant model is reciprocal: G(i,j) = G(j,i)%%% Copyright (c) Rik Pintelon, Vrije Universiteit Brussel - dept. ELEC, November 2009% All rights reserved.% Software can be used freely for non-commercial applications only.% Version 24 October 2011%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% initialisation of the variables, and compatibility check of the input arguments %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% degrees of freedom of the noise covariance estimatestry	if isempty(data.dof)		data.dof = inf;         % known noise covariances	endcatch	data.dof = inf;             % known noise covariancesend % try% model structure variablesModelVar.PlantPlane = lower(ModelVar.PlantPlane);ModelVar.Struct = upper(ModelVar.Struct);ModelVar.ny = size(data.Y,1);ModelVar.nu = size(data.U,1);% 1. imposes the compatibility of the parameter vector Theta and%    the free model parameters with the model structure% 2. puts the order of the polynomials in ModelVar[Theta, Sel, ModelVar] = MIMO_ML_ModelCompatibility(Theta, Sel, ModelVar);% Check if DC and Nyquist belong to the frequency setif data.freq(1) == 0; data.DC = 1; else data.DC = 0; endif data.freq(end) == 1/(2*data.Ts); data.Nyquist = 1; else data.Nyquist = 0; enddata.freq = data.freq(:);% jw, sqrt(jw), or exp(-jwTs) values for plant and noise modelx = struct('Plant', []);% matrix of powers of x xMat = struct('Plant', []);CovThetan = struct('A', [], 'vecB', [], 'AvecB', [], 'all', [], 'poles', [], 'res', []);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Domain of the plant model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the vector s represents z^-1, s, or sqrt(s) of the plant modelswitch ModelVar.PlantPlane	case {'s','w'}		if ModelVar.PlantPlane == 's'			x.Plant = sqrt(-1)*2*pi*data.freq;		elseif ModelVar.PlantPlane == 'w'			x.Plant = (sqrt(-1)*2*pi*data.freq).^(0.5);		end;		wscale = median(abs(x.Plant));		x.Plant = x.Plant/wscale;	case 'z'		x.Plant = exp(-sqrt(-1)*2*pi*data.freq*data.Ts);		wscale = 1;	case ''		x.Plant = ones(size(data.freq));		wscale = 1;	otherwise, disp('Invalid plant plane ...'), returnendnmax = max([ModelVar.na, ModelVar.nb, ModelVar.nig]);xMat.Plant = MIMO_ML_CalcOmegaMat(x.Plant, nmax);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Normalise the model parameters for s-, and sqrt(s)-domains %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Thetan = MIMO_ML_Normalise(Theta, wscale, ModelVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Impose constraints on the (normalised) model parameters      %%   z-domain:           a0 = 1                                 %%   s-, sqrt(s)-domain: ana = 1                                %% and modify the free model parameter selection accordingly    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% impose the constraints on the model parameters[Thetan, Seln] = MIMO_ML_MonicModel(Thetan, Sel, ModelVar);% store the normalised plant transient term because later on it is deletedSaveIg = Thetan.Ig;   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Cramer-Rao lower bound of the free model parameters %%   CRBound.A                                         %%   CRbound.vecB                                      %%   CRbound.AvecB                                     %%   CRbound.all                                       %   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculation polynomials and transfer functionsPolyTrans = MIMO_ML_CalcPolyTrans(Thetan, x);G = PolyTrans.G;A = PolyTrans.A;% Since they are asymptotically zero, the Cramer-Rao lower bound is not % calculated for the plant and noise transient termsModelVar.Transient = 0;ModelVar.nig = 0;Seln.Ig = zeros(ModelVar.ny, 1);Thetan.Ig = zeros(ModelVar.ny, 1);PolyTrans.Tg = zeros(size(PolyTrans.Tg));% calculate the derivative of the transfer functions w.r.t. the model parametersDeriv = MIMO_ML_CalcDeriv(xMat, PolyTrans, ModelVar);% derivatives of the hermitian transpose of the plant transfer function w.r.t. the model parameters Deriv.vecGHa = MIMO_ML_DvecZ2DvecZH(Deriv.vecGa, ModelVar.ny, ModelVar.nu);Deriv.vecGHb = MIMO_ML_DvecZ2DvecZH(Deriv.vecGb, ModelVar.ny, ModelVar.nu);[CRbound, sqrtCRbound, TheCond] = MIMO_ML_CRtheta(PolyTrans, Deriv, Seln, ModelVar, data);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Cramer-Rao lower bound of the poles and residue matrices %%   CRbound.poles                                          %%   CRbound.res                                            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculate poles and residue matrices and their covariances[CovParam, Param] = CovResidues(Thetan, CRbound, Seln, ModelVar.PlantPlane, data.Ts);% add poles and residue matrices to ThetanThetan.poles = Param.poles;Thetan.res = [];Thetan.res.all = Param.res;Thetan.res.sv = Param.sv;Thetan.res.lsv = Param.lsv;Thetan.res.rsv = Param.rsv;% add poles and residue matrices to CRboundCRbound.poles = CovParam.poles;CRbound.res = CovParam.res;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Cramer-Rao lower bound of the plant transfer function matrix %%   CRBound.vecG                                               %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%CRbound = MIMO_ML_CRtf(CRbound, sqrtCRbound, PolyTrans, Deriv, Seln, ModelVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CR-bound of the estimated normalised parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%CovThetan.A = CRbound.A;CovThetan.vecB = CRbound.vecB;CovThetan.AvecB = CRbound.AvecB;CovThetan.all = CRbound.all;CovThetan.poles = CRbound.poles;CovThetan.res = CRbound.res;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CR-bound of the estimated physical model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% frequency denormalisation CR-bounds plant model parametersCRbound = MIMO_ML_CRboundPhysicalParam(CRbound, Seln, wscale, ModelVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Restore the estimated plant transient parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Thetan.Ig = SaveIg;Seln.Ig = Sel.Ig;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation of the constrained physical model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Thetan: constrained frequency normalised parameters A, B, Ig, res, poles% Theta: constrained physical parameters A, B, IgTheta = MIMO_ML_DeNormalise(Thetan, wscale, ModelVar);if ~strcmp(ModelVar.PlantPlane, 'z')        switch ModelVar.PlantPlane         case 's'            wscale2 = wscale;        case 'w'            % poles are squared in sqrt(s)-domain before calculating            % the resonance frequencies and damping ratios            wscale2 = wscale^2;       end % if        % denormalisation of the poles, frequency and time constants,    % but not the damping because it has no units    Theta.poles = Thetan.poles;    Theta.poles.root = Theta.poles.root * wscale;    Theta.poles.freq = Theta.poles.freq * wscale2;    Theta.poles.time = Theta.poles.time / wscale2;    % denormalisation of the residue matrices and the singular values,     % but not the left and right singular vectors because they have no units    Theta.res = Thetan.res;    Theta.res.all = Theta.res.all * wscale;    Theta.res.sv = Theta.res.sv * wscale;end % if not z-domain