%% Paramteric transfer function modeling of a multiple-input, multiple-output (MIMO) discrete-time % or continuous-time system operating in open loop and excited by random phase multisines.% The identification starts from 2 periods of the transient response to one set of random phase % multisine inputs (1 MIMO experiment). The transients are removed by the local polynomial method % via the function "FastLocalPolyAnal".% Noisy input, noisy output case (errors-in-variables stochastic framework) %% Rik Pintelon, 11 October 2011%%clear allclose all%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Choice discrete-time or continuous-time models, noise standard deviation % % number of samples, sampling period, number of inputs and outputs         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%N = 5000;		% number of time domain samples% discrete-time plant and noise models% NoisePlane = 'z';% PlantPlane = 'z';% continuous-time plant and noise models% NoisePlane = 's';       % continuous-time noise model% PlantPlane = 's';       % continuous-time plant model% sqrt(s) domain plant and noise modelsNoisePlane = 'w';PlantPlane = 'w';RecipPlant = 1;         % 1 => plant model is reciprocal% standard deviation input/output noisestdu = 0.1;switch PlantPlane	case 'z', stde = 1;	case 's', stde = 0.05;    case 'w', stde = 1;end% sampling period Ts, sampling frequency fsTs = 1/5.5;fs = 1/Ts;% frequency band of interestfmin = 0.1;fmax = 2;% number of outputs ny and inputs nuny = 3;         % 1 <= ny <= 3nu = 2;         % 1 <= nu <= 3%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition noise model %%%%%%%%%%%%%%%%%%%%%%%%%%%switch NoisePlane    	case 'z',		c0 = zeros(3,3,3);		c0(1,1,:) = fliplr([3.5666e-01   0.9830e-01   3.3444e-01]);		c0(2,2,:) = fliplr([1 -1 0.9]);		c0(3,3,:) = fliplr([9.6478e-01   -5.4142e-01   9.4233e-01]);		c0(3,1,:) = [0.1   -0.15    0];		c0(1,3,:) = c0(3,1,:);		c0(2,3,:) = [0.2 0 0];		c0(3,2,:) = [0.35 0.5 -0.25];		d0 = [1 -0.2 0.85];        	case 's',		c0 = zeros(3,3,3);		% entry 1,1		fz = 1.5/2;		deltaz = 0.1;		TheZero = 2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz);		c0(1,1,:) = fliplr(real(poly([TheZero,conj(TheZero)])));		% entry 2,2		fz = 1.2;		deltaz = 0.05;		TheZero = 2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz);		c0(2,2,:) = fliplr(real(poly([TheZero,conj(TheZero)])));        % c0(2,2,:) = [1 0 0];		% entry 3,3		fz = 0.35;		deltaz = 0.15;		TheZero = 2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz);		c0(3,3,:) = fliplr(real(poly([TheZero,conj(TheZero)])));				fp1 = 0.25;		deltap1 = 0.2;		ThePole1 = 2*pi*sqrt(-1)*fp1*(1 + sqrt(-1)*deltap1);		fp2 = 1;		deltap2 = 0.05;		ThePole2 = 2*pi*sqrt(-1)*fp2*(1 + sqrt(-1)*deltap2);		d0 = real(poly([ThePole1,conj(ThePole1),ThePole2,conj(ThePole2)]));		d0 = real(poly([ThePole2,conj(ThePole2)]));       		d0 = fliplr(d0);             case 'w',		c0 = zeros(3,3,3);		% entry 1,1		fz = 1.5/2;		deltaz = 0.1;		TheZero = (2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz)).^0.5;		c0(1,1,:) = fliplr(real(poly([TheZero,conj(TheZero)])));		% entry 2,2		fz = 1.2;		deltaz = 0.05;		TheZero = (2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz)).^0.5;		c0(2,2,:) = fliplr(real(poly([TheZero,conj(TheZero)])));        % c0(2,2,:) = [1 0 0];		% entry 3,3		fz = 0.35;		deltaz = 0.15;		TheZero = (2*pi*sqrt(-1)*fz*(1 + sqrt(-1)*deltaz)).^0.5;		c0(3,3,:) = fliplr(real(poly([TheZero,conj(TheZero)])));				fp1 = 0.25;		deltap1 = 0.2;		ThePole1 = (2*pi*sqrt(-1)*fp1*(1 + sqrt(-1)*deltap1)).^0.5;		fp2 = 1;		deltap2 = 0.05;		ThePole2 = (2*pi*sqrt(-1)*fp2*(1 + sqrt(-1)*deltap2)).^0.5;		d0 = real(poly([ThePole1,conj(ThePole1),ThePole2,conj(ThePole2)]));		d0 = real(poly([ThePole2,conj(ThePole2)]));       		d0 = fliplr(d0);end % switch NoisePlane% simulate a non-diagonal noise modelswitch NoisePlane        case 'z',        c0(1,2,:) = [0.1 -0.05 0.07]*2;        c0(2,1,:) = c0(1,2,:);        c0(2,1,end) = c0(2,1,end)*0.4;            case {'s','w'}        c0(1,2,:) = 0.1*c0(3,3,:);        c0(2,1,:) = 0.1*c0(1,1,:);        end % switchnc = size(c0, 3) - 1;nd = length(d0) - 1;%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition plant model %%%%%%%%%%%%%%%%%%%%%%%%%%%nmax = 3;switch PlantPlane    	case 'z',        rand('state',0);		b0 = rand(nmax, nmax, 5);		% chebychev polynomial for noise model		[b110, a0] = cheby1(4, 3, 0.5);        	case {'s','w'}        rand('state',0);		b0 = rand(nmax, nmax, 4);		% inverse chebychev polynomial for plant		[b110, a0] = cheby2(4, 40, 2*2*pi,'s');		b110 = fliplr(b110(2:end));		b110(2) = 5e-4;        if PlantPlane == 'w'            ThePoles = roots(a0);            ThePoles = ThePoles.^0.5;            a0 = poly(ThePoles);        end % if sqrt(s)-domain		a0 = fliplr(a0);		b0(1,1,:) = 1*b110;        b0(1,2,:) = b0(1,1,:);        b0(1,3,:) = b0(1,2,:);        b0(2,1,:) = b0(2,1,:);		b0(2,2,:) = fliplr([a0(1) 0 2e-3 1])/10;		b0(3,3,:) = fliplr([2e-3 a0(1) 0 1]);		b0(3,2,:) = fliplr([0 5e-4 a0(1) 1]);        end % switchna = length(a0) - 1;nb = size(b0,3) - 1;% make the plant model reciprocal if requiredif RecipPlant == 1	for ll = 1:nb+1		b0(:,:,ll) = (b0(:,:,ll) + b0(:,:,ll).')/2;	endend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition actuator model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%n_act = 6;                                      % order actuator filtersb_act = zeros(nu, n_act+1);a_act = zeros(nu, n_act+1);[b1, a1] = cheby1(n_act, 6, fmax/(fs/2));       % first input[b2, a2] = butter(n_act, fmax/(fs/2));          % second input[b3, a3] = ellip(n_act, 6, 60, fmax/(fs/2));    % third inputb_act = [b1; b2; b3];a_act = [a1; a2; a3];%%%%%%%%%%%%%%%%%%%%%%%%%%% Set the default values %%%%%%%%%%%%%%%%%%%%%%%%%%%[Sel, Theta0, ModelVar, IterVar] = MIMO_ML_DefaultValues(na, nb, nu, ny, PlantPlane);% Note: the default value of ModelVar.Struct = 'EIV'% reciprocity of the plant model is imposed belowModelVar.RecipPlant = RecipPlant;Select = [ceil(fmin/(fs/N))+1:1:floor(fmax/(fs/N))+1].';	% select from 0.1 Hz to 2 Hzfreq = (Select-1)*fs/N;SelectAll = [1:1:2*N+1].';                                  % from DC to Nyquist on 4*N pointsfreqAll = ((SelectAll-1)/(4*N)/Ts);% powers of jw or exp(-jw*Ts)switch PlantPlane	case 's', sAll = sqrt(-1)*2*pi*freqAll;	case 'w', sAll = (sqrt(-1)*2*pi*freqAll).^0.5;endswitch NoisePlane	case 's', sAll = sqrt(-1)*2*pi*freqAll;	case 'w', sAll = (sqrt(-1)*2*pi*freqAll).^0.5;end%%%%%%%%%%%%%%%%%%%%%%%%%% True model parameters %%%%%%%%%%%%%%%%%%%%%%%%%%Theta0.A = a0;for ii = 1:ny	for jj = 1:nu		Theta0.B(ii,jj,:) = b0(ii,jj,:);	end % jjend % iiTheta0.B = Theta0.B(1:ny,1:nu,:);Theta0.D = d0;for ii = 1:ny	for jj = 1:ny		Theta0.C(jj,ii,:) = c0(jj,ii,:);	endendTheta0.C = Theta0.C(1:ny,1:ny,:);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Definition MIMO multisine experiment %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%ExcitedHarm = Select-1;AmplExcitedHarm = ones(nu, length(ExcitedHarm));AmplExcitedHarm(:,end/2+1:end) = 0.5;RmsValues = ones(nu, 1);RmsValues = linspace(1.5, 0.5, nu);% random phase multisine excitationsr = Calc_MIMO_Multisine(ExcitedHarm, N, AmplExcitedHarm, RmsValues);% select 1 MIMO experimentr = squeeze(r(:,1,:)); if nu == 1    r = r.';end % if one input%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Deterministic part output %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% calculate 4 periods of the transient response of the % actuators to the random phase multisinesu0 = zeros(nu, 4*N);         for ii = 1:nu    u0(ii, :) = filter(b_act(ii, :), a_act(ii, :), repmat(r(ii, :), [1, 4]));    end % iiswitch ModelVar.PlantPlane   	case 'z',                   % calculation 2 periods transient response in time domain via filter        % only the first 2 periods are needed		u0 = u0(:,1:2*N);        y0 = zeros(ny, 2*N);		for jj=1:ny			for ii=1:nu				y0(jj,:) = y0(jj,:) + filter(squeeze(b0(jj,ii,:)), a0, u0(ii,:));			end % ii		end % jj        	case {'s','w'}               % calculation 2 periods transient response via the frequency domain 		U0 = fft(u0,[],2);       % fft based on 4 periods		Y0 = zeros(ny, length(SelectAll));		for jj=1:ny			for ii=1:nu				Y0(jj,:) = Y0(jj,:) + ((polyval(fliplr(squeeze(b0(jj,ii,:)).'),sAll)./polyval(fliplr(a0),sAll)).').*U0(ii,SelectAll);			end % ii		end % jj		y0 = 2*real(ifft([zeros(ny,1),Y0(:,2:end-1),zeros(ny,2*N)],[],2));                % limit response to the first 2 periods		u0 = u0(:,1:2*N);		y0 = y0(:,1:2*N);        end % switch%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Contribution noise to input and output %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% white input noise vuvu = stdu*randn(nu, 2*N);% filtered white output noise vyTe = fliplr(hankel(ones(ny,1)));switch NoisePlane    	case 'z',                       % filter operation in the time domain		e = stde*randn(ny, 2*N);		vy = zeros(ny, 2*N);		e = Te*e;		for jj=1:ny			for ii=1:ny				vy(jj,:) = vy(jj,:) + filter(squeeze(c0(jj,ii,:)),d0,e(ii,:));			end % ii		end % jj        	case {'s', 'w'}                 % calculate the response via the frequency domain		e = stde*randn(ny, 4*N);		e = Te*e;		E = fft(e,[],2);		Vy = zeros(ny, length(SelectAll));		for jj=1:ny			for ii=1:ny				Vy(jj,:) = Vy(jj,:) + ((polyval(fliplr(squeeze(c0(jj,ii,:)).'),sAll)./polyval(fliplr(d0),sAll)).').*E(ii,SelectAll);			end % ii		end % jj		vy = 2*real(ifft([zeros(ny,1),Vy(:,2:end-1),zeros(ny,2*N)],[],2));                % limit response to the first 2 periods		vy = vy(:,1:2*N);        end % switch%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Local polynomial estimate of the FRM, its noise covariance, %% and the input-output sample mean and sample covariances     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% data for FastLocalPolyAnaldata.y = y0 + vy;                   % 2 periods transient response outputdata.u = u0 + vu;                   % 2 periods transient response inputdata.Ts = 1/fs;data.r = r;                         % one period reference signaldata.N = N;                         % number of samples in one perioddata.ExcitedHarm = ExcitedHarm;     % excited harmonics% defintion methodmethod.dof = 6;[CZ, Z, freq, G, CvecG, dof, CL] = FastLocalPolyAnal(data, method);%%%%%%%%%%%%%%%%%%%%%%%%%%%% Data for identification %%%%%%%%%%%%%%%%%%%%%%%%%%%%F = length(freq);                               % number of frequenciesdata_fit.Y = Z.m_NL(1:ny,:);                    % sample mean with transient removaldata_fit.U = Z.m_NL(ny+1:end,:);                % sample mean with transient removaldata_fit.freq = freq;data_fit.Ts = Ts;data_fit.CY = CZ.m_NL(1:ny,1:ny,:);             % sample covariance sample mean with transient removaldata_fit.CU = CZ.m_NL(ny+1:end,ny+1:end,:);data_fit.CYU = CZ.m_NL(1:ny,ny+1:end,:);% Note: since the system is linear Z.n and CZ.n could have been used as well % for the sample means and sample covariances%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Parametric estimate plant model %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% starting values plant model: GTLS estimate followed by BTLS estimate[ThetaWGTLS, smax, smin, wscale] = MIMO_WGTLS(data_fit, Sel, ModelVar);[ThetaBTLS, CostBTLS, smax, smin, wscale] = MIMO_BTLS(data_fit, Sel, ThetaWGTLS, ModelVar, IterVar);% SML estimate[ThetaML, CostML, smax, smin, wscale] = MIMO_ML(data_fit, Sel, ThetaBTLS, ModelVar, IterVar);%%%%%%%%%%%%%%%%%%%%%%%%%%% Cramer-Rao lower bound %%%%%%%%%%%%%%%%%%%%%%%%%%%data_fit.dof = dof.NL;                      % the CR-bound needs variability of the estimated noise (or total) covariancedata_fit.CY = CZ.NL(1:ny,1:ny,:);           % the CR-bound requires the noise (or total) covariance; not the covariance of the sample meandata_fit.CU = CZ.NL(ny+1:end,ny+1:end,:);data_fit.CYU = CZ.NL(1:ny,ny+1:end,:);% Calculation parametric TF model and its covariance; the poles (+ resonance frequency, damping, time constant) and their covariances; % and residue matrices (+ singular values and left and right singular vectors) and their covariances [CRbound, GML, ThetaML, CovThetan, Thetan, Seln, wscale, TheCond] = MIMO_ML_CRbound(data_fit, Sel, ThetaML, ModelVar);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation true plant model and noise power spectrum %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% powers of jw or exp(-jw*Ts)switch PlantPlane	case 'z', x.Plant = exp(-sqrt(-1)*2*pi*freq.'*Ts);	case 's', x.Plant = sqrt(-1)*2*pi*freq.';	case 'w', x.Plant = (sqrt(-1)*2*pi*freq.').^0.5;endswitch NoisePlane	case 'z', x.Noise = exp(-sqrt(-1)*2*pi*freq.'*Ts);	case 's', x.Noise = sqrt(-1)*2*pi*freq.';	case 'w', x.Noise = (sqrt(-1)*2*pi*freq.').^0.5;end% true plant transfer functionPolyTrans0 = MIMO_ML_CalcPolyTrans(Theta0, x);% true noise transfer function H0 = C0/D0H0 = zeros(ny, ny, F);D0 = polyval(fliplr(Theta0.D), x.Noise.');       % true noise denominator for ii = 1:ny	for jj = 1:ny		H0(ii, jj, :) = polyval(fliplr(squeeze(Theta0.C(ii, jj, :)).'), x.Noise.');	end % jjend % iidummy(1,1,:) = D0;H0 = H0./repmat(dummy, ny, ny);% true noise power spectrumCovE = stde^2*Te*Te.';                  % true covariance driving white noise disturbancesSY0 = zeros(ny, ny, F);for kk = 1:F	SY0(:,:,kk) = H0(:,:,kk) * CovE * H0(:,:,kk)';	% remove small imaginary parts on the main diagonal	SY0(:,:,kk) = SY0(:,:,kk) - diag(sqrt(-1)*imag(diag(SY0(:,:,kk))));end % frequencies kk% scaling to have the noise covariance of the Fourier coefficientsP = 2;          % number of periodsSY0 = SY0/(N*P);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Calculation true poles, resonance frequencies, %% damping ratios, time constants                 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% the covariance has no meaning here[CovPoles0, Poles0] = CovRoots(Theta0.A, eye(na+1), Sel.A, PlantPlane, Ts);%%%%%%%%%%%%%%%%%%%%% Plot the results %%%%%%%%%%%%%%%%%%%%%% comparison true noise covariance and nonparametric local polynomial estimateCUn = CZ.n(ny+1:end,ny+1:end,:);           % nonparametric estimate input noise covarianceSU0 = zeros(nu, nu, F);for ii = 1:nu    SU0(ii, ii, :) = stdu^2/(N*P);end % iiFigNum = 1;figure(FigNum)clfmm = 0;for jj = 1:nu    mm = mm+1;    subplot(nu, 1, mm)    plot(freq, db(squeeze(SU0(jj,jj,:)))/2, 'k', freq, db(squeeze(CUn(jj,jj,:)))/2, 'r');    xlabel('Frequency (Hz)')    ylabel('Var. (dB)')end % jjsubplot(nu,1,1)title('True input noise var.: black; Nonparametric estimate: red');zoom on; shg% comparison true noise covariance and nonparametric local polynomial estimateCYn = CZ.n(1:ny,1:ny,:);           % nonparametric estimate output noise covarianceFigNum = FigNum+1;figure(FigNum)clfmm = 0;for jj = 1:ny	for ii = 1:ny		mm = mm+1;        subplot(ny, ny, mm)        plot(freq, db(squeeze(SY0(jj,ii,:)))/2, 'k', freq, db(squeeze(CYn(jj,ii,:)))/2, 'r');        xlabel('Frequency (Hz)')        ylabel('Cov. (dB)')	end % iiend % jjsubplot(ny, ny, ceil(ny/2))title('True output noise cov.: black; Nonparametric estimate: red');zoom on; shg% comparison true plant model and parametric estimateFigNum = FigNum+1;figure(FigNum)mm = 0;for jj = 1:ny	for ii = 1:nu		mm = mm+1;		subplot(ny, nu, mm)		plot(freq, db(squeeze(GML(jj,ii,:))), 'r', freq, db(squeeze(PolyTrans0.G(jj,ii,:))), 'k', ...		     freq, db(squeeze(PolyTrans0.G(jj,ii,:)-GML(jj,ii,:))), 'k--', ...             freq, db(squeeze(CRbound.G(jj,ii,:)))/2, 'r--');	end % iiend % jjsubplot(ny, nu, ceil(nu/2))title('G_0: black; G: red; |G-G_0|: black --; var(G): red --');zoom on; shg% whitness test residuals every CL frequency[Auto_Corr0, Lags0, Conf_Bound0, Fraction0] = WhitenessTestResiduals(G, CvecG.NL, GML, CL.NL, dof.GNL);if nu*ny == 1    Fraction0m = squeeze(Fraction0);elseif ny == 1    Fraction0m = squeeze(mean(Fraction0, 2));elseif nu == 1    Fraction0m = squeeze(mean(Fraction0, 1));else    Fraction0m = mean(mean(Fraction0));end % if disp(['mean fraction outside 50% and 95% confidence bounds: ',num2str(Fraction0m(1)),', and ',num2str(Fraction0m(2))]);F=length(freq);ntheta = sum(Sel.A)+sum(sum(sum(Sel.B))+sum(sum(Sel.Ig))) - 1;Cost0 = dof.NL/(dof.NL-ny)*ny*(F-ntheta/2);stdCost0 = sqrt(3*(dof.NL)^3*ny/(dof.NL-ny)^2/(dof.NL-ny-1)*(F-ntheta/2));disp(['Expected value true cost, std true cost, and actual value cost: ',num2str(Cost0),', ',num2str(stdCost0),', and ',num2str(CostML)]);% comparison true and estimated resonance frequenciesdisp('Estim. f0 [Hz], std(f0) [Hz], estim. - true [Hz]')[ThetaML.poles.freq, CRbound.poles.freq.^0.5, ThetaML.poles.freq-Poles0.freq]% comparison true and estimated damping ratiosdisp('Estim. damping, std(damping), estim. - true')[ThetaML.poles.damp, CRbound.poles.damp.^0.5, ThetaML.poles.damp-Poles0.damp]